= Type Checker [110.99.1 version]
:Author: Dave MacQueen
:Date: 2020/05/09
:stem: latexmath
:source-highlighter: pygments
:VERSION: 110.98

This document is a collection of notes organized in chronological
order based on when ideas occurred to the author(s). The numbering
therefore has no logical significance. Related ideas can appear
scattered through a number of different notes.

Organization and logical coherence are left to a future document
(that would use more sophisticated formatting, citations, etc.)

--------------------------------------------------------------------------------

[0] Agenda: (also, see requirements.txt)

Overall Goal: To reunderstand and redesign type SML/NJ type checker.

* pre- and post-type-checking version of abstract syntax
  i.e. proper "typed abstract syntax" produced by type checker
  - explicit polymorphic type abstraction and instantiation (a la plambda?)

* remove any last vestiges of FLINT interference in the type checker (tycpath)

* redesign type error management and improve type error messages (also wrt modules?)

* translate (FLINT/tran/transtypes.sml) front-end types into "named"-style plambda/flint.

* types/modules interface (probably involved more in module redesign)

* use "modern" BASIS and SML/NJ libraries (such as Atom, sets, maps,
hash-tables, etc.)

* think about infrastructure (interfaces, hooks) for supporing LSP
  (Language Server Protocol - Microsoft technology)

--------------------------------------------------------------------------------
[1] The question of implicit binding of "free type variables" in
expressions.
--------------------------------------------------------------------------------

See Sec 4.6 is Defn of SML 97.

SML 97 introduced syntax for explicitly binding type variables in
declarations.  In SML 90, all bindings of "free" type variables in
expressions were implicit. 

Corresponding discussion in Defn 90 and Commentary?

An example:

[code]

    (* implicit type variable binding *)
    fun f1 (x) =
	let fun h (z) = 
		let fun g () = z :: (nil : 'a list)
		 in z :: x :: nil
		end
	 in h
	end;

    (* explicit type variable binding *)
    fun f1 (x) =
	let fun h (z) = 
		let fun 'a g () = z :: (nil : 'a list)
		 in z :: x :: nil
		end
	 in h
	end;

[end code]

--------------------------------------------------------------------------------
[2] etyvars (type variables appearing free in type definitions)
-------------------------------------------------------------------------------- 
Terminology: a type variable appearing free in an _expression_ (i.e.
appearing in a type constraint or declared type parameter of a val or
fun decl, but not a formal parameter in a type declaration) is called
an "explicit type variable" in the Defn (S 4.6). Another name would be
an "expression type variable".  In either case, the abbreviation
or meta-classificaiton could be "etyvar".

[code]

fun 'a f (x: 'a list) =
    let type 'b t = 'a * 'b  (* SML/NJ doesn't accept "free" 'a in body of defn of t *)
    in (hd x, 3): int t
    end;

[end code]

This is not accepted in SML/NJ, but the Defn appears to allow it
(Section 4.4 and rules (16) and (27)). What do other SML compilers
do with this?  Eplicitly, the question is whether etyvars are allowed
to appear in type declarations (abbreviations or datatypes).

PROPOSAL [sML]: This should be outlawed. The only type variables
allowed in the defn of a type (rhs of a type abbreviation) are
(immediate) parameter variables of that definition appearing on
the lhs.

PROPOSAL [sML]: No type definitions allowed inside expressions.


As a programming guideline, it is also a bad idea to declare
exceptions inside of expressions (i.e. not at "top level", meaning
REPL (interactive) top level or structure top level). There are
algorithms that can make use of "dynamically" declared exceptions
with, say, the body of a recursive function, but this is "tricky"
programming that should not be encouraged.


--------------------------------------------------------------------------------
[3] tycon equality and strictness for DEFtycs
--------------------------------------------------------------------------------

Can two "different" (resulting from different declarations)
strict or non-strict DEFtycs turn out to be equal when their
strictness differs?

Definition of equal for DEFtycs tyc1, tyc2:
- check arities have to be equal, otherwise tyc1 <> tyc2
- apply them both to a tuple of "fresh" atomic types
- fully normalize the results and compare (eqType)

CONJECTURE:
   eqTycon (deftyc1, deftyc2) => strict(deftyc1) = strict(deftyc2)

where strict(DEFtyc{strict,...}) = strict  -- strictness signature : bool list

-------------- 
QUESTION: can a DEFtyc tycon be equal to a non-DEFtyc (atomic/basic) tycon?

E.g. given

   type 'a t = 'a list

is eqTycon(t,list) true?

ANSWER: no, eqTycon is only true when tycons are the same "kind" (e.g.
both GENtyc, both DEFtyc, both PATHtyc, etc).  So a DEFtyc will never
agree (eqTycon) with a basic (atomic) tycon. (but they _can_ unify!)
--------------


--------------------------------------------------------------------------------
[4] deftycs and "equality strictness"
--------------------------------------------------------------------------------
For a deftyc (DEFtyc _), which arguments need to be equality types for
the CONty(deftyc, args) to be an equality type?

E.g.

    type ('a,'b) t = ('a, 'b ref)

is equality strict in 'a but not in beta.  Its equality strictness
signature would therefore be (true, false).


--------------------------------------------------------------------------------
[5] false positive occurrence checks with non-strict deftycs
--------------------------------------------------------------------------------
Sometimes deeper (or full) normalization may be required to detect and
eliminate irrelevant variable occurrences causing false occurrence
check failures.

E.g.

< deftyc application within a deftyc definition >


--------------------------------------------------------------------------------
[6] Issues relating to unification and overloading (functions and literals)
--------------------------------------------------------------------------------

Instantiating an OVLDV tyvar (associated with an overloaded function)
to OVLDI and OVLDW tyvars (associated with overloaded literals).
[See function tyvarInst in Unify (Elaborator/types/unify.sml), and
also possibly unifyTyvars.]

Resolving literal overloading before resolving function overloading
(or vice versa?).


--------------------------------------------------------------------------------
[7] Accurate printing of type (tycon) paths
--------------------------------------------------------------------------------

This is about printing the correct path for tycons at top-level and in
error messages. We want to avoid leading "?.".

* Idea: have a table of "print names" of basic (built-in) tycons.
  So default int type would always print as "int", not "?.int", etc.
  
--------------------------------------------------------------------------------
[8] Presentation of expressions and types in error messages
--------------------------------------------------------------------------------
Expressions: Prettyprinting ast or absyn vs source region excerpts
Types: prettyprinting

Goal is to be as faithful as possible to what the code looked like in
the source file. (or at least "approved style" of code presentation)

* indentation
* comments

Related issues were addressed (long ago) in language "structure
editors".

What is "state of the art" in modern IDE's like Xcode and Visual
Studio, etc.

Main focus is presentation as ascii text (in a terminal or emacs buffer)

Consider whether it might be possible to borrow any mechanism from emacs SML-mode?


--------------------------------------------------------------------------------
[9] Accurate printing of type (tycon) paths
--------------------------------------------------------------------------------

Generally, printing of type names/paths is determined relative to a
current static environment.

Each type constructor contains its own internal version of its "full
name" (a symbolic path, or qualified identifier, a "sympath").

It is possible that the "name" of a type is not in scope (i.e. is not
bound in the current environment).

Defn: sympath is a/the valid name of a tycon:

    valid(tycon,spath,senv)

iff lookup(spath,senv) is defined and is equal to tycon.

In the case where the internal "name" (sympath) is bound in the environment
(i.e. the head symbol is bound, and if it is a structure, the tail of
the path is a valid type name relative to that structure), we print
the shortest _suffix_ of the path that is valid for the tycon.

<further detail for this case>

If the internal "name" (sympath) of a tycon is not "valid for the tycon"
in the current environment, i.e.

   (1) the head symbol is not bound, or
   (2) it is bound to a different tycon, or
   (3) it is bound to a structure, but
       (3.0) the tail of the sympath is nil
       (3.1) the tail of the sympath is not defined for that structure, or
       (3.2) the tail is defined for the structure, but its denotation
             is a module or a different tycon
   
there are a couple of options:

(1) print the sympath name of tycon as is, or left-truncated to the
last symbol (i.e. take the tycon's word for its "birth" name, even
though the birth name is not defined in the current environment. A
variant would be to truncate the name to the last two symbols, e.g.
A.t if the tycon name is X.Y.A.t.

(2) print the internal sympath name, but marked as "not currently
valid", meaning that not (valid(tycon,name(tycon),current_env)). One
way of so marking the sympath is to preceded it with "?." (i.e. add
"?" on the front of the sympath.

(3) For special cases (e.g. pervasive tycons, like int), lookup the
"print name" for the tycon in a global table. For example, Int.int
prints as "int", Int32.int prints as "int32", etc.  Alternatively,
the internal name stored in the tycon could be blessed as "absolute",
regardless of the current environment.

* When printing a type, it is important that different tycons
  appearing in the type should have different print names.  E.g.
  avoid "t * t" where the two occurrences of "t" represent different
  tycons.  (There is a particular danger of this when using the tycon
  naming style where all types are named "t"!)

  
--------------------------------------------------------------------------------
[10] "recoverable" types
--------------------------------------------------------------------------------

For an IDE or LSP communication of type invormation for arbitrary
variables (say, local to a function), what would need to be done.

If I recall correctly, Tolmach's debugger instrumentation had some
capability to reconstruct types of internal variables.

It is not as simple as simply retrieving a type stored in the variable
structure in the abstract syntax.  If one wants to determine the type
in a "dynamic" context (e.g. stack of current function calls), you need
to reconstruct polymorphic instantiations.

For our (potential) purposes (static properties, not debugging), we don't need to
deal with "dynamic" information, but there is still the problem of
determining the type of an applied occurrence of a polymorphic
variable in context. The type checker currently determines the polymorphic
instantiation at each static applied occurrence, and stores that information
in the VARexp absyn structure.  Consider possible alternative
approaches.

Consider how to make this information accessible, say via Microsoft
LSP, or some home-grown, lightweight mechanism within the SML/NJ system.

[This is below the level of "granularity" that CM deals with in its
dependency analysis, which is done at the module level.]


--------------------------------------------------------------------------------
[11] terminology: "constructor" vs "type", "monotype" vs "polytype", etc.
--------------------------------------------------------------------------------
The CMU school (and maybe TaPL? in places), stratifies types into two
layers. The first/lower level types are called "constructors", and the
second/higher level types are called types.

Depending on the particular type system being represented, there is
sometimes an overlap between the "contructs" at the two levels.  For
instance, there may be an arrow operator at both levels.

This stratification roughly corresponds to monotypes and polytypes,
particularly the case of SML with prenex polymorphism, where one
cannot have a function type with polymorphic domain and/or range.

The "constructor" terminology conflicts with well established SML
(SML/NJ) usage of the term "type constructor" (tycon) for a type
function that is used to build structured (non-atomic) type terms. At
the base are nullary tycons like int, real, string, bool, and then
there are non-nullary constructors introduced by datatype
declarations, "type abbreviations" (another bad choice of name), and
tycon exported/imported through (opaque) signatures (or the obsolete
abstype). The point is that tycons represent concrete or abstract
_1st-order_ functions for building types. Some tycons (defined tycons,
type functions) are reducible, and it is therefore sometimes necessary
to talk about reduced (normalized) or head-reduced type terms. All
type terms have a normal form because there is not unmediated
recursion in the definition of type functions.

The main distiction embodied in these layers is between "ordinary"
types that are simple expressions (in a 1st-order, non-recursive
functional language), and polymorphic types that involve universal
(and possibly also existential) quantification over type variables.

I would like to avoid using the "contructor" terminology for basic
types.  Where possible, "monotype" would be more suitable (or perhaps
"simple" types).

In SML, polymorphic abstraction interacts weakly with issues like
normalization of monotypes (i.e. the body of a polymorphic type).
All tycons appearing in the basic types map from basic types to
basic types -- they do not apply to polytypes.  Polymorphic
instantiation is a separate (and orthogonal) process from type
normalization.  For purposes of preserving the "original" form of
types written by the programmer, normalization is done in a "lazy"
fashion.  Polymorphic instantiation is _required_ at every applied
occurrence of a polymorphic (i.e. let-bound) variable.

"tycons" are used to build basic (mono)types. There are four flavors:

(1) primitive tycons:
     nullary tycons for primitive types: e.g. int, real, string
     n-ary tycons: "->", record tycons

(2) datatype tycons:
     predefined: bool, list
     user-defined: datatype declarations

(3) type functions (type abbreviations, defined tycons)
     introduced by "type ..." delcarations
     reducible by type-level beta reduction
     non-recursive

(4) abstract tycons
     introduced by opaque signature matching (RWH "sealing")

Form (3) are reducible by beta-reduction and can therefore be
eliminated (in principle, but not necessarily in practice, as
mentioned above).  The other three forms are "atomic" and irreducible.


--------------------------------------------------------------------------------
[12] experimental, prototype type checkers
--------------------------------------------------------------------------------
Try the experiment of writing type checkers for simply-typed FP (SFP) and
polymorphically-typed FP (PFP).  (see prototc directory)

The question is how etyvars (expression-level) tyvars are introduced
and managed, and, during type checking, how they give rise to
polymorphic types.

We assume that we are generally working with monotypes (simple types,
which may contain (unquantified) type variables). At one special
point, a let-binding, the bound variable is explicitly given a
polymorphic type ("polytype").

Types
-----
*Monotypes* (monomorphic types) are defined as terms over type
variables and type constants.

-- [code]

    type tvar = int  (* trivial representation to begin with *)

    type tycon = int  (* ditto *)

    (* monotypes or "type constructions" *)
    datatype ty
      = INTt
      | BOOLt
      | VARt of tvar
      | PAIRt of ty * ty
      | ARRt of ty * ty
      | APPt of tycon * ty
      | ERRORt  (* produced by the type checker *)

-- [code]

Terminology: a "closed monotype" is a monotype containing no type
variables (i.e. no occurrences of the VARt constructor). An "open"
monotype might contain type variables.  A closed monotype might also
be called a "ground type".

A *polytype* (polymorphic type) is an open monotype "preceded by" a
universal quqntifier over some (zero or more, in some given order)
type variables.

We represent polytypes by the type:

-- [code]

    type pty = tvar list * ty

-- [code]
    
and informally write them as, for example

   [A, B] A -> B   ( for ([A,B], ARRt(VARt A, VARt B) )

using square brackets to indicate universal quantification and using
capital letters for type variables (a la Haskell rather than a la SML).

NOTE: polytypes are a different type from monotypes, so they are
segregated and cannot be confused.  polytypes appear in a restricted
way in the expression abstract syntax (and in the type environment).


Type Environments (tenv)
------------------------
A type-environment (tenv) maps expression variables to their types,
which are explicitly determined at their binding point. There are two
variants of variables/bindings:

  (1) function parameter variables, with (open) monotypes

  (2) let-bound variables with polytypes

Let-bound variables _always_ are assigned polytypes, possibly
degenerate (i.e. of the form ([], ty), with empty list of quantified
type variables). Since _expressions_ are always assigned monotypes,
this means that the type of each applied occurrence of a let-bound
variable must be an monotype "instance" of the polytype of the variable.

-- [code]

    datatype tenv
      = Fbind of var * ty * tenv  (* function parameter binding *)
      | Lbind of var * pty * tenv  (* let binding *)
      | Empty

    datatype binding
      = MONOb of ty
      | POLYb of pty
      | UNDEFb

-- [code]

Type environments are build using the Fbind and Lbind
constructors. They are accessed using a function

    look : var * tenv -> binding


Typed Abstract Syntax
---------------------

Typed abstract syntax is represented using the following types

-- [code]

    type var = int

    datatype texp
      = VAR of var
      | INT of int
      | BOOL of bool
      | PAIR of texp * texp
      | PI1 of texp
      | PI2 of texp
      | LET of var * pty * texp * texp
      | FUN of var * ty * texp
      | APP of texp * texp
      | PINST of var * ty list

-- [code]

An applied occurrence of a function-bound variable is represented by
VARte v, and has the type assigned to it (via Fbind) in the current
tenv. An applied occurrence of a let-bound (polymorphic) variable v
must always occur in the form PINST(v,tys), with an explicit
instantiation.

Example:
--------

The expression written informally as

   let f : [A].A->A = fn x: A => x in (f [int]) 3

is represented as follows:

    val f: var = 0 (* a variable f *)
    val x: var = 1 (* a variable x *)

    val A: tvar = 0 (* a type variable *)

    val exp1 = LET (f, ([A], ARRt(VARt A, VARt A)),
		      FUN(x, VARt A, VAR x),
		      APP (PINST(f, [INTt]), INT 3));

This is type-checked by calling the PFL type checker as follows:

    val f_type = PFL_Typecheck.tych PFL_Tenv.EmptyTenv exp1;
    ==> INTt


NOTE: This abstract syntax is different from the syntax for a full
"polymorphic" functional language, based on the polymorphic lambda
calculus.  In such a language we would have constructors for type
(lambda-)abstraction and type application, such as

    | TFUN of tvar list * texp
    | FAPP of texp * ty list

but these constructs imply "first-class" polymorphism, where a
polymorphic expression (produced by TFUN) could appear in any
expression context, and types would have to allow polymorphic
subterms.

Typing rules for fun, let, var:

[FUN]
    tvars |- ty_arg 
    tvars |- ty_body 
    Fbind(v,ty_arg,tenv), tvars |- body : ty_body
    ---------------------------------------------------------------
    tenv, tvars |- FUN (v, ty_arg, body) : ARRt (ty_arg, ty_body)

[LET]
    tenv, (tvars::tvars0) |- defn : ty
    Lbind(v, (tvars, ty), tenv), tvars0 |- body : ty_body
    -----------------------------------------------------------
    tenv, tvars0 |- LET (v, (tvars, ty), defn, body) : ty_body

[VAR mono]
    tvars |- ty    -- free tvars of ty contained in tvars
    look(v, tenv) = MONOb ty
    -------------------------
    tenv, tvars |- = v : ty

[VAR poly]
    tvars |- ty
    look(v, tenv) = POLYb (tvars, ty)
    -----------------------------------------------
    tenv, tvars |- PINST (v, tys) : {tys/tvars} ty      (* TINST ~~ TAPPt *)
