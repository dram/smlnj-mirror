= Type Checker [110.99.1 version]
:Author: Dave MacQueen
:Date: 2020/05/09
:stem: latexmath
:source-highlighter: pygments
:VERSION: 110.98

[0] Agenda:

Reunderstand and redesign type SML/NJ type checker.

* pre- and post-type-checking version of abstract syntax
  i.e. proper "typed abstract syntax" produced by type checker
  - explicit polymorphic type abstraction and instantiation (a la plambda?)

* remove any last vestiges of FLINT interference in the type checker (tycpath)

* redesign type error management and improve type error messages (also wrt modules?)

* translate (FLINT/tran/transtypes.sml) front-end types into "named"-style plambda/flint.

* types/modules interface (probably involved more in module redesign)

* use "modern" BASIS and SML/NJ libraries (such as Atom, sets, maps,
hash-tables, etc.)


[1] The question of implicit binding of "free type variables" in
expressions.

See Sec 4.6 is Defn of SML 97.

SML 97 introduced syntax for explicitly binding type variables in
declarations.  In SML 90, all bindings of "free" type variables in
expressions were implicit. 

Corresponding discussion in Defn 90 and Commentary?

An example:

[code]

    (* implicit type variable binding *)
    fun f1 (x) =
    let
     fun h (z) = 
	 let fun g () = z :: (nil : 'a list)
	 in z :: x :: nil
	    end
    in h
    end;

    (* explicit type variable binding *)
    fun f1 (x) =
    let
     fun h (z) = 
	 let fun 'a g () = z :: (nil : 'a list)
	 in z :: x :: nil
	    end
    in h
    end;

[end code]

