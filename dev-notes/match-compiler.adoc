= Match Compilation [110.97 version]
:Author: Dave MacQueen
:Date: 2020/05/09
:stem: latexmath
:source-highlighter: pygments
:VERSION: 110.98

== Introduction

This document describes the revised implementation of the match compiler
SML/NJ 110.98. This document replaces the Alex Aiken note.

== Files (relative to base/compiler/FLINT/trans
   mcommon.sml  -- match compiler types
   andor.sml  -- building the and-or trees
   matchcomp.sml  -- the main (or reset of the) match compiler

== Terminology anb basic types

The types used in the match compiler are defined 

- type ruleno = int
   index, zero-based, of a rule in a match (pre- or post- ?) OR expansion
   E.g. "allRules" defined in matchComp, which is the list after OR expansion

- type ruleset = ruleno list = int list
   an ordered list of rule indices (no duplicates) representing rule index sets
   [should be abstract]
   
- type dconinfo = datacon * tyvar list
   a dataconstructor (occurring in a pattern) with an "associated"? list of tyvars
   [Q: what is the relation between the datacon and the tyvars?]

- "destructuring paths" (datatype path)
  [paths that record a position in a decision tree? But paths are _trees_ because
   of the RECORDPATH constructor! ]

Two compilcations in the and-or analysis.

- layered patterns. But the pattern that is layered over a base pattern is
  restricted to be a variable (possibly with at type constraint), so the "information
  content is not modified by a layered pattern. It just introduces a variable
  binding at that node.

- vector patterns. These are _both_ OR (dispatching on the length of the vector)
  and AND in the sense that all the element patterns of the vector pattern must
  be matched.  These two roles could possibly be separated, splitting the node
  into an OR over lengths, and for each 

   case x 
     of #[nil, x::y] => ...
      | #[z::w, nil] => ...

  Here the two patterns are vectors of the same length, but the element patterns
  for OR choices. This case should be analyzed similarly to

   case x 
     of {a = nil, b = x::y} => ...
      | {a = z::w, b = nil} => ...

  where on the "a"-field there is an OR choice on {nil, z::w} and on the "b"-field
  there is an OR choice on {x::y, nil}. But we know (from type-checking} that all
  record patterns at the same node will have the same record type and hence the same
  fields.  So there is no OR choice at the level of the record patterns themselves,
  only at the level of corresponding field patterns, where in this case, both the
  "a"-field and "b"-field give rise to OR choices (which will have to be ordered 
  during the construction of the decision tree).

  But two vector patterns at the same node may be of different lengths:

      case x 
	 of #[nil, x::y] => ...
	  | #[z::w, nil, u] => ...

  Here we do the OR dispatch solely on the vector length, and the respective field
  patterns (here {nil, z::w} for the 1st element) do not constitute an OR choice --
  they are "independent" because they lie in separate OR branches.  This is analagous
  to the following situation:

     datatype t = A of int list * int list
                | B of int list * int list

     case x
       of A(nil,x::y) =>
        | B(z::w,nil) =>

  where we don't dispatch on the {nil, z::w} patterns because the A vs B OR node
  has separated them into two branches.

== And-Or trees

Principles:

- Pattern space (for a type)
  Types are either pattern opaque (atomic) or pattern transparent:

  (1) pattern opaque types are types that are atomic or opaque wrt pattern matching,
      i.e. they cannot be analyzed or deconstructed using pattern matching. 
      These types are function types, abstract types, and primitive types other
      than integers, words, characters and strings. There is, not surprisingly,
      a lot of overlap with "equality" types (types that admit generic equality).

  (2) pattern transparent types are formed by products and sums (datatypes) and
      recursion, plus a small set of primitive types that can match atomic (constant)
      patterns, namely int, word, char, and string types.

Given a pattern-transparent type (pattern type, for short), it can be
unfolded into an infinite (or quasi-infinite, in the case of a
primitive type like int) tree constructed from AND nodes (for
products) and OR nodes for sums. [E.g. infinite (regular) tree for 'a
list.]

A sequence of patterns for a pattern type determines a finite "initial
segment" of the tree for the pattern type. The branches of this initial
tree (the union of the finite branches (paths) in the individual patterns,
is called the pattern spece for the pattern set. The branches are finite and
terminate with (a) atomic variable patterns, or (b) constant patterns, where
a constant can be a constant for a primitive type (e.g. 3) or a constant data
constructor (e.g. true, false, nil).

This is the basic AND-OR tree for the pattern sequence, and it is a concrete 
representation of the pattern space generated by the pattern sequence.

Compilications (for SML)

(1) layered patterns of the form "x as p".
These introduce variable binding points at intermediate nodes in the pattern space.

(2) vector patterns.
These are a variant of datatype OR nodes, where the OR-descrimination is on the
length of the vector pattern. The elements of the vector form an AND node.

A position in the pattern space is determined by a node in the AND-OR tree, which
can be described by a finite path down a branch from the root of the tree.  A
path can be defined as a finite list of "links", where links can be defined by
the datatypes

    datatype link
      = R of int      (* index into a record/tuple product pattern *)
      = VE of int     (* index into the elements of a vector pattern *)
      = D of datacon  (* choice among the decendents of a datatype OR node *)
      = VL of int     (* choice among vector patterns of different lengths *)
      = C of const    (* choice among constants, where const is the sum of the
                         transparent primitive types *)
    type path = link list

The root path is the empty list of links ([]: path).

- a node in an And-Or tree corresponds to a _position_ in the pattern space.

-- a node has an associated rule set that specifies the (rule) patterns
   that are consistent with that node

- a given target value can be propagated down through an And-Or tree, following
  each consistent branch and propagating in parallel though the children of an
  AND node. When it reaches a leaf node, the resulting rule set indicates which
  rule patterns are consistent with that value.  The possible matches are formed
  by taking the intersection of the leaf node rule sets.


== Terms: AND-OR trees, choices, rule sets, relevance

An AND-OR tree is a representation of the pattern space generated by a
sequence of patterns. Each node represents a merging of the
subpatterns at a given point in the pattern space from each pattern in
the sequence. The original patterns all have a common type, and each
node of the AND-OR tree has a type derived from that common types.

It is possible to _match_ a value with an AND_OR tree by "pushing" the value 
(and its subcomponents)) down the branches of the AND_OR tree in parallel. Along
some branches the value will be eliminated because it is not consistent with a
choice (i.e. a nil value will be incompatible with a cons-labeled branch.

A _choice_ (or _choice point_) is a point in the pattern space (a node in the AND-OR tree)
that discrimiates based on one of the following:

(1) datatype constructors (e.g. true vs false or nil vs cons)
(2) vector length
(3) constant value (int, word, char, or string)
    
Thus we distinguish three flavors of choice point. We don't distinguish between
different types of constants, (merging them under type constCon).

At each point in the pattern space (AND-OR node), there is a set of rules that are
compatible with that node (i.e. consistent with choices made on the path from
the root to that node). These rules are said to be "live", or "active" for that point.
Only the live rules actually have a subpattern at this point (as determined by a _path_).

A choice is _relevant_ to a rule (ruleno), if that rule is:

(a) live for that choice point (hasn't been eliminated by an earlier choice along the
     path to this choice point), and 
(b) is not live in some immediate child of that choice point.


This is a binary relation between choices and rules.

Being relevant to more rules is considered a positive property of a choice.
It does more discrimination.

Building a decision tree is a process of choosing an ordering choice points.

Choice points are inherently ordered by their position along branches in the AND-OR
tree. Thus a choice below a given choice must come after the higher choice (higher
and lower being determined by position along a branch. If two choices are not on the
same branch (i.e. the path to one does not go through the other), then they are 
inherently not ordered, or are _independent.

== Variables at nodes

A variable can occur at a node in one of two ways:

(1) an atomic variable node (VAR)
(2) an "as"-bound variable attached to one (or more) of a nodes patterns

Atomic, or terminal variable nodes create defaults.  All rules that are live at
that node remain live through the entire subtree determined by that node (i.e. they
cannot be excluded by a choice.

For instance, consider the pattern sequence

(1)  cons(p1,p2)
(2)  nil
(3)  x

This forms an OR node at the root:

    []: OR-data {1,2,3}
        var: (x, rule 3)
         [D cons]
	    AND {1,3}  [rule 2, nil, is eliminated, but not rule 3]
	      tree(p1)
	      tree(p2)
         [D nil] {2,3} *

All the rules live at the top OR-data node remain live for the two immediate
children nodes.  Note that the variable x does not consitute a child node of
the OR-data node.  But it does influence propagation of liveness -- rule 3 remains
live throughout the subtree (e.g. at [D cons] and [D nil] and in tree(p1) and tree(p2)).

Compare this with

(1)  cons(p1,p2)
(2)  nil

with AND-OR tree:

    []: OR-data {1,2}
         [D cons]
	    AND {1}
	      tree(p1)
	      tree(p2)
         [D nil] {2} *

A layered variable binding does not extend the lifetime of rules:

(1) x as cons(p1,p2)
(2) nil

    []: OR-data {1,2}
        as-var: (x, rule 1)
         [D cons]
	    AND {1}
	      tree(p1)
	      tree(p2)
         [D nil] {2} *

So a primitive var pattern creates a "default" rule that remains live below
(this) node, while a layered variable does not.


== From AND-OR to Decision trees

(1) determine "accessible" list of CHOICE nodes
These are the CHOICE nodes that are accessible from a root (through selection
from AND nodes) without passing through another CHOICE node.  They are located
on paths which contain no OR links.


== Constructing a Decision Tree

(1) Collect the list of "accessible" OR nodes in the AND-OR tree, with accurate
live rule sets, including default rules that result from VAR/VARS nodes.
The rule of a var binding remains live in the AND-OR node containing that variable,
and thoughout the subtree below that node (i.e. its rule cannot be killed by any
choice within that subtree, including the CHOICE that is the root of that subtree.
Note that VAR nodes may be merged with an AND node _above_ the CHOICE node that 
is being evaluated.

(1)  (x,nil)
(2)  (cons(p1,p2), nil)

Here the x at (RL 1) in the first rule creates a default for the choice node 
created by cons(p1,p2), so rule 1 will be live in the choice node generated from
the cons pattern.

As-bound variables (layer variables) do not have this defaulting effect, and therefore
don't affect the selection and ordering of choice nodes during the construction of the
decistion tree (?).  AS-bindings will have to be dealt with later during the translation
of the decision tree into match code.

Once a choice node is chosen as best from the initial list (the highest set of indepenent
choice nodes), we discard that choice from the list and enqueue the accessible choice
nodes from the subtree below the chosen node (if any).  So the set of remaining choice
nodes may grow (or shrink by one if there are no choice nodes below the chosen one in
the AND-OR tree.



Rule sets associated with an AND-OR node:

(1) live rules: relation Live(rule,node)
Defn. A rule is live at a node if there is no OR choice above that node that is not
compatible with that rule. This means that there exists a value that could match that
rule. If the value was pushed down the branches of the andor tree, it would not have
been eliminated by the time it reaches this node.

(2) relevant rules (static?, or relevant to choice order in a decision tree?)
Defn: Relevance (static): a node is (absolutely) relevant to a rule if that
rule is live for the node (Live(rule,node)) and the rule is not live for some
immediate child of the node (i.e. one of the choices rules it out). Can a rule
ruled out for _all_ children?  Two cases

  (a) the rule introduces one of the children of the OR nodes (in which case it
      will be live for that child.
  (b) the rule does not introduce a new child
      (b1) it contains a variant that was already introduced by an earlier rule, in
           which case it is live for that variant
      (b2) it does not introduce a variant at all, in which case it must have
           a variable at this nodes position. In this case it becomes a default
           rule for this node, and for all its descendents, and is therefore 
	   considered "live" (= live union defaults)

(3) default rules: relation Default(rule,node)
Defn: a rule is a default rule at a node if there is a variable binding for that rule
at some node on the path to the node (including the node as the end of the path).
If Default(rule,node), then that rule cannot be ruled out at that node (i.e. the
node is not relevant to that rule.

Example:

  (1) cons(x,     nil)
  (2) cons(true,  cons(y,    nil))
[ (3) cons(false, cons(true, z))  ]
  (4) _

variable x in rule 1 makes rule 1 a default for the [R1,D(cons)] node. Rule 1 is
live for that node and any descendents of that node.

  [] ORdata(list) cons {1,2,3; 4}} (vars = (_,4)) (partial)
     [DL(cons)] AND {1,2,3}
                [RL0] OR(bool) {1,2,3; 1,4}  vars=(x,1)
		      [DL(true)] # {2; 1,4}
		      [DL(false)] # {3; 1,4}
		[RL1] OR(list) {1,2,3; 4}
                      [DL(nil)] # {1; 4}
		      [DL(cons)] AND {2,3; 4}
 		                 [RL0] OR(bool) {2,3; 2,4} (vars = (y,2)) (partial)
				       [DL(true)] # {3; 2,4}
				 [RL1] OR(list) {2,3; 4} (vars = (z,3) (partial)
				       [DL(nil)] {2; 34}

A _partial_ OR node is a datatype or node with not all dataconstructors prepresented
in the children of the node.  

(All constant and vector OR nodes are partial by default.)

live(node) = {rule: Live(rule,node)}

live [] = allrules



================================================================================
Theory
================================================================================

Defn. A patternable type is a type with some concrete product and sum (datatype)
structure at the top (where ty vector is an "honorary datatype descriminating on
the vector lenght).  Some primitive types (int, word, char, string) are also
deemed patternable.  Abstract types and function types are not patternable.

Defn. Abstractly, a tree is a prefix-closed set of paths (Milner, Webs, 1985). Each
path determines a "node" in the tree, and nodes can have attributes attached to them.
"Paths" are lists (finite or infinite) of "links", which may have structure and
attributes of their own.

Defn. Path concatention. If p and p' are paths, p@p' is the concatenation of the
paths, consisting of the links of p followed by the links of p' (the concatenation
of the paths as lists of links).

Defn. A path p' is a _prefix_ of a path p if E(p''). p = p'@p''. (depends on an
equality relation on links)

Defn. If T is a tree, T' \subset T is the _subtree_ at path p if T' consists of all paths
in T having p as an prefix.  Subtree(p,T) = {p' | p@p' \in T).  It is a tree (prefix closed).

Defn. An _initial_ tree of a tree T is a prefix-closed subset of T. A finite initial tree
is an initial tree that is finite.

For any patternable (ML) type t, there is a pattern tree P(t) that expresses the potential
pattern spaces of the type.  This tree has nodes of three kinds:

 (1) product (AND) nodes that may have a finite number of successors (or children)
     indexed by natural numbers (non-negative integers). The subtype at a product
     node is a product (record, tuple) type.

 (2) sum (OR) nodes, that have a finite number of successors indexed by "keys" that
     are either data constructors (datacons) for a datatype, or constants
     (for a patternable primitive type). The subtype at a sum node is a sum type
     (i.e. a datatype).
 (3) terminal (LEAF) nodes for constants (datatype or primitive)

Note: Vector types are treated as a kind of sum type (over some finite
range of vector lengths).  Natural numbers serve as keys for vector
types, indicating to the vector length.

Let t be a patternable type. A pattern pat: t is represented as an initial
tree of P(t).

Defn: Pat(p) \subset P(t) where pat: t.
(inductive definition on pattern structure or concrete structure of type t)

A variable in a pattern generates a (potentially infinite) subtree of the P(t).

Defn. The pattern space of a pattern list is the union of Pat(pi) for pi \in pat list.

This pattern space is represented concretely by an AND-OR tree.


================================================================================
variable patterns, default rulesets, propagation of defaults

[datatype t = A | B | C]
  (1) A
  (2) x
  (3) C

N0:
[] OR(t) {1,2,3}  Vars (x,2)
   [DL(A)] {1; 2}
   [DL(C)] {3; 2}

Rule 2 is default for the DL(A) and DL(C) variants.

Some rules may become "inaccessible" because of defaulting from variables.
In this example, rule (3) will never be "fired" in a match because it is
"shadowed" by rule (2).

Thus rule (3) will never be chosen on a branch of the decision tree (because,
while it may be live at a leaf, it will not be the _least_ live node at a leaf.
Here we have

  [] DEC(t)
     A {1,2}
     C {2,3}
     [B] {2}  -- default branch

C leads to live set {2,3} which will select the least rule, i.e. (2).
B goes down an "else" branch with default ruleset {2}
A leads to live set {1,2} which selects rule (1)
Rule 3 is redundant, will never be matched.

r in Defaults(Node)
  ==>
  (1) Var(Pat(r)[Path(Node)]), or
  (2) Exists p < Path(Node). Var(Pat(r)[p])

which is the same as:

   Exists p <= Path(Node). Var(Pat(r)[p])

This means that Pat(r)[p] _cannot cause a mismatch_.

If for p0 < Path(Node), Var(Pat(r)[p]). r contributes no
pattern structure below p0. There may be pattern structure below
p, but it is contributed by other rules (earlier or later than r).

In above example: Var(Pat(2)[[]])


Defn: Relevant(N,r): An OR node N is relevant to a rule r if
  the choice made at that rule can affect whether that rule matches
  i.e. some variant is compatible with that rule and another variant
  is incompatible with that rule.
  i.e. Pat(r)[Path(N)] is not a variable, therefore is either
       a constant or a constructor (constant or applied)
       therefore Pat(r)[Path(N)] is a key for the choice made
       at N (N.variants).

Defn: Pat(r) (r a ruleno) is the pattern part of rule r (r.pat)

Defn: Pat(r)[p] = pattern element at longest possible prefix of
      path p in Pat(r).

Prop: Var(Pat(r)[N]) <=> r in Defaults(N)

Defn: Given an andor tree N for a given rule set
    Compat(r,p) if Pat(r) is "compatible" with all choices made
    on path p.

Notation: N an andor tree, p a path, Np is the andor tree found at
  the end of path p.
    N[] = N
    N[CL(c)] = LEAF ...
    N[DL(d)] = N' where N = OR{variants=ORdata [(d,N'),...],...}
    N[VL(l)] = N' where N = OR{variants=ORvec [(d,N'),...],...}
    N[RL(i)] = Ni where N = AND [..., Ni,...]
    otherwise, N

Defn: Compat(pattern, andor) : 
      Compat(pat, N[])  -- no choices made (yet) at root path
      Compat(c, N[CL(c)])   -- constant pattern; N is OR[ORconst] = LEAF
      Compat((p0,p1), AND(a0,a1)) if Compat(p0,a0) and Compat(p1,a1)
        -- and so on for n-ary products  (a0 = N[RL(0)], a1 = N[RL(1)]
      Compat(d, N[DL(d)])   -- constant datacon
      Compat(d(p), N[DL(d)]) if Compat(p,N)
      Compat(v, N))  true
   In which case r is live for node N(p)

pat@path = the subpattern (if any) of pat at the point designated
           by path (if "compatible")

Prop: Compat(r,p) <==> r in Live(Node(p)) ?

Prop: If Var(Pat(r)[path]), then r in Defaults(N(path)),
      where N = andor(rules).

Note: Pat(r)[path] is always defined, though the actual path for this
subpattern may be a strict prefix of path.

Example:

  (1)  true,  false, true
  (2)  true,  x,     false
  (3)  false, true,  y

AND-OR tree

[] AND
   [RL(1)] OR(bool) {1,2,3}
           [DL(true) LF {1,2}
           [DL(false) LF {3}
   [RL(2)] OR(bool) {1,3; 2}  var: (x,2)   [2 goes to defaults, not live]
           [DL(true) LF {3; 2}
           [DL(false) LF {1; 2}
   [RL(3)] OR(bool) {1,2; 3}  var: (y,3)
           [DL(true) LF {1; 3}
           [DL(false) LF {2; 3}
   
metric:
   [RL(1)] : (0, 2)   (#defaults,breadth)
   [RL(2)] : (1, 2)   (#defaults,breadth)  (x, 2)
   [RL(3)] : (1, 2)   (#defaults,breadth)  (y, 3)

   [RL(1)] < [RL(2)] = [RL(3)]

Relevance: {1,2,3}, least: 1
   [RL(1)]: true
   [RL(2)]: true
   [RL(3)]: true

Decision tree:

D[RL(1)] {1,2,3}
   true  : {1,2}, least: 1
      Relevance: [RL(2)]: true  (1 not in defaults = {2})
                 [RL(3)]: true  (1 not in defaults = {3})
      D[RL(2)]  {1,3; 2}
         true  : {2!,3} inter {1,2} = {2}, least: 2
	   Relevance: [RL(3)] : true  (2 not in defaults = {3})
	   [RL(3)] {1,2; 3} > {1,3!}
	      true  : {1,3!} inter {2} = empty ==> MATCH!
	      false : {2,3!}, least: 2   
	        no more choices  ==> (2)
	 false : {1,2!} inter {1,2} = {1,2}, least: 1
	   Relevance: [RL(3)] : true  (1 not in defaults = {3})
	   [RL(3)] {1,2; 3}
	      true  : {1,3!} inter {1,2!} = {1}, least : 1  ==> (1)
	        [[no more choices  ==> (1)]]
	      false  : {2,3!} inter {1,2} = {2}, least : 1  ==> (2)
	        [[no more choices  ==> (2)]]
   false : {3}
      Relevance: [RL(2)] : true  (3 not in defaults={2})
                 [RL(3)] : true  (3 not in defaults={2})
      D[RL(2)] {1,3; 2}
         true: {2!,3} inter {3} = {3}, least: 3  ==> (3)
	   [[ Relevance: [RL(3)]: false  (2 in defaults = {2})   [==> (3)] ]]
	 false: {1,2!} inter {3} = {},    ==> MATCH!
	   [[ Relevance: [RL(3)]: true  (1 not in defaults = {3})
	   D[RL(3)]: {1,2; 3}
	      true: {1,3!}, least: 1
	        no more choice nodes  ==> (1)
	      false: {2,3!}, least 2
	        no more choice nodes  ==> (2)  ]]

Abbreviated decision tree:

  [RL(10]
  true =>
    [RL(2)]
    true  => 
      [RL(3)]
      true  => MATCH!
      false => (2)
    false =>
      [RL(3)]
      true  => (1)
      false => (2)
  false =>
    [RL(2)]
     true  => (3)
     false => MATCH!


match?: (true,true,true) ==>  MATCH!
        (false,true,false) ==> (3)
	(false,false,false) ==> MATCH!

Example (where rule is chosen because no relevant OR nodes)

  (1)  A,  false, true
  (2)  B,  x,     false
  (3)  z,  true,  y

AND-OR tree

[] AND
   [RL(1)] OR(t) {1,2,3z}
           [DL(A) LF {1,3z}
           [DL(B) LF {2,3z}
   [RL(2)] OR(bool) {1,2x,3}  var: 2x   [2 goes to defaults, not live]
           [DL(true) LF {2x,3}
           [DL(false) LF {1,2x}
   [RL(3)] OR(bool) {1,2,3y}  var: 3y
           [DL(true) LF {1,3y}
           [DL(false) LF {2,3y}
  
metric(RL(1)) = (1,2)
metric(RL(2)) = (1,2)
metric(RL(3)) = (1,2)
(all three nodes have 1 variable, 2 keys)

accessible = [RL(1),RL(2),RL(3)]

D[RL(1)] {1,2,3}  (= allrules)
   A  : {1,3z}, least: 1
      Relevance: [RL(2)]: true  (1 not in defaults = {2})
                 [RL(3)]: true  (1 not in defaults = {3})
      D[RL(2)]  {1,2x,3}
         true  : {2x,3} inter {1,3zy} = {3zy}, least: 3z  ==> (3)
	 false : {1,2x} inter {1,3zy} = {1}, least: 1
	   Relevance: [RL(3)] : true  (1 not in defaults = {3})
	   [RL(3)] {1,2,3z}
	      true  : {1,3z} inter {1,2x} = {1}, least : 1  ==> (1)
	        [[no more choices  ==> (1)]]
	      false  : {2,3z} inter {3z} = {3z}, least : 3  ==> (3z)
	        [[no more choices  ==> (2)]]
   B : {2,3z}, least: 2
      Relevance: [RL(2)] : false  (2 is in defaults={2x})
                 [RL(3)] : true  (2 not in defaults={3y})
      D[RL(3)] {1,2,3y}
         true: {1,3y} inter {2,3z} = {3yz}, singleton  ==> (3)
	 false: {2,3y} inter {2,3z} = {2,3yz}, least {2},  ==> (2)
	   [[ Relevance: [RL(2)]: false  (2 in defaults = {2x})
   X : {C} {3z} ==> (3)   -- immediate, because singleton live

Abbreviated decision tree:

  [RL(1)]
  A =>
    [RL(2)]
    true  => (3)
    false =>
      [RL(3)]
      true  => (1)
      false => (3)
  B =>
    [RL(3)]
     true  => (3)
     false => (2)
  [C] => {3}

Example (where rule is chosen because no relevant OR nodes)

  (1)  A,  false, true
  (2)  B,  x,     false
  (3)  z,  true,  false

AND-OR tree

[] AND
   [RL(1)] OR(t) {1,2,3z}     var: 3z
           [DL(A) LF {1,3z}
           [DL(B) LF {2,3z}
   [RL(2)] OR(bool) {1,2x,3}  var: 2x   [2 goes to defaults, not live]
           [DL(true) LF {2x,3}
           [DL(false) LF {1,2x}
   [RL(3)] OR(bool) {1,2,3}
           [DL(true) LF {1}
           [DL(false) LF {2,3}
  
metric(RL(1)) = (1,3)
metric(RL(2)) = (1,2)
metric(RL(3)) = (0,2)

accessible = [RL(1),RL(2),RL(3)]

D[RL(3)] {1,2,3}  (= allrules)
  true : {1}, least: 1
      Relevance: [RL(1)]: true  (1 not in {3z})
      Relevance: [RL(2)]: true  (1 not in {2x})  RL(2) chosen by metric
      D[RL(2)] {1,2x,3}
        true : {2x,3} inter {1} = {}  ==> MATCH! 
	false: {1,2x} inter {1} = {1}  =/=> (1)!  -- Don't know whether RL(1) will match!
	   Relevance: [RL(1)]: true  (1 not in {3z})
	   D[RL(1)] {1,2,3z}
	     A: {1,3z} inter {1} = {1}  ==> (1) (no more OR nodes)
	     B: {2,3z} inter {1} = {}  ==> MATCH!
	     [C]: {3z} inter {1} = {}  ==> MATCH!
  false: {2,3}, least 2
      Relevance: [RL(2)]: false  (2 in {2x})
      Relevance: [RL(1)]: true (2 not in {3z})
      D[RL(1)] {1,2,3z}
        A: {1,3z} inter {2,3} = {3}
        B: {2,3z} inter {2,3} = {2,3}, least 2
	   Relevance: [RL(2)]: false (2 in {2x})  ==> (2) least of {2,3}
	[C]: {3z} inter {2,3} = {3z}
	   Relevance: [RL(2)]: true (3 not in {2x})
	   D[RL(2)]: {1.2x.3}
	     true: {2x,3} inter {3z} = {3}  ==> (3) (no more OR nodes)
	     false: {1,2x} inter {3z} = {}  ==> MATCH!
	     
Abbreviated decision tree:

  [RL(3)]
  true =>
    [RL(2)]
    true  => MATCH!
    false =>
      [RL(1)]
      A  => (1)
      B => MATCH!
      *[C] => MATCH!
  false =>
    [RL(1)]
     A => (3)
     B => (2)
     *[C] [RL(2)]
        true => (3)
        false => MATCH!
  
================================================================================
email to Bob, 2020.5.31
================================================================================

I am trying to reconstruct the match compilation algorithm from first
principles (after having spend way too much time trying to reverse
engineer the existing (Bill Aitken) code).  The reverse engineering,
while slow and painful, was one way to come to grips with the
essential ideas.  I have been writing lots of notes as I gradually
understand what is going on.  One simple way of thinking of the
problem is that any “pattern-matchable” type (a type with outer layers
of concrete product/sum structure, plus a few primitive types with
constants allowed in patterns, i.e. int, work, char, string) has an
associated “pattern space” that can be represented as a (potentially
infinite) tree which is obtained by unrolling the concrete structure
(abstract types and function types are “atomic” for this purpose).  A
particular pattern is a finite “initial segment” (prefix-closed set of
paths) in this pattern space, and a set of patterns can be
characterized by the union of the initial segments for the patterns.
This union gives one an AND-OR tree (AND for product nodes, OR for sum
nodes corresponding to datatypes or “open” patternable types like int,
string, exceptions (with unbounded numbers of alternatives).  For
engineering/algorithmic purposes you need to annotate this AND-OR tree
with additional information (which bits come from which patterns,
which patterns are “live” or compatible at a given point in the
pattern space, and what kind of “defaulting” is introduced by
occurrences of variables in the patterns. [This AND-OR representation
evolved from an earlier “matrix” view of a pattern sequence that has
been used in lots of formulations — I wrote one up in May, 1084 for
the first time.  The formulating the pattern space as a tree was also
partly inspired by Milner’s Webs note.]

Having constructed the AND-OR tree to concretely represent the pattern
space, the next step is to order the “accessible” (non-nested) OR
nodes by some heuristic criteria and from this ordering (roughly)
construct a decision tree using all the “relevant” choices represented
by the OR nodes.  Once you “choose” an OR node to be the next choice
on a branch of the decision tree, the AND-OR structure beneath its
children (variants), if any, is opened up and introduces new available
OR nodes for including in the decision tree.  When you have used up
the “relevant” OR nodes, you have the complete decision tree.

The final step is to flatten the decision tree into (pseudo) code
(e.g. abstract syntax or FLINT plambda). You have to deal with types
and type variables if the code is typed.  Another engineering
challenge is to try to avoid duplicating the switch code because of
the branching structure of the decision tree, where an single OR node
in the static AND-OR representation might be replicated under the
branches of another OR node.

There are various optimality criteria that may be used to drive the
building of the decision tree, such as total code size, minimizing the
number of tests (switches), etc.  At the very least, there will be no
redundant tests performed dynamically (any given OR node from the
AND-OR tree will be represented at most once on any branch of the
decision tree).  The underlying fundamental idea is not to forget any
information derived from a test so that the test might need to be
performed again somewhere down the line.

So that is a capsule summary of my current approach.  There are lots
of variations.  For instance, there are “backtracking” pattern
matchers that same on code size at the expense of having to repeat
tests.

So far, as I said, I’ve been reconstructing this from first
principles.  Before writing this up (as a very tardy follow up to
Baudinet and MacQueen, 1985), I’ll need to review the literature (see
SML-history/Implementation/pat-match) to see what wheels I have
re-invented.

================================================================================
