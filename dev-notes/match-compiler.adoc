= Match Compilation [110.97 version]
:Author: Dave MacQueen
:Date: 2020/05/09
:stem: latexmath
:source-highlighter: pygments
:VERSION: 110.98

== Introduction

This document describes the revised implementation of the match compiler
SML/NJ 110.98. This document replaces the Alex Aiken note.

== Files (relative to base/compiler/FLINT/trans
   mcommon.sml  -- match compiler types
   andor.sml  -- building the and-or trees
   matchcomp.sml  -- the main (or reset of the) match compiler

== Terminology anb basic types

The types used in the match compiler are defined 

- type ruleno = int
   index, zero-based, of a rule in a match (pre- or post- ?) OR expansion
   E.g. "allRules" defined in matchComp, which is the list after OR expansion

- type ruleset = ruleno list = int list
   an ordered list of rule indices (no duplicates) representing rule index sets
   [should be abstract]
   
- type dconinfo = datacon * tyvar list
   a dataconstructor (occurring in a pattern) with an "associated"? list of tyvars
   [Q: what is the relation between the datacon and the tyvars?]

- "destructuring paths" (datatype path)
  [paths that record a position in a decision tree? But paths are _trees_ because
   of the RECORDPATH constructor! ]

Two compilcations in the and-or analysis.

- layered patterns. But the pattern that is layered over a base pattern is
  restricted to be a variable (possibly with at type constraint), so the "information
  content is not modified by a layered pattern. It just introduces a variable
  binding at that node.

- vector patterns. These are _both_ OR (dispatching on the length of the vector)
  and AND in the sense that all the element patterns of the vector pattern must
  be matched.  These two roles could possibly be separated, splitting the node
  into an OR over lengths, and for each 

   case x 
     of #[nil, x::y] => ...
      | #[z::w, nil] => ...

  Here the two patterns are vectors of the same length, but the element patterns
  for OR choices. This case should be analyzed similarly to

   case x 
     of {a = nil, b = x::y} => ...
      | {a = z::w, b = nil} => ...

  where on the "a"-field there is an OR choice on {nil, z::w} and on the "b"-field
  there is an OR choice on {x::y, nil}. But we know (from type-checking} that all
  record patterns at the same node will have the same record type and hence the same
  fields.  So there is no OR choice at the level of the record patterns themselves,
  only at the level of corresponding field patterns, where in this case, both the
  "a"-field and "b"-field give rise to OR choices (which will have to be ordered 
  during the construction of the decision tree).

  But two vector patterns at the same node may be of different lengths:

      case x 
	 of #[nil, x::y] => ...
	  | #[z::w, nil, u] => ...

  Here we do the OR dispatch solely on the vector length, and the respective field
  patterns (here {nil, z::w} for the 1st element) do not constitute an OR choice --
  they are "independent" because they lie in separate OR branches.  This is analagous
  to the following situation:

     datatype t = A of int list * int list
                | B of int list * int list

     case x
       of A(nil,x::y) =>
        | B(z::w,nil) =>

  where we don't dispatch on the {nil, z::w} patterns because the A vs B OR node
  has separated them into two branches.

== And-Or trees

Principles:

- Pattern space (for a type)
  Types are either pattern opaque (atomic) or pattern transparent:

  (1) pattern opaque types are types that are atomic or opaque wrt pattern matching,
      i.e. they cannot be analyzed or deconstructed using pattern matching. 
      These types are function types, abstract types, and primitive types other
      than integers, words, characters and strings. There is, not surprisingly,
      a lot of overlap with "equality" types (types that admit generic equality).

  (2) pattern transparent types are formed by products and sums (datatypes) and
      recursion, plus a small set of primitive types that can match atomic (constant)
      patterns, namely int, word, char, and string types.

Given a pattern-transparent type (pattern type, for short), it can be
unfolded into an infinite (or quasi-infinite, in the case of a
primitive type like int) tree constructed from AND nodes (for
products) and OR nodes for sums. [E.g. infinite (regular) tree for 'a
list.]

A sequence of patterns for a pattern type determines a finite "initial
segment" of the tree for the pattern type. The branches of this initial
tree (the union of the finite branches (paths) in the individual patterns,
is called the pattern spece for the pattern set. The branches are finite and
terminate with (a) atomic variable patterns, or (b) constant patterns, where
a constant can be a constant for a primitive type (e.g. 3) or a constant data
constructor (e.g. true, false, nil).

This is the basic AND-OR tree for the pattern sequence, and it is a concrete 
representation of the pattern space generated by the pattern sequence.

Compilications (for SML)

(1) layered patterns of the form "x as p".
These introduce variable binding points at intermediate nodes in the pattern space.

(2) vector patterns.
These are a variant of datatype OR nodes, where the OR-descrimination is on the
length of the vector pattern. The elements of the vector form an AND node.

A position in the pattern space is determined by a node in the AND-OR tree, which
can be described by a finite path down a branch from the root of the tree.  A
path can be defined as a finite list of "links", where links can be defined by
the datatypes

    datatype link
      = R of int      (* index into a record/tuple product pattern *)
      = VE of int     (* index into the elements of a vector pattern *)
      = D of datacon  (* choice among the decendents of a datatype OR node *)
      = VL of int     (* choice among vector patterns of different lengths *)
      = C of const    (* choice among constants, where const is the sum of the
                         transparent primitive types *)
    type path = link list

The root path is the empty list of links ([]: path).

- a node in an And-Or tree corresponds to a _position_ in the pattern space.

-- a node has an associated rule set that specifies the (rule) patterns
   that are consistent with that node

- a given target value can be propagated down through an And-Or tree, following
  each consistent branch and propagating in parallel though the children of an
  AND node. When it reaches a leaf node, the resulting rule set indicates which
  rule patterns are consistent with that value.  The possible matches are formed
  by taking the intersection of the leaf node rule sets.


== Terms: AND-OR trees, choices, rule sets, relevance

An AND-OR tree is a representation of the pattern space generated by a
sequence of patterns. Each node represents a merging of the
subpatterns at a given point in the pattern space from each pattern in
the sequence. The original patterns all have a common type, and each
node of the AND-OR tree has a type derived from that common types.

It is possible to _match_ a value with an AND_OR tree by "pushing" the value 
(and its subcomponents)) down the branches of the AND_OR tree in parallel. Along
some branches the value will be eliminated because it is not consistent with a
choice (i.e. a nil value will be incompatible with a cons-labeled branch.

A _choice_ (or _choice point_) is a point in the pattern space (a node in the AND-OR tree)
that discrimiates based on one of the following:

(1) datatype constructors (e.g. true vs false or nil vs cons)
(2) vector length
(3) constant value (int, word, char, or string)
    
Thus we distinguish three flavors of choice point. We don't distinguish between
different types of constants, (merging them under type constCon).

At each point in the pattern space (AND-OR node), there is a set of rules that are
compatible with that node (i.e. consistent with choices made on the path from
the root to that node). These rules are said to be "live", or "active" for that point.
Only the live rules actually have a subpattern at this point (as determined by a _path_).

A choice is _relevant_ to a rule (ruleno), if that rule is:

(a) live for that choice point (hasn't been eliminated by an earlier choice along the
     path to this choice point), and 
(b) is not live in some immediate child of that choice point.


This is a binary relation between choices and rules.

Being relevant to more rules is considered a positive property of a choice.
It does more discrimination.

Building a decision tree is a process of choosing an ordering choice points.

Choice points are inherently ordered by their position along branches in the AND-OR
tree. Thus a choice below a given choice must come after the higher choice (higher
and lower being determined by position along a branch. If two choices are not on the
same branch (i.e. the path to one does not go through the other), then they are 
inherently not ordered, or are _independent.

== Variables at nodes

A variable can occur at a node in one of two ways:

(1) an atomic variable node (VAR)
(2) an "as"-bound variable attached to one (or more) of a nodes patterns

Atomic, or terminal variable nodes create defaults.  All rules that are live at
that node remain live through the entire subtree determined by that node (i.e. they
cannot be excluded by a choice.

For instance, consider the pattern sequence

(1)  cons(p1,p2)
(2)  nil
(3)  x

This forms an OR node at the root:

    []: OR(list) {1,2,3} var: (x,3)
         [cons]
	    AND {1,3}  [rule 2, nil, is eliminated, but not rule 3]
	      tree(p1)
	      tree(p2)
         [nil] {2,3} *

All the rules live at the top OR-data node remain live for the two immediate
children nodes.  Note that the variable x does not consitute a child node of
the OR-data node.  But it does influence propagation of liveness -- rule 3 remains
live throughout the subtree (e.g. at [D cons] and [D nil] and in tree(p1) and tree(p2)).

Compare this with

(1)  cons(p1,p2)
(2)  nil

with AND-OR tree:

    []: OR-data {1,2}
         [D cons]
	    AND {1}
	      tree(p1)
	      tree(p2)
         [D nil] {2} *

A layered variable binding does not extend the lifetime of rules:

(1) x as cons(p1,p2)
(2) nil

    []: OR(list) {1,2}
        as-var: (x, rule 1)
         [cons]
	    AND {1}
	      tree(p1)
	      tree(p2)
         [nil] {2} *

So a primitive var pattern creates a "default" rule that remains live below
(this) node, while a layered variable does not.


== From AND-OR to Decision trees

(1) determine "accessible" list of CHOICE nodes
These are the CHOICE nodes that are accessible from a root (through selection
from AND nodes) without passing through another CHOICE node.  They are located
on paths which contain no OR links.


== Constructing a Decision Tree

(1) Collect the list of "accessible" OR nodes in the AND-OR tree, with accurate
live rule sets, including default rules that result from VAR/VARS nodes.
The rule of a var binding remains live in the AND-OR node containing that variable,
and thoughout the subtree below that node (i.e. its rule cannot be killed by any
choice within that subtree, including the CHOICE that is the root of that subtree.
Note that VAR nodes may be merged with an AND node _above_ the CHOICE node that 
is being evaluated.

(1)  (x,nil)
(2)  (cons(p1,p2), nil)

Here the x at (RL 1) in the first rule creates a default for the choice node 
created by cons(p1,p2), so rule 1 will be live in the choice node generated from
the cons pattern.

As-bound variables (layer variables) do not have this defaulting effect, and therefore
don't affect the selection and ordering of choice nodes during the construction of the
decistion tree (?).  AS-bindings will have to be dealt with later during the translation
of the decision tree into match code.

Once a choice node is chosen as best from the initial list (the highest set of indepenent
choice nodes), we discard that choice from the list and enqueue the accessible choice
nodes from the subtree below the chosen node (if any).  So the set of remaining choice
nodes may grow (or shrink by one if there are no choice nodes below the chosen one in
the AND-OR tree.

Rule sets associated with an AND-OR node:

(1) live rules: relation Live(rule,node)
Defn. A rule is live at a node if there is no OR choice above that node that is not
compatible with that rule. This means that there exists a value that could match that
rule. If the value was pushed down the branches of the andor tree, it would not have
been eliminated by the time it reaches this node.

(2) relevant rules (static?, or relevant to choice order in a decision tree?)
Defn: Relevance (static): a node is (absolutely) relevant to a rule if that
rule is live for the node (Live(rule,node)) and the rule is not live for some
immediate child of the node (i.e. one of the choices rules it out). Can a rule
ruled out for _all_ children?  Two cases

  (a) the rule introduces one of the children of the OR nodes (in which case it
      will be live for that child.
  (b) the rule does not introduce a new child
      (b1) it contains a variant that was already introduced by an earlier rule, in
           which case it is live for that variant
      (b2) it does not introduce a variant at all, in which case it must have
           a variable at this nodes position. In this case it becomes a default
           rule for this node, and for all its descendents, and is therefore 
	   considered "live" (= live union defaults)

(3) default rules: relation Default(rule,node)
Defn: a rule is a default rule at a node if there is a variable binding for that rule
at some node on the path to the node (including the node as the end of the path).
If Default(rule,node), then that rule cannot be ruled out at that node (i.e. the
node is not relevant to that rule.

Example:

  (1) cons(x,     nil)
  (2) cons(true,  cons(y,    nil))
[ (3) cons(false, cons(true, z))  ]
  (4) _

variable x in rule 1 makes rule 1 a default for the [R1,D(cons)] node. Rule 1 is
live for that node and any descendents of that node.

  [] OR(list) cons {1,2,3; 4} (vars = (_,4)) (partial)
     [cons] AND {1,2,3}
                [0] OR(bool) {1,2,3; 1,4}  vars=(x,1)
		      [true] LEAF {2; 1,4}
		      [false] LEAF {3; 1,4}
		[1] OR(list) {1,2,3; 4}
                      [nil] LEAF {1; 4}
		      [cons] AND {2,3; 4}
 		                 [0] OR(bool) {2,3; 2,4} (vars = (y,2)) (partial)
				       [true] # {3; 2,4}
				 [1] OR(list) {2,3; 4} (vars = (z,3) (partial)
				       [nil] {2; 34}

A _partial_ OR node is a datatype or node with not all datacons represented
in the children of the node.  

(All constant (except char) and vector OR nodes are partial by default.)

live(node) = {rule: Live(rule,node)}

live [] = allrules



================================================================================
Theory
================================================================================

Defn. A patternable type is a type with some concrete product and sum (datatype)
structure at the top (where ty vector is an "honorary datatype descriminating on
the vector lenght).  Some primitive types (int, word, char, string) are also
deemed patternable.  Abstract types and function types are not patternable.

Defn. Abstractly, a tree is a prefix-closed set of paths (Milner, Webs, 1985). Each
path determines a "node" in the tree, and nodes can have attributes attached to them.
"Paths" are lists (finite or infinite) of "links", which may have structure and
attributes of their own.

Defn. Path concatention. If p and p' are paths, p@p' is the concatenation of the
paths, consisting of the links of p followed by the links of p' (the concatenation
of the paths as lists of links).

Defn. A path p' is a _prefix_ of a path p if E(p''). p = p'@p''. (depends on an
equality relation on links)

Defn. If T is a tree, T' \subset T is the _subtree_ at path p if T' consists of all paths
in T having p as an prefix.  Subtree(p,T) = {p' | p@p' \in T).  It is a tree (prefix closed).

Defn. An _initial_ tree of a tree T is a prefix-closed subset of T. A finite initial tree
is an initial tree that is finite.

For any patternable (ML) type t, there is a pattern tree P(t) that expresses the potential
pattern spaces of the type.  This tree has nodes of three kinds:

 (1) product (AND) nodes that may have a finite number of successors (or children)
     indexed by natural numbers (non-negative integers). The subtype at a product
     node is a product (record, tuple) type.

 (2) sum (OR) nodes, that have a finite number of successors indexed by "keys" that
     are either data constructors (datacons) for a datatype, or constants
     (for a patternable primitive type). The subtype at a sum node is a sum type
     (i.e. a datatype).
 (3) terminal (LEAF) nodes for constants (datatype or primitive)

Note: Vector types are treated as a kind of sum type (over some finite
range of vector lengths).  Natural numbers serve as keys for vector
types, indicating to the vector length.

Let t be a patternable type. A pattern pat: t is represented as an initial
tree of P(t).

Defn: Pat(p) \subset P(t) where pat: t.
(inductive definition on pattern structure or concrete structure of type t)

A variable in a pattern generates a (potentially infinite) subtree of the P(t).

Defn. The pattern space of a pattern list is the union of Pat(pi) for pi \in pat list.

This pattern space is represented concretely by an AND-OR tree.


================================================================================
Variable patterns, live rulesets, default rulesets, propagation of defaults

Notational conventions for links, paths, keys:
  [n] represents [Rn], where n is the index of a product/tuple/record component (0 based)
  [K] represents [D(K,_)] where K is a dataconstructor name
  (not currently using other constant keys (num, char, string) in examples)

Conjectures:
1. live field of AND nodes do not play a role.  But live sets during decision tree
   building need to be propagated down through AND nodes.
2. Same for live field of VARS nodes?

[datatype t = A | B | C]
  (0) A
  (1) x
  (2) C

N0:
[] OR(t) {0,1,2}  Vars (x,2)
   [A] {0; 1x}
   [C] {2; 1x}

Rule 2 is default for the [A] and [C] variants.

Some rules may become "inaccessible" because of defaulting from variables.
In this example, rule (3) will never be "fired" in a match because it is
"shadowed" by rule (2).

Thus rule (3) will never be chosen on a branch of the decision tree (because,
while it may be live at a leaf, it will not be the _least_ live node at a leaf.
Here we have

  [] DEC(t)
     A {1,2x}  -- 1 chosen
     C {2x,3}  -- 2 chosen
     [B] {2x}  -- default branch

C leads to live set {2,3} which will select the least rule, i.e. (2).
B goes down an "else" branch with default ruleset {2}
A leads to live set {1,2} which selects rule (1)
Rule 3 is redundant, will never be matched.

r in Defaults(Node)
  ==>
  (1) Var(Pat(r)[Path(Node)]), or
  (2) Exists p < Path(Node). Var(Pat(r)[p])

which is the same as:

   Exists p <= Path(Node). Var(Pat(r)[p])

This means that Pat(r)[p] _cannot cause a mismatch_.

If for p0 < Path(Node), Var(Pat(r)[p]). r contributes no
pattern structure below p0. There may be pattern structure below
p, but it is contributed by other rules (earlier or later than r).

In above example: Var(Pat(2)[[]])


Defn: Relevant(N,r): An OR node N is relevant to a rule r if
  the choice made at that rule can affect whether that rule matches
  i.e. some variant is compatible with that rule and another variant
  is incompatible with that rule.
  i.e. Pat(r)[Path(N)] is not a variable, therefore is either
       a constant or a constructor (constant or applied)
       therefore Pat(r)[Path(N)] is a key for the choice made
       at N (N.variants).

Defn: Pat(r) (r a ruleno) is the pattern part of rule r (r.pat)

Defn: Pat(r)[p] = pattern element at longest possible prefix of
      path p in Pat(r).

Prop: Var(Pat(r)[N]) <=> r in Defaults(N)

Defn: Given an andor tree N for a given rule set
    Compat(r,p) if Pat(r) is "compatible" with all choices made
    on path p.

Notation: N an andor tree, p a path, Np is the andor tree found at
  the end of path p.
    N[] = N
    N[CL(c)] = LEAF ...
    N[DL(d)] = N' where N = OR{variants=ORdata [(d,N'),...],...}
    N[VL(l)] = N' where N = OR{variants=ORvec [(d,N'),...],...}
    N[RL(i)] = Ni where N = AND [..., Ni,...]
    otherwise, N

Defn: Compat(pattern, andor) : 
      Compat(pat, N[])  -- no choices made (yet) at root path
      Compat(c, N[CL(c)])   -- constant pattern; N is OR[ORconst] = LEAF
      Compat((p0,p1), AND(a0,a1)) if Compat(p0,a0) and Compat(p1,a1)
        -- and so on for n-ary products  (a0 = N[RL(0)], a1 = N[RL(1)]
      Compat(d, N[DL(d)])   -- constant datacon
      Compat(d(p), N[DL(d)]) if Compat(p,N)
      Compat(v, N))  true
   In which case r is live for node N(p)

pat@path = the subpattern (if any) of pat at the point designated
           by path (if "compatible")

Prop: Compat(r,p) <==> r in Live(Node(p)) ?

Prop: If Var(Pat(r)[path]), then r in Defaults(N(path)),
      where N = andor(rules).

Note: Pat(r)[path] is always defined, though the actual path for this
subpattern may be a strict prefix of path.


================================================================================
Example 1:

datatype tree = L | N of tree * tree

           

      [0]         [N]
              [N0]  [N1]
  (0) N      (x,    L)
  (1) N      (L,    y)
  (2) z

AND-OR tree:
([n] is short for [Rn] (record selection n))

[] OR(tree) {0,1,2z}
   [N] AND {0,1,2z}
       [0] OR(tree) {0x,1,2z}
           [N] # {0x,2z}
	   [L] LF {0x,1,2z}
       [1] OR(tree) {0,1y,2z}
           [N] # {1y,2z}
	   [L] LF {0,1y,2z}
   [L] LF {2z}

Priorities:
  []   : (1,2)
  [N0] : (2,2)
  [N1] : (2,2)
  
  [] < [N0] = [N1]
  [N0] || [N1]  ([N0] and [N1] are compatible; diverge at AND node [N])
  [N0], [N1] dominated by [] ([] is a prefix of ...)

Decision Tree:

D[] {0,1,2(z)}
   N : {0,1,2z}
       Relevance:
         [N0] false (0 \in {0x,3z})
         [N1] true  (0 not \in {1y,2z})
     D[N1] {0x,1,2z}
        N*: {1y,2z}   ==> (1)
	    Relevance:
	      [N0] false (? not in {0x,2z}) [no _hard_ live rule]
	L : {0,1y,2z} ==> (0)
	    Relevance:
	      [N0] (0 in {0x,2z}) false
   L*: {2z} ==> (2)	       
       Relevance:  [N0], [N1] not compatible with [L] (diverge at OR[0])

Abbreviated Decision Tree:

  []
  N =>
    [N1]
    N* => (1)
    L => (0)
  L* => (2)

Note: OR node [N0] not used, because not relevant after [N1].

Code:

   Case vtop                 (vtop = v[0]: tree)
     of N v1 =>              (v1 = v[N]: tree * tree)
          letr (v2,v3) = v1  (v2 = v[N0]: tree, v3 = v[N1]: tree)
            in Case v3
	         of N => RHS 1
	          | L => RHS 0
        L => RHS 2

Code with external variable bindings:

   Case vtop                 (vtop = v[0]: tree)
     of N v1 =>              (v1 = v[N]: tree * tree)
          letr (v2,v3) = v1  (v2 = v[N0]: tree, v3 = v[N1]: tree)
            in Case v3
	         of N =>
		    Let1 y = v3 in RHS 1
	          | L => Let1 x = v2 in RHS 0
        L => Let1 z = vtop in RHS 2

================================================================================
Example 2:

       [0]     [1]     [2]
 
  (0)  true,   false,  true
  (1)  true,   x,      false
  (2)  false,  true,   y

AND-OR tree:

[] AND
   [0] OR(bool) {0,1,2}
         [true]  LF {0,1}
         [false] LF {2}
   [1] OR(bool) {0,2; 3y}  var: (x,2)   [2 goes to defaults, not live]
         [true]  LF {2; 1x}
         [false] LF {0; 1x}
   [2] OR(bool) {0,1; 2y}  var: (y,3)
         [true]  LF {0; 2y}
         [false] LF {1; 2y}
   
Priorities:
   [0] : (0, 2)   (#defaults, width)
   [1] : (1, 2)   (#defaults, width)  (x, 2)
   [2] : (1, 2)   (#defaults, width)  (y, 3)

   [0] < [1] = [2]

Relevance: {1,2,3}, least: 1
   [0]: true  (1 /in {})
   [1]: true  (1 /in {2x})
   [2]: true  (1 /in {3y})

Decision tree:

D[0] {1,2,3}
   true  : {1,2}, least: 1
      Relevance: [1]: true  (1 not in defaults = {2})
                 [2]: true  (1 not in defaults = {3})
      D[1]  {1,3; 2x}
         true  : {2x,3} inter {1,2} = {2}, least: 2
	   Relevance: [2] : true  (2 not in defaults = {3}); [1],[2] compatible
	   D[2] {1,2,3y} > {1,3!}
	      true  : {1,3!} inter {2} = empty ==> MATCH!
	      false : {2,3!}, least: 2   
	        no more choices  ==> (2)
	 false : {1,2x} inter {1,2} = {1,2}, least: 1
	   Relevance: [2] : true  (1 not in defaults = {3}); [1],[2] compatible
	   D[2] {1,2,3y}
	      true  : {1,3!} inter {1,2!} = {1}, least : 1  ==> (1)
	        [[no more choices  ==> (1)]]
	      false  : {2,3!} inter {1,2} = {2}, least : 1  ==> (2)
	        [[no more choices  ==> (2)]]
   false : {3}
      Relevance: [1] : true  (3 not in defaults={2})
                 [2] : true  (3 not in defaults={2})
      D[1] {1,3; 2}
         true: {2!,3} inter {3} = {3}, least: 3  ==> (3)
	   [[ Relevance: [3]: false  (2 in defaults = {2})   [==> (3)] ]]
	 false: {1,2!} inter {3} = {},    ==> MATCH!
	   [[ Relevance: [3]: true  (1 not in defaults = {3})
	   D[2]: {1,2; 3}
	      true: {1,3!}, least: 1
	        no more choice nodes  ==> (1)
	      false: {2,3!}, least 2
	        no more choice nodes  ==> (2)  ]]

Abbreviated decision tree:

  [0]
  true =>
    [1]
    true  => 
      [2]
      true  => MATCH!   (counterexample: (true,true,true))
      false => (2)
    false =>
      [2]
      true  => (1)
      false => (2)
  false =>
    [1]
    true  => (3)
    false => MATCH!   (counterexample: (false,false,*))

Tests: (true,true,true) ==>  MATCH!
       (false,true,false) ==> (3)
       (false,false,false) ==> MATCH!

Code:
  Letr (v1,v2,v3) = vtop (argument)
    in Case v1
         of true =>
	     Case v2
	       of true  => 
		   Case0 v3
                      of true  => Raise Match
		       | false => RHS 2
		| false =>
                   Case0 v3
		      of true  => RHS 1
		       | false => RHS 2
          | false =>
	     Case v2
               of true  => RHS 3
	        | false => Raise Mmatch
		 

================================================================================
Example 3:
(where a rule is chosen because no relevant OR nodes)

Type:    t * bool *  bool
        [0]  [1]     [2]
-----------------------------
  (0)  (A,   false,  true)
  (1)  (B,   x,      false)
  (2)  (z,   true,   y)

AND-OR tree

[] AND
   [0] OR(t) {0,1,2z}  -- [partial]
         [A] LF {0,2z}
         [B] LF {1,2z}
   [1] OR(bool) {0,1x,2}  var: 1x
         [true]  LF {1x,2}
         [false] LF {1,1x}
   [2] OR(bool) {0,1,2y}  var: 2y
         [true]  LF {0,2y}
         [false] LF {1,2y}
  
Priorities:
  [0] : (1,2)
  [1] : (1,2)
  [2] : (1,2)
(all three nodes have 1 variable, 2 keys ==> equal priorities)

top accessible = [[0],[1],[2]]

D[0] {0,1,2}  (= allrules)
   A  : {0,2z}, least: 0
      Relevance:
        [1]: true  (0 not in defaults = {1x}) -- chosen
        [2]: true  (0 not in defaults = {2y})
      D[1] {0,2}
         true  : {1x,2} inter {0,2} = {2}, least: 2  ==> (2)
	       Relevance:
	         [2]:  (2 in {2y}) false
	 false : {0,1x} inter {0,2z} = {0}, least: 0
	   Relevance: [2] : true  (0 not in defaults = {2y})
	   D[2] {0}
	      true  : {0,2y} inter {0} = {0}, least : 0  ==> (0)
	        [no more OR nodes  ==> (0)]
	      false : {1,2y} inter {0} = {}  ==> MATCH (A,false,false)
	        [no more choices -- irrelevant]
   B : survivors = {1,2z}, least: 1
      Relevance:
        [1] : false  (1 is in defaults[1]={1x})
        [2] : true  (1 not in defaults[2]={2y})
      D[2] {1,2z}
         true: {0,2y} inter {1,2z} = {2yz}
	   Relevance:
	     [1]: (2 not in {1x}?) true
	   D[1] {0,2y}
	      true  : survivors = {1,2z} inter {0,2y} = {2zy}
	         OR-nodes exhausted ==> (2)
	      false : survivors = {0,1x} inter {2} = {}  ==> MATCH
	 false: {1,2y} inter {1,2z} = {1,2yz}, least {1},  ==> (1)
	   Relevance: [1]: false  (1 in defaults = {1x})
	   no relevant OR node => choose least({1,2yz}) = (1)
   * : {2z} [not finished: e.g. (C,false,*) doesn't match]
      Relevance: [1] : (2 not in {1x}) true
                 [2] : (2 in 2y} false
      D[1] {2}
         true: {1x,2} inter {2} = {2}
           D[2] not relevant ==> (2)
	 false: {0,1x} inter {2} = {}  ==> MATCH (C,false, any)
	 
Abbreviated decision tree: (exhaustive)

  [0]
  A =>
    [1]
    true  => (2)
    false =>
      [2]
      true  => (0)
      false => MATCH  (A,false,false)
  B =>
    [2]
     true  => (2)
       [1]
       true => (2)
       false => MATCH  (B,false,true)
     false => (1)
  * =>  [C]
    [1]
     true => (2)
     false => MATCH  (C,false, *) 


=========================================================================================
Example 4:
(where rule is chosen because no relevant OR nodes)

  (0)  A,  false, true
  (1)  B,  x,     false
  (2)  z,  true,  false

AND-OR tree

[] AND
   [0] OR(t) {0,1,2z}     var: 2z
           [A] LF {0,2z}
           [B] LF {1,2z}  (only _direct_ keys appear in andor tree)
   [1] OR(bool) {0,1x,2}  var: 1x   [1 goes to defaults, not live]
           [true] LF {1x,2}
           [false] LF {0,1x}
   [2] OR(bool)] {0,1,2}
           [true] LF {0}
           [false] LF {1,2}

*** andor ***
[] AND {0,1,2} {}
   [0] OR {0,1} {2}  (vars: (z,3))
      A LEAF {0} {2}  {0,2z}
      B LEAF {1} {2}  {1,2z}
   [1] OR {0,2} {1}
      T LEAF {2} {1}  {1x,2}
      F LEAF {0} {1}  {0,1x}
   [2] OR {0,1,2} {}
      T LEAF {0} {}   {0}
      F LEAF {1,2} {} {1,2}

Priority:
  [0] : (1,3)  (2 variants + default = 3 branches)
  [1] : (1,2)  (2 variants, 2 constructors *)
  [2] : (0,2)

  [2] > [1] =? [0]

top accessible = [[0],[1],[2]]
all three OR nodes compatible: [0] || [1], [0] || [2], [1] || [2]
  (diverge from []AND )

Decision Tree:

D[2](bool) {1,2,3}  (= allrules)
  true : survivors' = {0}, least: 0
      Relevance:
        [0]: true  (0 not in {2z})
        [1]: true  (0 not in {1x})
        priority [1] > priority [0]
      D[1](bool) {0,1x,2}
        true : survivors' = {1x,2} inter {0} = {}  ==> MATCH 
	false: survivors' = {0,1x} inter {0} = {0}, least: 0
	   Relevance: [0]: (0 not in {1x}?) true
	   D[0] {0,1,2z}
	     A: survivors' = {0,2z} inter {0} = {0}  ==> (0) (no more OR nodes)
	     B: survivors' = {1,2z} inter {0} = {}  ==> MATCH
	     *: {2z} inter {0} = {}  ==> MATCH  <--- failure!!!  Catch this and generate MATCH
  false: survivors = {1,2}, least 1
      Relevance:
        [1]: (1 not in {1x}?) false,
        [0]: (1 not in {2z}?) true
           [1] not relevant, so [0] chosen, even though lower priority
      D[0](t) {0,1,2z}
        A: survivors' = {0,2z} inter {1,2} = {2}, least: 2
	   Relevance: [1] (2 not in {1x}?) true
	   D[1]: {0,1x,2}
	     true: survivors' = {1x,2} inter {2} = {2}
	       queue exhausted  ==> (2)
	     false: survivors' = {0,1x} inter {2} = {} ==> MATCH
        B: survivors = {1,2z} inter {1,2} = {1,2}; least 1
	   Relevance:
	     [1]: (1 not in {1x}? => false)
	     no more relevant tests  ==> (1) least of {1,2}
	*: survivors = {2z} inter {1,2} = {2z}
	   Relevance:
	     [1]: (2 not in {1x}?) true  (2 least live, even though from defaults)
	   D[1]: {0.1x.2}
	     true: survivors = {1x,2} inter {2z} = {2}  ==> (2) (OR node queue exhausted)
	     false: survivors = {0,1x} inter {2z} = {}  ==> MATCH
	     
Abbreviated decision tree:

  [2]
  true =>
    [1]
    true  => MATCH     (*,true,true)
    false =>
      [0]
      A  => (0)
      B  => MATCH      (B,false,true)
      * => MATCH       (C,false,true)
  false =>
     [0]
     A => 
       [1]
       true => (2)
       false => MATCH  (A,false,false)
     B => (1)
     * =>
       [1]
       true => (2)
       false => MATCH  (C,false,false)
  
Code:

  Letr (v1,v2,v3) = vtop
    Case v3
      true =>
        Case v2
	  true => MATCH
	  false =>
	    Case v1
	      A => RHS 2
	      B => MATCH
	      * => MATCH
     false =>
       case v1
         A =>
	   Case v2
	     true => RHS 2
	     false => MATCH
	 B => RHS 1
	 * =>
	   Case v2
	     true => RHS 2
	     false => MATCH
		

================================================================================
Theory (Clarification): live ruleset, defaults ruleset, relevance, survival
================================================================================

(re: Construction of decision tree)

Rule sets are associated with andor nodes, which represent/designate points in the
pattern space (through their path).

Let's say the "live" ruleset is the set of all rules that have a chance of
  successfully matching at a given pattern point.

Live rules can be characterized as either "direct" or "default".

A rule is a "direct" live rule at p if that rule/p determines/contributes/matches
a particular discriminator key (constructor or constant or vector length). Thus

in the example 

       [p] OR(bool)
   (0) true   ...
   (1) x      ...
   (2) false  ...

rules (0) and (2) are directly live at [].  Rule (1) introduces a variable
default (1x), which also matches the direct keys true and false.  So for
this node:

  direct = {0,2}
  default = {1}

The live ruleset is

  live = direct U default = {0,1,2},

sometimes writen as {0,1x,2} to make it clear that 0 and 2 are direct and
2 is a default (introduced by the occurrence of x).

CONJECTURE: The relevance test should use the least rule in the _live_ set,
which includes both direct and default rules. This least rule may therefore
be a default rule.

Thus at a point in the decision tree construction, rule (0) may have been
eliminate by a higher ([]) false choice (in another column), in which case
the surviving live rules may be {1,2}.  A futher decision may be able to
elimate (1) even though 1 \in defaults.

At an OR node, there is a set of _live_ rules.  Each associated key for that
node determines a subset of live, live/key that is consistent with that key.
These are the rules that have that key at this pattern point, or are default
rules (because of having a variable at that pattern point or above on the path).

In the decision tree construction, the effective live set (for a given key)
is the intersection of live/key and the surviver set being passed down from
higher in the decision tree, i.e.

  survivors' = survivors inter (live/key)

This is the ruleset that should be passed to the call of makeDecisionTree
to compute that decVariant (key,dectree).  It eliminates direct rules with
keys other than the current key. E.g. in the above example, for key false,
live = {0,1x,2} and live/false = {1x,2} and if survivors = {0,2}, say, then
the new survivors for the call of makeDecisionTree for this decVariant is

  survivors' = {0,2} inter {1x,2} = {2}

CONJECTURE. direct and defaults rulesets are only active for OR nodes, so
they don't need to be computed or saved for other kinds of nodes: AND, SINGLE,
VARS, LEAF.

For an OR node, each ruleno in direct is associated with some key in
the variants. If we want to isolate the rulenos introduced with some
particular key, how can we do that?  Look at the andor in that key's
variant, use its direct ruleset. This will be a subset of the OR nodes
direct (?). But its andor may be an AND or a LEAF, or a SINGLE. So have
to be able to derive their direct and defaults sets. Thus any andor that
can be the andor of a variant will have to have direct and defaults.


================================================================================
OR node queue management in DecisionTree
================================================================================
File: dec-tree.sml

OR nodes get "used up" while building a branch downward.
They do not get "used up" across separate, incompatible branches.

Hence, a node is passed down and as decision nodes are added, the queue
is eventually exhausted, _or_ the decision tree branches may terminate
while the queue is still not empty (redundant OR nodes).

Under each variant of an OR node, new (dominated) OR nodes may become
accessible, but OR nodes from "sibling" variants will be incompatible
and do not need to be added to the queue. Only OR nodes within that
variant andor need to be added for further consideration.

================================================================================
OR node priorities
================================================================================
The priority function is based on two factors:

  (1) number of default rules (fewer is better)
  (2) branching factor

At a first approximation, branching factor = number of variants
(length(variants)). But if there is a default rule (covered by a
variable) that can apply where there are missing constructors (keys),
then the branching factor can be

   length (variants) + 1  (for the default branch)

Does this occur only where variants are _partial_, meaning some keys
(e.g. datacons) are missing? [See example 4, path [0]].  Or is it
possible that a default with a _complete_ list of variants (covering
all constructors) can result in an increased branching factor?

Example (conjectural)

      p
  (0) T
  (1) F
  (2) x

Could the x in rule (2) result in a third branch at position p?

================================================================================
Code generation
================================================================================
File: mc-code.sml

Provisional datatype for code: mcexp

Variables:
_Internal variables_ used to name value components. These are in 1-1 correspondence
with paths in the pattern space of the match (and hence AND-OR nodes). Could
generate a fresh internal variable as we construct each andor node, and then
would have the variables already available and "connected" with their path.

Otherwise, might maintain a mapping or two:

  variable --> path == node
  path/node --> variable

Multiple _external_ variables (the source variables that appear in the patterns)
may be associated (equivalent, denote the same value component) with a given
internal variable.  (i_variable <--> node => vars, asvars).  Will need parallel
bindings of internal and external variables (or bindings on external variables
_to_ internal variables).

Each internal variable will have a definite type == the type of the node/path,
== the type of corresponding value components.  Some of these types will be
represented by type variables (not metavariables/univariables!).
Make the abstraction over these "real" type variables explicit.

  AND(v0, [N1(v1), N2(v2), ..., Nn(vn)\])  ==>
   
    letr (v1,v2,...,vn) = v0  (* destructuring a product value *)
      (unpackaging(next choice))
       
  OR(v0, [(k1,N1(v1)), (k2,N2(v2)), ..., (kn,(Nn(vn)))])  ==>

    case v0          (v0 is the "scrutinee" *)
      k1 v1 => exp1  (= (unpackaging(next choice)))
      k2 v2 => exp2
      ...
      kn vn => expn

  For some keys, there will not be arguments, hence no variable binding needed.
  vi designates the ki-destructuring of the value bound to v0, etc.

  Example:

      (1) nil => rhs1
      (2) cons(x,y) => rhs2

      OR v0
        [(nil, LEAF({1})),
	 (cons, AND(v1, [VARS(v2,[(x,2)],{2}), VARS(v3,[(y,2)],{2})]))]

      case v0
        nil => rhs1
	cons v1 =>
	  letr (v2,v3) = v1
	    rhs2'     -- need to identify x with v2 and y with v3
	              -- or substitute (v2,v3) for (x,y) in rhs2

Observations
* Each OR node scrutinizes a particular point in the value structure
  (determined by its path in the pattern space), assuming the value
  is compatible with that path (agrees with OR choices along the path).

* Each value (component) scrutinized should be named by a (internal) variable.
  - A variable could be assigned to every AND-OR node, even though not all such
  variables might be needed -- but most of them will be used.  We don't need
  internal variables for LEAF nodes, since their partent OR node will have a
  variable naming the value already.
  - Some "internal" variables will pair with "external" variables (from vars
  or asvars fields).  How do we manage this association?
  

Example 3: [datatype t = Leaf | Node of t * t

      Node   1               2      Node  1                  2
  (1) Node  (Leaf,           Node        (Leaf,              x))
  (2) Node  (Node(y, Leaf),  Node        (Node(Leaf, Leaf),  Leaf))
  (3) Node  (z,              Leaf)
  (4) Leaf

Andor:

1 [] OR(t) {1,2,3,4}
    [Node] AND {1,2,3}
2      [1] OR(t) {1,2,3z}     (var: (z,3))
            [Node] AND {2,3z}
4	      [1] OR(t) {2y,3z}  (var: (y,2))
5	      [2] OR(t) {2,3z}
	          [Node] - {3z}
	          [Leaf] # {2,3z}
	    [Leaf] # {1,3z}
3      [2] OR(t) {1,2,3}
            [Node] AND {1,2}
6	      [1] OR(t) {1,2}
	           [Node] AND {2}
8	             [1] OR(t) {2}
		          [Node] - {}
	                  [Leaf] # {2}
9		     [2] OR(t) {2}
		          [Node] - {}
	                  [Leaf] # {2}
                   [Leaf] # {1}
7	      [2] OR(t) {1x,2}  (var: (x,1))
	           [Node] - {1x}
	           [Leaf] # {1x,2}
	    [Leaf] # {3}
    [Leaf] # {4}

Priorities:
1 []                     = (0,2)
2 [Node,1]               = (1,2)   (z)
3 [Node,2]               = (0,2)
4 [Node,1,Node,1]        = (2,2)   (y,z)
5 [Node,1,Node,2]        = (1,2)
6 [Node,2,Node,1]        = (0,2)
7 [Node,2,Node,2]        = (1,2)   (x)
8 [Node,2,Node,1,Node,1] = (0,2)
9 [Node,2,Node,1,Node,2] = (0,2)

Decision tree:

  D[[]] {1,2,3,4}
    Node: {1,2,3}, least 1
       Relevance: [Node,1] true, (1 not in {3z})
       Relevance: [Node,2] true, (1 not in {})
       [Node,2] {1,2,3}  ("lower" priority)
         Node: {1,2} inter {1,2,3} = {1,2}
	 Leaf: {3} inter {1,2,3} = {3}
    Leaf: {4}, least 4  (do we need more choices in this case?)
       Relevance: [Node,1] true, (4 not in {3z}); Compatible: false
       Relevance: [Node,2] true, (4 not in {});   Compatible: false

* Only use "path compatible" tests.
  E.g. [Node,1] is not "compatible" with the decision branch [Leaf].
  so it should not be tested under Leaf.

* When choosing the next OR node in building a decTree, the set of
  OR nodes selected from should be "independent of"(?) and "consistent
  with" the current branch/node in the decTree that is being extended.

* Two nodes are consistent if their paths have no divergences.  A divergence
  is a point on the two paths where distinct and inconsistent keys are followed
  to the next node.  E.g. [... D(true) ...] and [... D(false) ...] where the
  true and false keys occur at the same point (the ith link) in the path.

* Being consistent means that both nodes can be "fired" during the matching
  of some potential value.

* In Example 3 above, the [Leaf] path is inconsistent with all the remaining
  OR nodes, since they all have paths beginning with [Node ...]. The first
  links (keys) in the paths are inconsistent. Therefore the [LEAF] node of
  the decTree is terminal -- there will be no further tests on this branch.
  
* Defn: Two paths p1 and p2 are incompatible ("diverge hard") if the first
  link (key) at which they differ is an OR (choice) key, e.g. D(true) vs
  D(false) or I(1) vs I(2).  Two OR nodes N1 and N2 are _incompatible_ if
  their paths Path(N1) and Path(N2) are incompatible.

  Prop: If OR nodes N1 and N2 are incompatible, then they will not both be
    tested when matching a value.  In particular, they will not be comparable
    in the path prefix ordering.  There is a test that dominates both N1 and
    N2 that discriminates between them, namely the test that is the source of
    the two divergent keys on their path.

  When selecting the next OR node while building the decision tree, the
  selected node should be both _relevant_ and _compatible_ with the "current"
  node.

Decision Tree 1 (8 ORs)

   []
   Node =>
      [N2]
      Node =>
         [N2N1]
         Node =>
            [N2N1N1]
            Node => MATCH!
            Leaf =>
               [N2N1N2]
               Node => MATCH!
               Leaf =>
 	          [N1]
                  Node =>
                     [N2N2]
	             Node => MATCH!
	             Leaf => (2)
                  Leaf => MATCH!
         Leaf => 
            [N1]
            Node => MATCH!
            Leaf => (1)
      Leaf => (3)
   Leaf => (4)
  
Decision Tree 2 (hand crafted) (8 ORs)

   [] 
   Node => {1,2,3}
      [N2]
      Node => {1,2}
         [N2N1]
         Node => {2}
            [N2N1N1]
	    Node => {} MATCH!
	    Leaf => {2}
	       [N2N1N2]
	       Node => {} MATCH!
	       Leaf => {2}
	          [N1]
		  Node => {2}
		     [N1N2]
		     Node => {} MATCH!
		     Leaf => {2} (2)
		  Leaf => MATCH!
         Leaf =>
            [N1]
	    Node => {} MATCH!
	    Leaf => {1} (1)
      Leaf => (3)
   Leaf => (4)

Code:
(No context around top decision node.)

  Case vtop  (* [] *)
    of Node v1 =>
         letr (v2,v3) = v1   (* v2 = Var[N1], v3 = Var[N2] *)
	   in Case v3  -- [N2]
	        of Node v4 =>
		     Letr (v5,v6) = v4
		       in Case v5  - [N2N1]
		            of Node v7 =>
			     | Leaf =>
			         Case v2
		 | Leaf => RHS 3
     | Leaf => RHS 4



================================================================================
Adding types
================================================================================

Observations:

1. The type of all the rules is known (post type checking).

2. The type of any andor node (path, point in the pattern space) can easily
be computed.




================================================================================
email to Bob, 2020.5.31 - high level overview of rebuilt match compiler
================================================================================

I am trying to reconstruct the match compilation algorithm from first
principles (after having spend way too much time trying to reverse
engineer the existing (Bill Aitken) code).  The reverse engineering,
while slow and painful, was one way to come to grips with the
essential ideas.  I have been writing lots of notes as I gradually
understand what is going on.  One simple way of thinking of the
problem is that any “pattern-matchable” type (a type with outer layers
of concrete product/sum structure, plus a few primitive types with
constants allowed in patterns, i.e. int, work, char, string) has an
associated “pattern space” that can be represented as a (potentially
infinite) tree which is obtained by unrolling the concrete structure
(abstract types and function types are “atomic” for this purpose).  A
particular pattern is a finite “initial segment” (prefix-closed set of
paths) in this pattern space, and a set of patterns can be
characterized by the union of the initial segments for the patterns.
This union gives one an AND-OR tree (AND for product nodes, OR for sum
nodes corresponding to datatypes or “open” patternable types like int,
string, exceptions (with unbounded numbers of alternatives).  For
engineering/algorithmic purposes you need to annotate this AND-OR tree
with additional information (which bits come from which patterns,
which patterns are “live” or compatible at a given point in the
pattern space, and what kind of “defaulting” is introduced by
occurrences of variables in the patterns. [This AND-OR representation
evolved from an earlier “matrix” view of a pattern sequence that has
been used in lots of formulations — I wrote one up in May, 1084 for
the first time.  The formulating the pattern space as a tree was also
partly inspired by Milner’s Webs note.]

Having constructed the AND-OR tree to concretely represent the pattern
space, the next step is to order the “accessible” (non-nested) OR
nodes by some heuristic criteria and from this ordering (roughly)
construct a decision tree using all the “relevant” choices represented
by the OR nodes.  Once you “choose” an OR node to be the next choice
on a branch of the decision tree, the AND-OR structure beneath its
children (variants), if any, is opened up and introduces new available
OR nodes for including in the decision tree.  When you have used up
the “relevant” OR nodes, you have the complete decision tree.

The final step is to flatten the decision tree into (pseudo) code
(e.g. abstract syntax or FLINT plambda). You have to deal with types
and type variables if the code is typed.  Another engineering
challenge is to try to avoid duplicating the switch code because of
the branching structure of the decision tree, where an single OR node
in the static AND-OR representation might be replicated under the
branches of another OR node.

There are various optimality criteria that may be used to drive the
building of the decision tree, such as total code size, minimizing the
number of tests (switches), etc.  At the very least, there will be no
redundant tests performed dynamically (any given OR node from the
AND-OR tree will be represented at most once on any branch of the
decision tree).  The underlying fundamental idea is not to forget any
information derived from a test so that the test might need to be
performed again somewhere down the line.

So that is a capsule summary of my current approach.  There are lots
of variations.  For instance, there are “backtracking” pattern
matchers that same on code size at the expense of having to repeat
tests.

So far, as I said, I’ve been reconstructing this from first
principles.  Before writing this up (as a very tardy follow up to
Baudinet and MacQueen, 1985), I’ll need to review the literature (see
SML-history/Implementation/pat-match) to see what wheels I have
re-invented.

================================================================================
