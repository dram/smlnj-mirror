(extended-pm.txt)

Extended Pattern Matching
-------------------------

Reference pseudo-code implementations

Metavariable C ranges over constants and data constructors.

We consider three operations for composing patterns. These
constitute "extended" pattern matching.

1. p | q.
  This should be thought of as p xor q. p and q should be
  _disjoint, so p | q and q | p should have the same effect.
  I.e. the "|" operator is commutative (and associative).

2. p ; q
  This should be thought of as analagous to a "computational"
  or operator like "orelse".  Match p and if that fails match q.

3. !p
  This is a pattern negation operator. Match !p iff match p fails.
  This should not bind variables, so p should be variable free
  (but it may contain wildcard patterns).

1a. Simple pattern matching (ignoring variable bindings; no environment)

   match (p, v). Assume p and v are of the same type.

   match : (pattern, value) -> bool

   match (_, v) = true
   match (x, v) = true
   match (C, C) = true    (constant)
   match (C, C') = false  (C <> C')
   match (C p, C v) = match (p, v) 
   match (C p, C' v) = false  (C <> C')
   match ((p1,..,pn), (v1,..,vn)) = (All k: 1<=k<=n) match(pk, vk)

1b. Extended simple matching

   match ((p1 | p2), v) = match (p1, v) xor match (p2, v)   (xor => disjointness)

   match ((p1 ; p2), v) = match (p1, v) orelse match (p2, v)

   match (!p, v) = not (match (p, v))


2a. Simple pattern matching producing environments 

   type venv = (variable * value) list

   matchv (p, v). Assume any variable has at most one occurrence in p.

   matchv : pattern * value -> venv option

   matchv (x, v) = SOME [(x,v)]
   matchv (C, C) = SOME []    (constant)
   matchv (C, C') = NONE  (where C <> C')
   matchv (C p, C v) = matchv (p, v) 
   matchv (C p, C' v) = NONE  (where C <> C')
   matchv ((p1,..,pn), (v1,..,vn)) =
     foldl2 f (SOME []) [(p1,v1), ..., (pn,vn)]
     where
       f ((p,v), NONE) = NONE
       f ((p,v), SOME env) =
         case matchv (p,v)
	   of NONE => NONE
	    | SOME env' => SOME (env @ env')  (* dom(env). dom(env') disjoint *)
   
   Note: in (p1,..,pn), vars(pi) disjoint vars(pj) when i <> j.

2b. Extended simple matching producing environments

   matchv ((p1 | p2), v) =
     case (matchv (p1,v), matchv (p2,v))
       of (NONE, NONE) => NONE
        | (SOME env, NONE) => SOME env
	| (NONE, SOME env) => SOME env
	| (SOME env, SOME env') => NONE  (p1, p2 not disjoint)

   Note: p1 and p2 not disjoint is a static property that should be statically checked,
    and if it holds, (p1 | p2) should be considered illegal.


   matchv ((p1 ; p2), v) =
     case (matchv (p1,v))
       of NONE => matchv (p2,v)
        | SOME env => SOME env

   matchv (!p, v) =
     if match (p,v) then NONE else SOME []
    
     (assuming p contains no variables)

3. Disjointness of patterns

   disjoint : pattern * pattern -> bool

   disjoint (p, q).  Assume p and q have same type.

   disjoint (x, p2) = false
   disjoint (p1, x) = false
   disjoint (C1 p1?, C2 p2?) = true  (C1 <> C2 constants; ? indicates optional arg pattern)
   disjoint (C, C) = false
   disjoint (C p1, C p2) = disjoint (p1,p2)
   disjoint ((p1,..,pn), (q1,..,qn)) = (Exists k: 1<=k<=n) disjoint (pk, qk)



================================================================================
Examples:

1. p1 = [_,_,x,_,_,_,true] : bool list
   p2 = [_,_,_,_,x,_,false] : bool list

p1 and p2 are disjoint, and they bind x at different points in the list.
Is there any (algorithmic) difference between p1 | p2 and p1 ; p2?

2. p1 = [_,_,x,_,_,_,_] : bool list
   p2 = [_,_,_,_,x,_,_] : bool list

p1 and p2 are not disjoint, and they bind x at different points in the list.

Observations: In either of these examples, we don't want to have to examine
elements of the list more than once.

In 1, we won't know where x is bound until we examine the 7th element of the
list, which distinguishes p1 from p2.

3. p1 = [_,_,x,_,_,_,_] : bool list
   p2 = [false,_,_,_,x,_,_] : bool list

not(disjoint(p1, p2)

Assume the pattern is p1 | p2.  Here we can "discard" or "disqualify"
p2 if the value is a list whose 1st element is true, in which case we
do not need to record that x might be bound at to the 5th element
(rather than the 3rd, for p1).  So should we treat this as p2 ; p1?
 
4. p1 = [false,_,x,_,true]
   p2 = [_,x,_,_,false]

disjoint(p1, p2)

For p1 | p2: here if the first element of the value list is true, we
should "abandon" the matching of p1 and procede with matching p2.  The
same is true for p1; p2 -- we should fail over to matching p2 if the
first element is true.

In general, if there is some (a lot of) overlap between p1 and p2, we
want to match that overlap just once, but "commit" to the "still live"
pattern when there is a conflict that is resolved during a match.

5. p1 = (true,_)
   p2 = (_, false)

not disjoint: (true, false) matches both.
No variables.

5a. p1 = (true, x)
    p2 = (x, false)

Not disjoint, variables {x}

* Distinction between p | q and p ; q
Are there examples that make a clear case for treating p | q
differently from p ; q?

* Provisional variable binding
In a case like Example 1, we don't distinguish until we get to the 7th
element of the list.  In the meantime, we have two potential binding
sites for x (the 3rd element for p1 and the 5th element for p2). These
have to be recorded and the right one selected (when generating match
code) based on the later choice point at element 7.

Note that this is essentially the same as for rule ordering

  (1) p1 => e1[x]
  (2) p2 => e2[x]

so the mechanism for managing "provisional" variable bindings should
be related to how they are already handled when merging patterns for
sequential rules.

* The problem of duplicated decision trees: pattern continuations

While we are at it, would it be possible to address the old problem of
duplicating decision subtrees.  (shared decision tree "continuations?)


================================================================================
Changes needed in MatchComp
================================================================================

* In existing MatchComp, rulenos are used for the following purposes:

  1. controlling the mapping from pattern variables to svars (when
     translating the vars, asvars fields of AndOr nodes).
     [in MatchComp, bindSVars, called in genRHS]

  2. computing priorities of OR nodes when constructing decision trees?
     [Defn of priority fn in or-queues.sml uses only number of
     defaults and number of variants, not the rule relevance property.
     But ORQueues.selectBestRelevant checks whether an OR-node is relevant to
     the "leastLive" rule. selectBestRelevant is called by
     DecisionTree.decisionTree..makeDecisionTree.]

  3. determining when a rule RHS has multiple uses and has to be
     abstracted as a function
     [DecisionTree.decisionTree returns a vector of rule use-counts
     which is used in MatchComp..matchComp where it is passed as
     a parameter to MatchComp..genMatch.]
     
  4. defaults for AndOrs, currently a ruleset. Controls defaulting
     behaviour (shadowing) of the vertical stack of rule patterns.
     Note pushDefaults post-pass after AndOr tree construction where
     a primary variable at a path becomes a default for the whole
     andor subtree rooted at that path.

  5. direct field of AndOrs, currently a ruleset. rules for which
     a pattern element at this path is explicitly matched (e.g. a
     constant or constructor) by a value. Such elements can
     discriminate between rules (i.e. fail to match a
     constant/constructor) for some rule, thereby excluding that
     rule from contention.

* ruleCounts produced by DecisionTree.decisionTree (use 3) need to take into
  account multiple _layers_ as well as multiple _rules_ using the same RHS.
  E.g.

     (true | false) => RHS

  [Note: what exactly is the phenomenon causing duplicate use of a
  RHS? Is it the duplication of a decision subtree by the decisionTree
  function? Check!]

* varenvMC may need to map to (layer, path, svar) rather than (ruleno,
  path, svar) -- could also verify that path is redundant?

* Use layer relevance rather than rule relevance in selectBestRelevant
  function for choosing next OR node.
  

Question: Can we just replace rulesets (defaults, direct fields) in
the defn of andor with layersets?  If so, how should we implement
layersets?  (need a compare operation to use one of the library set
functors).

Some layers are not comparable: e.g. 0.0 and 0.0.1. But such
incomparable layers should never occur in a layerset for a node?

Perhaps the "defaults" field should remain rulesets?
