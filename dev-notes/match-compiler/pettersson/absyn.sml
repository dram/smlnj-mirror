(* pet/absyn.sml *)
(* absyn for Pettersson-style MC *)

structure Absyn =
struct

type var = string  (* variables *)
type oper = string
type dcon = Dcons.dcon (* constructors, Pettersson's "Ctor" *)

(* We represent constants as nullary constructor applications,
 * e.g. true ==> APP ("TRUE", TUP nil), as in Augustssen/Wadler.
 * Thus no CONST construct in patterns and expression for now.
 *)

(* Patterns. (No Layer patterns nor OR patterns to start out. KIS *)
datatype pat  (* source patterns, SrcPat *)
  = PVAR of var         (* variable pattern *)
  | PCON of dcon * pat  (* constructor application *)
  | PTUP of pat list

datatype exp  (* expressions -- copied from pw/mc.sml *)
  = VAR of var
  | INT of int
  | CON of dcon * exp  (* no separate constructor for "constant" constructors *)
  | PRIMapp of oper * exp
  | TUP of exp list   (* includes (): unit = TUP nil *)
  | DETUP of var * var list * exp  (* length var list > 1, generated by match *)
  | LET of var * exp * exp
  | SWITCH of var * srule list  (* shallow constructor case, generated by match *)
  | SFUN of var * exp  (* simple function *)
  | FUNapp of exp * exp (* function application *)
  | MFUN of match
  | CASE of match
  | ERROR
(* probably use SELECT(exp, i) rather than DETUP for tuple destruct, where i
 * is compile-time constant int *)

(* source rules and matches *)
withtype rule = pat * exp
and match = rule list
and srule = dcon * var option * exp  (* shallow case on constructors *)

end (* structure Absyn *)
