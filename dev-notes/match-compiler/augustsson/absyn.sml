(* augustsson/absyn.sml *)

structure Absyn =
struct

(* including 1st class tuple patterns and tuple expressions *)

(* atomic pattern/expression elements *)
(* primitive constants like numbers and booleans are included under dcon
 * for this prototype *)

type dcon = string  (* data constructors *)

(* convention is to order dcon names alphabetically in a dcon family *)
val dconFamilies : dcon list list =
    [["CONS", "NIL"],
     ["FALSE", "TRUE"]]

fun member (s: string, ss: string list)  =
   List.exists (fn r => r = s) ss    

(* dconFamily : dcon -> dcon list
 * return the complete "family" of constructors containing the dcon.
 * e.g. "NIL" ==> ["NIL", "CONS"]. *)
fun dconFamily dcon =
    let fun loop nil = nil
	  | loop (fam::rest) =
	      if member (dcon, fam) then fam else loop rest
    in loop dconFamilies
    end

(* patterns *)

type var = string   (* expression variables *)

(* patterns: note that constants (like int) are not handled *)
datatype pat
  = PVAR of var
  | PCON of dcon * pat
  | PTUP of pat list
     (* INVARIANT: length (pat list) = 0 or > 1; PTUP  nil = unit pattern *)

(* (very simple) expressions *)
type oper = string  (* some primitive operations, e.g. "+" for ints *)

(* expression abstract syntax:
 * SWITCH and DETUP are introduced by the match compiler; they do not appear
 * in source code. DETUP, LET, SWITCH, and FUN bind variables *)
datatype exp
  = VAR of var
  | INT of int
  | CON of dcon * exp  (* no separate constructor for "constant" constructors *)
  | PRIMapp of oper * exp
  | TUP of exp list   (* includes (): unit = TUP nil *)
  | DETUP of var * var list * exp  (* length var list > 1, generated by match *)
  | LET of var * exp * exp
  | SWITCH of var * srule list  (* shallow constructor case, generated by match *)
  | SFUN of var * exp  (* simple function *)
  | FUNapp of exp * exp (* function application *)
  | MFUN of match
  | CASE of match
  | ERROR (* used to represent match failure *)

(* switch/case rule/clause *)
withtype srule = dcon * var option * exp  (* Wadler's "clause" *)
and mrule = pat * exp
and match = mrule list

(* subst: exp * var * var -> exp
 *   subst (e, x, y) == [x/y]e
 * We assume x is a match admin variable, which cannot be bound in exp, and therefore
 * cannot be captured during substitution. *)
fun subst (exp, x, y) =
    (case exp
       of VAR z => if z = y then VAR x else exp
        | INT n => exp
	| TUP exps =>
	    TUP (map (fn exp => subst(exp, x, y)) exps)
	| FUNapp (rator, rand) =>
	    FUNapp (subst(rator, x, y), subst(rand, x, y))
	| PRIMapp (oper, exp) => PRIMapp (oper, subst (exp, x, y))
	| CON (dcon, exp) => CON (dcon, subst (exp, x, y))
	| LET (v, defn, body) => 					 
	  if y = v then LET (v, subst(defn, x, y), body)
	  else if x = v then raise Fail "subst[LET]"  (* cannot happen! *)
	  else LET (v, subst(defn, x, y), subst(body, x, y))
	| _ => exp (* punting on messy cases!? *))


fun printPat (PVAR v) = print v
  | printPat (PTUP ps) = 
    (print "("; List.app (fn p => (printPat p; print ", ")) ps; print ")")
  | printPat (PCON (dcon, pat)) = print dcon
					
end (* structure Absyn *)
