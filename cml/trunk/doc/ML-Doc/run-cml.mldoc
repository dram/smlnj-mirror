<!-- ../doc/mldoc/run-cml.mldoc -->

<!DOCTYPE ML-DOC SYSTEM>

<COPYRIGHT OWNER="John H. Reppy" YEAR=2003>
<VERSION VERID="1.0" YEAR=2003 MONTH=5 DAY=12>

<TITLE>The RunCML structure</TITLE>

<INTERFACE>
<HEAD>The <CD>RunCML</CD> structure</HEAD>
<SEEALSO>
  <STRREF>CML</STRREF>
  <STRREF DOCUMENT=SML-BASIS-DOC TOPID>Time</STRREF>
</SEEALSO>


<PP>
The <STRREF NOLINK>RunCML</STRREF> structure provides
support for running &CML; programs.

<STRUCTURE STRID="CML">
  <SIGBODY SIGID="CML" FILE=CML-SIG>
    <SPEC>
      <VAL>doit<TY>((unit -> unit) * Time.time option) -> OS.Process.status
    <SPEC>
      <VAL>isRunning<TY>unit -> bool
    <SPEC>
      <VAL>shutdown<TY>OS.Process.status -> 'a
    <SPEC>
      <VAL>exportFn<TY>(string * (string * string list -> OS.Process.status) * Time.time option) -> unit
<!--
    datatype when = AtInit | AtInitFn | AtShutdown | AtExit
	(* The CML clean-up times are somewhat different than the SML/NJ
	 * times.
	 *
	 *	AtInit		initialization of a program that is being run
	 *			under RunCML.doit.
	 *	AtInitFn	initialization of a stand-alone program that was
	 *			generated by exportFn.
	 *	AtShutdown	normal program exit of a CML program running
	 *			under RunCML.doit.
	 *	AtExit		normal program exit of a stand-alone CML program.
	 *
	 * Note that the clean-up routines run while CML is still active.  It
	 * may also be useful for an application to register clean-up routines
	 * with SML/NJ (AtExportFn actions are the most useful).
	 *)

    val atAll : when list
	(* at all times *)

    val addCleaner    : (string * when list * (when -> unit))
	  -> (when list * (when -> unit)) option
	(* add the named cleaner.  This returns the previous definition, or NONE. *)

    val removeCleaner : string -> (when list * (when -> unit)) option
	(* remove and return the named cleaner; return NONE if it is not found *)

    exception Unlog

    val logMailbox	: (string * 'a Mailbox.mbox) -> unit
    val unlogMailbox	: string -> unit

    val logChannel	: (string * 'a CML.chan) -> unit
    val unlogChannel	: string -> unit

    val logServer	: (string * (unit -> unit) * (unit -> unit)) -> unit
    val unlogServer	: string -> unit

    val unlogAll	: unit -> unit
-->
  </SIGBODY>
</STRUCTURE>
</INTERFACE>
