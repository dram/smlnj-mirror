\documentclass[9pt,nocopyrightspace, fleqn]{sigplanconf}
\usepackage{cite} % sort citations 
\usepackage{listings,amsmath,stmaryrd,pifont,aux/bussproofs,esvect}
\usepackage{aux/code,aux/math-envs,aux/math-cmds,aux/code,aux/proof}
\usepackage{pgf,pgfarrows,pgfnodes,tikz}

\input{aux/mac}
\input{../dissertation/config}
\input{syntax}

\bibliographystyle{plain}

% Introduction (3)
%
% (Outline)
% Module Language (1)
% Entity Calculus (4)
% Elaboration Semantics (5)
% Translation (5)
%
% Related Work (1)
% (Comparison with Shao, CMU, and Leroy)
%
% 1 column bibliography 
%
% 2 pg rule appendix

\begin{document}
	\permission{\copyright ACM, 2010. http://doi.acm.org/10.1145/nnnnnn.nnnnnn}
	\conferenceinfo{POPL '2010,} {26--28 January 2011, Austin, Texas, USA}
	\CopyrightYear{2011}
	\copyrightdata{978-1-59593-676-9/07/0010}
	
\title{A Higher-Order Module System with Generative Types}
\authorinfo{George Kuan\and David MacQueen}{University of Chicago}
  {\{gkuan,macqueen\}@cs.uchicago.edu}
\maketitle

\begin{abstract}
  Several dialects of ML have extended the module system to support
  higher-order modules, improving support for modular programming and
  elevating the module system to a full functional language. But there
  are significant differences in the semantics of higher-order modules
  embodied in these designs. With the exception of Standard ML of New
  Jersey and MLton, higher-order modules in these dialects do not obey
  natural $\beta$-reduction semantics for higher-order functor
  application (\emph{true higher-order semantics}). Most of the
  existing formal accounts of module system semantics also fall short
  of true higher-order semantics because they separate higher-order
  functors from type generativity, thus failing to account for
  interactions between higher-order modules and generative datatype
  declarations and type abstraction. Their limitations arise from an
  attempt to reconcile higher-order modules with ``true'' separate
  compilation.
          
  This paper presents a new formal account of a module system with
  true higher-order semantics, superseding the ``re-elaboration''
  semantics described in MacQueen and Tofte (ESOP 94). It is based on
  compiling the static content of a functor into a static entity
  calculus with generative effects that cleanly isolates and expresses
  the higher-order semantics. The semantics is validated by relating
  it to a translation semantics for compiling the module system to a
  variant of System F$_\omega$. It is more complete and realistic than
  other formal accounts because it corresponds closely to the
  implementation of true higher-order modules used in SML/NJ since the
  mid 1990s (Kuan and MacQueen, IFL 09).
\end{abstract}

\category{D.3.1}{Programming Languages}{Formal Definitions and Theory}
\category{D.3.3}{Programming Languages}{Language Constructs and Features}[Abstract data types, Modules] 
\category{F.3.3}{Logics and Meanings of Programs}{Studies of Program Constructs}[Type structure]

\terms 
Languages, Theory

\keywords
modularity, type theory, elaboration semantics, abstract data types, functors, generativity

\section{Introduction}

The semantics of ML module systems \cite{macqueen:popl86} has been
well studied over the past couple of decades. Many accounts have
considered recursion, first-class modules, separate compilation, and
higher-order modules. 

\section{Outline}


\section{Language Syntax}


The syntactic type system (Figure \ref{fig:typesystem}) consists of
monotypes, type constructors (\emph{tycons}), and type expressions
(\emph{aka} \emph{types}). The monokind $\Omega$ and arrow kind $\Omega^n
\Rightarrow \Omega$ classify monotypes and tycons respectively. As can
be seen from the form of the arrow kind, the syntactic type system
does not support higher-kinded tycons but it does support multi-arity
tycons where the $n$ is a natural number indicating the arity of the
tycon. Furthermore, the core language does not support impredicative
polymorphism. Universal quantifiers for polymorphism are added in a
semantic type system introduced later in this section. In the surface
type language, the only type expressions that can occur on the right
hand side of type definitions are type variables, arrow types, and
type applications. Type functions are only introduced by the type
definition construct in the core language.

\input{figs/fig-typesystem}

The type language is a significantly simplified version of Dreyer's
language\cite{dreyerthesis}.  Basic monotype expressions of kind
$\Omega$ are constructed from type variables by application of paths
denoting n-ary type constructors (tycons).  Derived tycons are
expressed by closed lambda abstractions over monotypes, and types,
which classify core language expressions, are formed from closed
monotypes by the $\typ$ coercion or from open monotypes by closing 
them using polymorphic quantification.  Primitive types are nullary constructors.

There are standard well-kinding judgments of the form
$\Gamma,\Delta\vdash C^s : \Omega$, $\Gamma \vdash C^\lambda : K$ and
$\Gamma \vdash T : \Omega$, where a static environment $\Gamma$ maps
symbolic paths to kinds, and $\Delta$s represents the set of all bound
type variables that are presumed to be in scope. Type variables are of
kind $\Omega$. The rules for the well-kinding judgements are routine
and are omitted.

% The tycon application kinding rule (\ref{eq:syntypeapp}) checks that
% the operator tycon path is well-kinded, the correct number of
% arguments is supplied and that each of the arguments is well-kinded
% with kind $\Omega$. The notation $C^s_i$ denotes the $i$th element in
% the $\vv{C^s}$ vector. The rest of the rules ensure that the types and
% tycons are closed with respect to type variables (\ie, all type
% variables are in $\Delta$).


\subsection{Core Language}

The surface language (Fig.~\ref{fig:modlang}) follows SML/NJ's
syntax with a few exceptions. The structure of expressions ($e$) is
taken for granted, and there are three forms of core level
declarations ($d^c$): value, type definition, and datatype. For type
definitions, the type parameters are written in an explicit
$\lambda$-abstraction form $\mathsf{type}~t = \lambda\vec{\alpha}.C^s$
instead of $\mathsf{type}~\vec{\alpha}~t=C^s$. Definitional type specs
use a similar notation. For simplicity, the data constructor part of
datatype declarations is omitted, since we only need to model the fact
that a datatype declaration generates a fresh atomic tycon.

\input{figs/fig-modlang.tex}

% The core language is a simple one comprised of an implicitly typed
% expression language ($e$) and a simple declaration language
% ($d^c$). There are three forms of declarations in the core language,
% value declarations, type definitions, and datatype declaration. For
% simplicity's sake, datatype declarations only declare the name and
% parameters (arity) of a generative tycon.


\subsection{Module Language}

\subsubsection{Signatures} 
A signature is a skeleton of static information for a structure. To
reflect the hierarchical nesting of structures, we can view a signature
as a tree where the internal nodes are substructure
specifications (specifying a signature for a named structure
component) and the leaves are static specifications for tycons,
functors, and values. Signature declarations can only occur at top level.

% Signatures are defined as a sequence of comma separated specs. Value% 
% specs use the notation $\mathsf{val}~x:\forall\vec{\alpha}.C^s$
% instead of $\mathsf{val}~\vec{\alpha}~x=C^s$. Each sequence is
% terminated by the empty spec $\emptyset_{specs}$. Signature
% expressions include a variable form, base signature
% $\mathsf{sig}~spec~\mathsf{end}$, and a signature expression modified
% by a where type clause. Signature declarations are always at top
% level.

The base signature form ($\mathsf{sig}~spec~\mathsf{end}$) may contain
two kinds of tycon specifications: open and definitional.
\emph{Open tycon specs} (abbreviated as \emph{open specs}) only declare the
name and arity of a tycon that must be present in a matching
structure. \emph{Definitional tycon specs} (abbreviated as
\emph{definitional specs}) constrain tycons by defining them, possibly
relative to open tycons specified elsewhere in the signature.

\begin{lstlisting}
type ('a, 'b) s = 'a list * 'b (* definitional *)
type ('a,'b) t                      (* open *)
\end{lstlisting}

% Definitional specs are intended to match type definitions in
% structures. Open specs can match type definitions, datatype
% declarations, and abstract types (\ie, a type component made abstract
% by opaque ascription) in structures. A signature may be modified by a
% \emph{where type} clause that adds a definition for one of its
% internal open tycon specs.
% 
% Signature expressions may be the base form that contains specs. The
% where type form of signature expressions is a generalization of SML's
% mechanisms. The where type form adds the type definitions on the right
% hand side to the structure spec (signature expression) identified on
% the left hand side.
A signature may be modified by a \emph{where type} clause that applies
a definition to one of its internal open tycon specs, thus converting
that open tycon spec into a definitional one.\footnote{SML also supports
symmetric type sharing constraints, which are made almost (but not quite)
redundant by \emph{where type} clauses, and hence are not considered here.}

Base signature expressions may be found in signature specs, structure
ascriptions, and functor parameter specs.  Such inline base signatures
may contain references to locally bound tycons and structures, which
have to be accounted for during elaboration.

% The mechanism subsumes the structure definition spec form found in
% SML. Structure definition specs, which have the form
% \lstinline{sig structure M : sig ... end = A end} where A is a
% previously defined structure, can be encoded as
% \lstinline{sig structure M : sig ... end end where M = A}. These
% special forms of signature expressions will be discussed further in
% a later section.
 
\subsubsection{Structures}
Structure expressions include paths, base structures encapsulating a
set of declarations, functor applications (where the functor is
designated by a path) and both transparent and opaque ascriptions. The
semantics of transparent and opaque ascription follow that of Standard
ML. Signature ascription always coerces the subject structure to the
form specified in the signature. In the transparent case, open tycon
specs take on the definition of the corresponding tycon in the
structure, while for opaque ascription each open tycon spec is
instantiated to a fresh tycon.

\subsubsection{Functors}
%% say something about functors, and the lack of a special functor
%% signature form, with associated functor signature declarations

%% DBM: following two subsections probably belong in section 4
%% as they are more directly relevant to the design of semantic representations
% \subsubsection{Primary and Secondary Components}\label{sec:primaries}
% The form of a functor argument is constrained by a parameter
% signature. The open and definitional specs in functor formal parameter
% signatures are worth special mention. The tycon names declared by
% these specs may occur in the functor body. When typechecking these
% occurrences, a free instantiation (\ie, dummy instantiation) of the
% tycon is used.  Open specs correspond to these free
% instantiations. These free instantiations are called \emph{formal}
% tycons. These are exactly the flexible tycons mentioned in
% Shao~\cite{shao98}.
% 
% We also use the term \emph{primary tycon} for these formal tycons that
% are introduced to represent open specs in a parameter signature.
% \emph{Secondary} tycons for definitional specs can be derived by
% instantiating their definitions using the primary (formal) tycons.
% In essence, these primary tycons represent the essential information
% from the parameter that will be operated on by the functor in the
% static phase.
% 
% \begin{lstlisting}
% functor F(X:sig type s type t type u = s * t end) = ...
% \end{lstlisting}
% 
% In the above example, \lstinline{s} and \lstinline{t} are primary,
% and \lstinline{u} is secondary. Primary tycons are the ones that must
% be instantiated each time a functor is applied. When a functor is
% applied, the primary tycons are replaced by the corresponding tycons
% in the actual parameter structure, and these are propagated
% ``transparently'' to the functor result.
% 
%  \subsubsection{Nonvolatile and Volatile Type Constructors}\label{sec:volatile}
% It is also useful to classify tycon components of modules as \emph{volatile} or
% \emph{nonvolatile}. A volatile tycon is either a primary tycon from a
% functor formal parameter, or a datatype tycon declared in a functor body, or
% a defined tycon whose definition refers to a volatile tycon. All other
% tycons are non-volatile. A volatile tycon is a potential tycon that
% will be given a definite identity when the functor it is associated
% with is applied, and it may have multiple instantiations if the
% functor is applied multiple times. Nonvolatile tycons have a single,
% noncontingent definition (\emph{i.e.}, their definition lies outside of any
% functor). Volatile tycons associated with a functor formal parameter
% can be further classified as primary (deriving from an open tycon spec)
% or secondary (defined in terms of primary volatile tycons in this, or
% an outer, functor).
% \begin{lstlisting}
% functor F(X: sig
%     type a (* primary, volatile *)
%     type b = int (* secondary, nonvolatile *)
%     structure M0 : sig
%       type c (* primary, volatile *)
%       type d = a (* secondary, volatile *)
%     end
%   end) = struct
%   type u = X.a list (* secondary, volatile *)
%   structure M1 : sig 
%     type v (* spec, not a tycon *)
%   end = struct
%     type v = X.M0.c * int (* secondary, volatile *)
%   end
% end
% \end{lstlisting}
% The above example illustrates some of the possible forms of volatile
% types. Types \texttt{X.a} and \texttt{X.M0.c} are obviously
% volatile. Defined types \texttt{X.M0.d}, \texttt{u}, and \texttt{M1.v}
% are also volatile because they are defined in terms of volatile types.
%% DBM: it's not clear that we really need the classifications of primary/secondary
%% and volatile/nonvolatile. Have to check how they are used later.

\section{Semantic Representations}
The semantic representations of modules are based on the idea of
factoring the static information in a module into a signature, which
can be thought of as a template specifying the ``shape'' of the
module, and a complementary \emph{realization}, which further
specifies the static contents of the module. The connection between
the signature and its realization is mediated by internal names called
\emph{entity variables} (denoted $\rho$), which are introduced as a more robust
substitute for symbolic names, whose bindings can be shadowed in SML,
resulting in hidden or inexplicit tycons (tycons that occur in a static
environment but are not nameable in that environment). The use of
such internal names was suggested in ~\cite{lillibridge94}.
The realization for a structure provides actual tycons to interpret
the undefined open tycon specs in the signature, and it also provides
realizations for substructure and functor components of the structure.

The static components of a signature are assigned unique entity variables
that are generated during elaboration of the signature, and a 
realization for that signature is an environment that assigns each of
these entity variables a static \emph{entity} of the appropriate kind.
For a tycon component, the entity will be a semantic tycon (defined
in Fig.~\ref{fig:semtypesystem}.  For a structure component, the
entity is another structure realization that agrees with the specified
signature of the substructure, and for a functor component, the
realization is a \emph{functor action}, which is a function mapping
parameter realizations to result realizations. A realization is thus
an \emph{entity environment} mapping entity variables to entities.

\input{figs/fig-semtypesystem}
 
In a given signature, the tycons with open specs are called
\emph{primaries}, and they will be defined in associated realizations,
while the defined tycons are called \emph{secondaries}, because their
instantiation in a structure can be derived from the primaries
(sometimes in a vacuous sense, when their definitions don't mention
the primaries).  Similarly, the types in value specifications will be
interpreted relative to the instantiations of primaries in a
realization.  The representation of semantic types and tycons
expresses these dependencies on primary tycons by referring to them by
\emph{entity paths}, denoted $\vec{\rho}$, as shown in
Fig.~\ref{fig:semtypesystem}, where the semantic interpretation of
monotypes, tycons, and types are distinguished by use of the Faktur
script.  A feature of semantic types is the use atomic tycon symbols
$\tau^n$ from a denumerable set Tyc to represent both primitive tycons
and tycons generated by datatype declarations and opaque signature
ascription.  Note that a symbolic path $p$ in a syntactic
monotype will be translated either into semantic tycon or an entity
path, depending on the context.

Semantic types and tycons are required to be closed with respect to
type variables. The semantic types form a well-kinded lambda calculus
over Tyc, and semantic monotypes are therefore strongly
normalizing. Kinds are preserved under $\beta$-reduction. The normal
forms constitute the set $\mathfrak{C}^{nf}$.  The arity of a semantic
tycon can be calculated directly: $|\tau^n| = n$ and
$|\lambda\vec{\alpha}.\mathfrak{C}^s| = |\vec{\alpha}|$.

\subsection{Entities and the Entity Calculus}
 
% We've called a signature a ``skeleton'' of the static aspect of a
% structure.  It determines the ``shape'' of the structure, but to fully capture
% the static information in the structure this shape has to be filled with
% additional content, which takes the form of actual tycons defining the
% formal, open tycon specs in the signature, which could be thought of as
% holes in a template to be filled in. We call a mapping from the open
% tycon specs of a signature to the tycons that instantiate them a
% (structure) \emph{realization}. We could identify the open tycon specs
% by their symbolic paths, and have the realization be a mapping from
% these paths to actual tycons, but instead we structure the realization
% as a tree matching the tree structure of the signature.  For each
% signature level, its realization maps its static component names to
% their realizations: tycons for tycon specs, and structure realizations
% for structure specs (we will deal with functor components below).
% So a structure realization is an environment mapping static component names
% to component realizations.  These tycons and structure realizations
% that complement a signature will collectively be called static entities, and
% later we will add functor entities.
% 
% For defined signatures, using the actual component names in the domains
% of these realization environments would work.  But because Standard ML
% allows shadowing of bindings, leading to the possibility of ``hidden''
% tycons (tycons which appear in a static environment but have no path
% naming them in that environment), using the symbolic names of
% components will not allow us to cope with inferred signatures
% of structures exhibiting tycon name shadowing.

%% DBM.  Could use an example here if space allows.

% The solution to this problem was suggested by Harper and Lillibridge 
% \cite{lillibridge94}. We need to introduce a parallel set of ``internal''
% names for static components that will be unique and not subject to
% shadowing.  Since these unique internal names will be bound to
% entities, we call them \emph{entity variables}.  So the realization
% environments will be finite mappings from entity variables to entities
% rather from symbolic component names to entities.

The entity constructs are defined in Fig.~\ref{fig:entities}.
There are four forms of static entities, corresponding to structure,
functor, atomic tycons, and defined tycons.

\input{figs/fig-entities.tex}
 
Entity environments $\Upsilon$ are sequences of bindings of an entity
variable $\rho$ to a static entity $\upsilon$. Entity environments are
used in two ways: (1) they are used to look up tycons expressed as
entity paths, and (2) they support an inverse translation from a atomic
semantic tycon ($\tau^n$) to an entity path denoting that tycon in 
a particular entity environment. The ordering of bindings is important because
the we will want a deterministic way to search the environment for
atomic tycons in (2).
    
A structure entity $\langle \Uloc,\Uclo \rangle$ is split into a local entity
environment $\Uloc$ and a closure environment $\Uclo$ to close an
associated semantic signature with respect to any entity variables not
defined in $\Uclo$, \ie, nonlocal entity variables.
\begin{lstlisting}
signature S = 
sig
  type t
  structure A = sig val x : t end
end

structure M : S =
struct
  type t = int
  structure A = struct val x = 1 end
end
\end{lstlisting}
Consider the above example. The semantic signature for \texttt{A} will
have a free occurrence of the entity variable for t, $\rho_t$, in the
spec type of x. The entity variable $\rho_t$ is not in the domain of
the entity environment for \texttt{A}. In fact, the entity environment
for \texttt{A} is empty because \texttt{A} does not contain any static
entities. Still, the structure entity for \texttt{A} must interpret
the entity path $\rho_t$ representing the type of \texttt{A.x}, so it
uses the entity environment of its enclosing structure \texttt{M} to
close its signature. So the structure entity for \texttt{A} is
$\langle \emptyset_{ee}, [\rho_t \mapsto \mathrm{int}] \rangle$.

A structure entity encodes only the volatile type information in
structure, \ie, the part that is re-instantiated with signature
matching and functor application. 

A functor specification in a signature, such as
\[
\mathsf{functor}~ f(x: \mathit{sigexp}_1) : \mathit{sigexp}_2
\]
implicitly defines a functor signature for $f$, which we might express
directly as $\mathrm{fsig}(x: \mathit{sigexp}_1) : \mathit{sigexp}_2$.
This functor signature is a kind of dependent type that relates the
signature template for the parameter, $\mathit{sigexp}_1$, to the
signature template for the result,$\mathit{sigexp}_2$.  Using the
parameter variable $x$ in definitional tycon specs in
$\mathit{sigexp}_2$ allows us to \emph{partially} specify the mapping
from argument tycons to result tycons.  But as in the case of
structure signatures, the functor signature can, in general, only
capture part of the static mapping performed by the functor, which can
involve rather complex constructions to define the result tycons
(including generative tycon declarations, local structure declarations
and internal functor applications, etc.).  So to fully represent the
static aspect of a functor, the functor signature also has to be
augmented by additional information, which we call a \emph{functor
  entity}.  This functor entity represents the \emph{functor
  action}.  We express this realization function using a
lambda-calculus of entities, called the \emph{entity calculus}.  More
specifically, a functor entity is a closure of a lambda abstraction in
the entity calculus with respect to an entity environment binding its
free variables.

There are two forms of functor entity. The standard form
$\langle\lambda\rho.\varphi;\Upsilon\rangle$ encodes the functor
action as an \emph{entity function} $\lambda\rho.\varphi$
with a closure environment $\Upsilon$. Applying such an entity
function results in a structure entity according the call-by-value
evaluation semantics of the entity calculus. The alternate form
$\langle\lambda\rho.\Sigma;\Upsilon\rangle$ represent formal functors in
functor parameters where the only information known is the
signature $\Sigma$ of the functor result. This form also requires
a closure environment to bind any nonlocal entity paths occurring in
$\Sigma$.

%% DBM: where does this figure belong, together with the associated discussion?

Fig. ~\ref{fig:semanticobjs} defines the representations of semantic
signatures, \emph{full signatures}, which are the complete static
representations of structures and functors, and static environments,
which map symbols to their static representation.  A full signature
for a structure or functor simply pairs the signature and realization
for the module, which together provide a complete static description.
The static bindings for structures and functors include the entity
variable to permit direct construction of entity paths during
signature extraction, structure path, and functor path elaboration.  

\input{figs/fig-semanticobjs.tex}

%% Entity calculus
The entity calculus is specified in Fig.~\ref{fig:entities}.  It is
essentially a lambda calculus with records using entity variables for
field labels and the dot notation for selection. The
environment-based, call-by-value
evaluation semantics is straightforward.  But this is not a pure
language because of the $\mathsf{new}$ operation that creates new
atomic tycons. So the entity calculus is effectful, where the effect
is the generation of new tycons.  The values expressed by the 
entity calculus are the static entities (tycons, structure and functor
entities).  Although the calculus is untyped, it could be made into
a typed calculus using the kinds and signatures associated with the
entities.

Note that base structure entity expressions consist of entity
declarations enclosed by $\llparenthesis\cdot\rrparenthesis$
corresponding to the \lstinline{struct ... end} base structure form.
The let expression is used to express coercions induced by signature
matching (see sec.~\ref{sec:sigmatch}).  There is also a special
evaluation rule associated with the formal functor expression
$\lambda\rho.\Sigma$ that will be discussed in Section
~\ref{sec:formalfunctor}.

The elaborator evaluates entity expressions to static
entities as necessary during elaboration. The judgments for  entity
expression evaluation are listed below:

\vspace{1ex}
\begin{tabular}{ll}
	$\Upsilon\vdash\varphi \Downarrow_{str} R$ & structure entity expression evaluation \\
	$\Upsilon\vdash\eta \Downarrow_{decl} \Upsilon'$ & entity declaration evaluation \\
	$\Upsilon\vdash\theta \Downarrow_{fct} \psi$ & functor entity expression evaluation
\end{tabular}
\vspace{1ex}


% \subsection{Entity declarations}
% The evaluation rules for entity declarations must accumulate the entity environment across declarations in order to support occurrences of entities in value specs within inline open signatures. 
% 
% \begin{lstlisting}
% datatype d = A
% 
% structure M : sig type t val x : d * t end =
% struct
%   datatype t = B
%   val x = (A, B)
% end
% \end{lstlisting}
% 
% Observe that the type name d is a nonlocal name that must be defined
% in a prior entity declaration. The clause entity environment for M
% must contain a binding for d.

%%DBM: make sure these notations are in fact used hereafter.
\subsection{Some Notation}\label{sec:entitycalc-notation}
We extend entity environments by juxtaposing a binding:
$\Upsilon[\rho\mapsto\upsilon]$.
Concatenation of two entity environments $\Upsilon$ and $\Upsilon'$ is represented by
juxtaposition, $\Upsilon\Upsilon'$. The notation for entity
environment lookup is overloaded. $\Upsilon(\rho)$ returns the static
entity corresponding to $\rho$. The notation
$\Upsilon(\rho_0\vec{\rho})$ looks up $\rho_0$ in $\Upsilon$,
returning a structure entity $R=\langle \Uloc,\Uclo \rangle$ and then recursively
computes $\Upsilon'(\vec{\rho})$ where $\Upsilon' =
\Uclo\Uloc$. $EV(\cdot)$ denote the set of all entity variables in
$\cdot$. The notation $dom(\Upsilon)$ denotes the set of entity
variables in the domain of all mappings in $\Upsilon$, including the
nested ones.

$\Upsilon_1 \subseteq \Upsilon_2$ indicates all the bindings in
$\Upsilon_1$ are in $\Upsilon_2$. Suppose $R=\langle \Uloc,
\Uclo \rangle$.  Then $R \subseteq \Upsilon$
means $\Uclo\Uloc\subseteq \Upsilon$,  
$\Upsilon\subseteq R$ means $\Upsilon
\subseteq \Uclo\Uloc$. If $R$ is used in a
context where an entity environment is expected, then $R$ denotes
$\Uclo\Uloc$.

\subsection{Entity Evaluation Semantics}
\input{figs/fig-entsems.tex}

The module system evaluates entity expressions when elaborating
functor application (rule \ref{eq:strapp}), i.e when performing a
functor action.
Fig.~\ref{fig:entsems} lists the rules for evaluating structure entity
expressions. The key rules are the ones for application
(\ref{eq:expapp},\ref{eq:expappformal}), one for regular functor application
and the other for formal functor application. Rule \ref{eq:expapp} is
standard. In Rule~\ref{eq:expappformal} functor entity
expression evaluates to a formal functor closure.
The signature $\Sigma$ (\ie~the formal functor body
signature) is freely instantiated by generating new tycons for its
open tycon specs (see Sec.~\ref{sec:siginst}). The resulting structure entity
is closed by extended entity environment.

Entity declarations must be evaluated in
sequence, producing a cumulative entity environment, in the usual way.
The other evaluation rules are fairly routine; lambda abstractions for
functor expressions evaluate by forming closures.  The rule for the
new operation is of interest -- it introduces new atomic tycons with
the specified arity:
{\small
\begin{equation}
	\infer{\Upsilon\vdash\rho=_{tyc}\newx(n),\eta\Downarrow_{decl}
          [\rho\mapsto\tau^n]\Upsilon'}
	    {\begin{array}{c}
                \Upsilon[\rho\mapsto\tau^n]\vdash\eta\Downarrow_{decl}\Upsilon'\qquad
            (\tau\textrm{ is fresh in }\Upsilon)
          \end{array}} 
\label{eq:entdecnew}
\end{equation}}
When the $\rho=_{tyc}\newx(n)$ entity declaration is embedded in
the body of a functor entity, it produces a fresh atomic tycon for
$\rho$ each time the functor entity is applied,~\ie~when this
entity declaration is evaluated. This models the behavior of
generative datatype declarations under true higher-order
semantics.

%%DBM: this rule, eq:entdectypedef is incorrect in the thesis, since
%%it needs to evaluate the relativized definition tycon against the entenv.
% Rule~\ref{eq:entdectypedef} yields a corresponding type
% definition entity environment binding. Rule~\ref{eq:entdecalias} looks
% up an entity path (constructed during signature matching coercion
% rule~\ref{eq:coerceopen}) for the corresponding entity mapping. 
% 
% Fig.~\ref{fig:fctenteval} gives the rules for evaluating a functor
% entity expression. Rule~\ref{eq:fctentpath} looks up entity paths in
% the usual way. The entity function is formed by combining an entity
% $\lambda$-abstraction with the current entity environment to form a
% closure (rule~\ref{eq:fctentlam}). Rule~\ref{eq:fctentformal}
% similarly forms a closure for formal functors.

\begin{lemma}[Entity evaluation terminates]
The following evaluation relations terminate (have a finite derivation tree):
\begin{enumerate}
\item $\Upsilon\vdash\varphi\Downarrow_{str}R$
\item $\Upsilon\vdash\eta\Downarrow_{decl}\Upsilon'$
\item $\Upsilon\vdash\theta\Downarrow_{fct} \psi$
\end{enumerate}
\end{lemma}

%% DBM: hint about the proof of the above?

%% DBM: the following lemma is not necessarily true when the
%% expressions are entity paths.  It looks true for other cases.
% \begin{lemma}
% \begin{enumerate}
% \item If $\Upsilon \vdash \varphi \Downarrow_{str} R$, then
% $\Upsilon\subseteq R$.
% \item If $\Upsilon\vdash \theta \Downarrow_{fct}
% \langle\theta;\Upsilon'\rangle$, then $\Upsilon\subseteq\Upsilon'$. 
% \end{enumerate}
% \end{lemma}

%% DBM: the next three sections on relativiation are way to long and
%% wordy.  Cut down to one subsection of less than one column.
\subsection{Relativization}\label{sec:relativization}
%% This section is rather vague and obscure -- it needs to be made
%% more specific and concrete with examples.
Tycon names have a scoping policy much like other program
identifiers. Tycon names can be shadowed by later tycon
declarations. A tycon name may refer to a local tycon that is declared
in the same semantic signature or structure entity, or to a nonlocal
one that is declared as a functor parameter or in another
structure. Although signature declarations occur only at the top
level, anonymous signature expressions may be embedded as functor
parameter signatures and signature ascriptions. When signatures occur
inline, its type specifications may refer to both local and nonlocal
tycons.

Some tycon names may refer to volatile tycons which may be
instantiated multiple times possibly to new generative tycons. Each
time a functor is applied or a signature is ascribed to a structure, the
tycon name must be interpreted according to a potentially different
entity environment. When elaboration reaches these tycons we need a
way to map them back to the corresponding entity path such that we
reference the correct ``up-to-date'' volatile tycon. The necessity of
this is illustrated in fig.~\ref{fig:lifecycle}. Semantic tycons which
live in static environments and entity environments have to be
relativized when put into semantic signatures and entity
expressions. When the tycon is needed for typechecking, the tycon must
be instantiated with respect to an entity environment. This is the
primary purpose of relativization, to give an entity path that can be
interpreted according to different entity environments. Secondarily,
relativization replaces fragile symbolic names with robust entity
paths to the entity environment mapping the entity paths.

%% DBM I'm afraid this figure may not be very clear or
%% self-explanatory.  I can see how it is supposed to illustrate the
%% paragraph above, but it's not clear the point will be clear to
%% other less-clued-in readers.
\begin{figure}
\begin{center}
\begin{tikzpicture}[node distance= 3.3cm,auto]
\tikzstyle{block} = [rectangle, draw,  
    text width=5em, text centered, rounded corners, minimum height=4em]
\tikzstyle{arr} = [line width=2pt,->]
	\node[block] (sy) {Syntactic};
	\node[block, right of=sy] (se) {Semantic};
	\node[block, right of=se] (re) {Relativized};

	\node[node distance=2cm,below of=se] (statenv) {static env};
	\node[node distance=1cm,,below of=statenv] {entity env};
	\node[node distance=2cm,below of=re] (semsig) {semantic sig};
	\node[node distance=1cm,below of=semsig]  {entity expr};
		
	\path[arr] (sy) edge node {elaborates} (se);
	\path[arr] ([yshift=-5mm]se.north east) edge node {relativizes} ([yshift=-5mm]re.north west);
	\path[arr] (se) edge [loop above] node {evaluates} (se);
	\path[arr] ([yshift=5mm]re.south west) edge node {instantiates} ([yshift=5mm]se.south east);
	

\end{tikzpicture}
\end{center}
\caption{Life-cycle of a tycon}
\label{fig:lifecycle}
\end{figure}
%% DBM: I modified fig:semtypesystem to include entpaths as possible
%% tycons, which merges semantic tycons and relativized tycons.  The
%% relativized tycons then just become semantic tycons in which at least
%% one entpath occurs.  This simplifies things in the sense that we don't
%% need another set of tycon/type expression metavariables, but does
%% it add complications elsewhere?

\subsection{Relativized Type System}\label{sec:relativized-type-sys}
The relativized type system ($\mathbb{C}^s, \mathbb{C}^\lambda,$ and
$\mathbb{T}$) replaces all occurrences of atomic tycons with entity
paths.
%% DBM: not _all_ tycons -- only volatile ones.  Absolute, nonvolatile
%% tycons can remain in place.  Since relativized types have both
%% regular and entpath tycons, an absolute type is just an extreme
%% case of a relativized type where there are 0 entpath tycons.
%% In other words, the semantic tycons should be viewed as a subset
%% of the relativized tycons.
The purpose of relativization and this type system is described
in section~\ref{sec:volatile}. Three classes of tycons have been
introduced: syntactic, semantic, and relativized. The semantics
progressively translates syntactic tycons to the latter two. The
module system only evaluates semantic tycons. Such tycons exist in the
static and entity environments. In contrast, relativized tycons are
never reduced directly. Instead, they must be instantiated into a
semantic tycon for reduction to take place as in
fig.~\ref{fig:lifecycle}. Relativized tycons exist in semantic
signatures and static environment by way of embedded semantic
signatures.

%% DBM: too routine to mention, and redundant if we view them as a
%% subset of semantic types/tycons
% Relativized monotypes, tycons, and types must also be well-kinded as
% defined in Fig.~\ref{fig:relativized-wellkinding}. The main difference
% between this well-kinding judgment and the other well-kinding
% judgments is that rule~\ref{eq:r-k-app} uses the entity environment to
% obtain a well-kinded {\bf semantic} tycon. The rest of the semantics
% is standard. 

%% DBM: we never have to determine equivalence of uninterpreted 
%% relativized types.  For the purpose of type checking, we will
%% always be working with fully interpreted (absolute) types.
The rules in Figs.~\ref{fig:mt-tyc-equiv} and~\ref{fig:typeequiv}
define monotype and tycon equivalences and type expressions
equivalences respectively.  The module system semantics will require a
notion of relativized monotype equivalence and relativized tycon
equivalence, which are given by rules~\ref{eq:mtequiv}
and~\ref{eq:tcequiv} respectively.  Monotypes and tycons are
equivalent under the interpretation of an entity environment when they
evaluate to equivalent normal form semantic tycons modulo
$\alpha$-renaming. Rules~\ref{eq:teequiv-typ}
and~\ref{eq:teequiv-forall} describe equivalence for type expressions.

\subsection{Role of Relativization}
Relativization plays in a role in signature extraction (discussed in sec.~\ref{sec:sigextract}):
\begin{enumerate}
\item Value bindings in the static environment must be relativized. 
\item Definitional type binding in the static environment must be relativized in the inferred signature. 
\end{enumerate}
        
\begin{lstlisting}
sig
  structure M : sig type t end
  type u = M.t 
end
\end{lstlisting}

\noindent The type definition for u must be relativized because it refers not to a concrete type, but a type defined relative to a matching structure's realization.

Consider the following example:
\begin{lstlisting}
structure A =
struct
  structure B = struct datatype u end
  functor F(X:sig type t end) = 
    struct val a : X.t * B.u = ... end : sig val a : X.t * B.u end
end
\end{lstlisting}

The following are the semantic signatures for the example:
\[B \mapsto (\rho_B, \{u \mapsto (\rho_u, 0)\})\]
\[X \mapsto (\rho_X, \{t \mapsto (\rho_t, 0)\})\]
In the type for a, the tycon for X.t must be relativized to $\rho_X\rho_t$ and for B.u to $\rho_B\rho_u$. 

When inferring the signature from the body of F, we have the formal tycon X.t in the static environment. When inferring the signature from F's body, there are two static environments, the static environment produced by elaborating F's body and the contextual static environment when entering into the body. 

Static environment for F's body: $[a \mapsto \tau_t^0 * \tau_u^0 ]$ \\
Static environment for the context: $[B \mapsto (\rho_B, \{u \mapsto (\rho_u, \tau_u^0)\}, R_B)]$\\
                 $[X \mapsto (\rho_X, {t \mapsto (\rho_t, \tau_t^0)}, R_X)]$

$R_B$ and $R_X$ are the structure entities for $B$ and $X$ respectively. 


\begin{lstlisting}
structure A =
struct [$\rho_A$]
  structure B = struct [$\rho_B$] datatype t [$\rho_t$] = K end
  functor F(X [$\rho_X$]:sig type u [$\rho_u$] val a : u end) =
  struct 
    val b : X.u * B.t = (X.a, B.K)
  end : sig val b : X.u * B.t end
end
\end{lstlisting}

The relativized tycon, an entity path, can be computed from the static environment at the point of elaboration. For example, when the elaborator reaches the body of the above functor, the static environment is the following:

$[B\mapsto (\rho_B, \langle \{t \mapsto (\rho_t, 0)\}, \emptyset_{ee}\rangle)][X\mapsto (\rho_X,\langle\{u\mapsto(\rho_u,0), a\mapsto [\rho_u]\},\emptyset_{ee}\rangle)]$

The tycon for \lstinline{X.u} can be relativized by building an entity path, \emph{i.e.}, $\rho_X\rho_u$, by traversing the static environment. 

When elaborating the specified type of \lstinline{a} in the functor parameter signature, the reference to the formal tycon \lstinline{u} is relativized to an entity path $\rho_u$. 

After instantiation of the parameter signature during functor elaboration (sec.~\ref{sec:modelab}),  the elaborator must derive the canonical entity path for any newly generated tycons, structures, and functors, which will correspond to an entity variable in the parameter signature. The elaborator uses the canonical entity path when elaborating the functor result signature and functor body. 

This after-the-fact entity to entity path mapping is also needed for structure bindings to create the mappings for coerced entities produced during signature matching. Unlike in the functor case, mappings for the entities in the structure binding and the structure entity itself must be in scope for the rest of the program. 

A policy of fully reducing a tycon before relativizing 
simplifies the process of relativization. Each primary
volatile tycon has a unique declaration site and thus a unique entry in the
entity environment from which the elaborator can derive the unique
entity path leading to that tycon. 

$\Upsilon$ is a sequence of bindings of entity variables to
entities. A binding $[\rho\mapsto\upsilon]$ in $\Upsilon$
\emph{precedes} another binding $[\rho'\mapsto\upsilon']$ if it comes
earlier in the sequence. Note that since entity environments are
hierarchical, one binding can precede another even if they are not in
the same level in the hierarchy.  Let ($\sqsubseteq_{ee}, \Upsilon$) be the total ordering of
the entity paths in $\Upsilon$. Let $\vec{\rho}_1 \sqsubseteq_{ee}
\vec{\rho}_2$ only if the entity environment binding denoted by
$\vec{\rho}_1$ precedes the binding for $\vec{\rho}_2$. Let
$\inv(\Upsilon, \tau^n)$ denote the least entity path $\vec{\rho}$ with respect to
$\sqsubseteq_{ee}$ such that $\Upsilon(\vec{\rho}) = \tau^n$. 

The definition of relativization
uses an operation of the entity environment $\inv$ to
calculate the entity path. Although $\Upsilon$ technically does not
admit an inverse because multiple entity paths may map to the same
atomic tycon, this operation is intuitively similar to an inverse of $\Upsilon$ lookup. 

\begin{definition}
$\inv(\Upsilon,\tau^n)$ is defined to be the entity path associated
with the first occurrence (\ie, least binding according to $\sqsubseteq_{ee}$) of $\tau^n$ when treating the entity environment $\Upsilon$ as a sequence of bindings. 
\end{definition}

\begin{example}
Let $\Upsilon=[\rho_0\mapsto [\rho_1\mapsto \tau^0_1]][\rho_2\mapsto \tau^0_1]$. $\inv(\Upsilon,\tau^0_1) = \rho_0\rho_1$. 
\end{example}

\subsection{Semantics}

Fig.~\ref{fig:eprelativize} formally defines the relativization of
syntactic monotypes, tycons, and type expressions. 
The relativization judgments require an
entity environment $\Upsilon$ to interpret atomic tycons associated
with those symbolic paths.

Relativization is used in signature expression elaboration of where type~(\ref{eq:wheretype}), type definition spec elaboration~(rule~\ref{eq:typedefspec}), val spec elaboration~(rule~\ref{eq:valspec}), and signature extraction (rules~\ref{eq:extraval},\ref{eq:extratypedef}). 

\begin{definition}[Well-formedness of entity environments]\label{def:wellformedentenvs}
\begin{enumerate}
\item If $\Gamma,\emptyset_{knds} \vdash \vec{\rho} :: \Omega^n \to \Omega$, then $\Upsilon(\vec{\rho}) = \tau^n$ or $\Upsilon(\vec{\rho}) = \mathfrak{C}^\lambda$ such that $|\mathfrak{C}^\lambda| = n$. 

\item If $\vec{\rho}$ is a functor in $\Gamma$, then $\Upsilon(\vec{\rho}) = \psi$. 

\item If $\vec{\rho}$ is a structure in $\Gamma$, then $\Upsilon(\vec{\rho}) = R$. 
\end{enumerate}
\end{definition}

\section{Elaboration Semantics}

In a first-order module system, functor application can propagate types in the parameter to the functor result. True higher-order semantics is useful for compilation of efficient module code \cite{shao98}. More importantly, type propagation is necessary to make some sound programs typecheck. THO semantics also reflects the dependent type structure of functors. Types in the functor parameter may also be generative, as in the case of datatypes and types in opaquely ascribed substructures. These generative types have to be faithfully propagated during functor application. Functors complicate type propagation because types in the functor result may be computed from multiple sources. As in the first-order case, types may be locally defined in the result or propagated from the parameter. Applications of formal functors (\ie, functors in the functor parameter) in the functor result should also propagates types. Collectively, generation of fresh instances of generative types and formal functor applications are called \emph{functor actions}, which must be performed during elaboration of functor application to maximize type propagation.    
 
As in other accounts of module system designs, I present the THO module system as an elaboration semantics. The syntactic module language is elaborated to a semantic representation. Unlike prior accounts, this semantics will use an entity calculus that captures the functor actions in a program. The entity calculus is a third level of representation distinct from the syntactic and semantic representations. It assumes that each type is given a unique name, an entity variable. Unlike other internal languages, the entity calculus only plays a role in elaboration. Entity calculus terms are translated to IL types by the time code reaches the optimization stages of a compiler. 
      
Elaboration accomplishes the following:
\begin{enumerate}   
	\item Produces a static environment mapping variables to static descriptions of values, types, structures, functors, and signatures
	\item Produces a typed abstract syntax
	\item Produces entity expressions used in representing functor actions
	\item Typechecks the program
\end{enumerate}

For simplicity, the discussion of (2) will be postponed to chapter~\ref{ch:translation}. Fig.~\ref{fig:overview} shows the major components of the elaboration process and how they are related. 

\begin{figure}
\begin{center}
\includegraphics[scale=0.4]{../dissertation/figs/overview}
\end{center}
\caption{Map of elaboration processes}
\label{fig:overview}
\end{figure}
 
% \section{Why Higher-Order Functors?}
% The Fox project at CMU demonstrated that functors are valuable for the design and organization of extensible software systems. Shao~\cite{shao:parameterizedsigsandho}  demonstrates that higher-order functors are necessary for precisely expressing the import signature of a module that refers to externally defined functors. This idea is motivated by the \emph{fully functorized style} originally espoused by Tofte. 


\section{Elaboration Representations}
Elaboration is mainly concerned with the construction of a static environment. Secondarily, the elaborator produces typed abstract syntax, an entity environment, and an entity expression. The static environment contains the visible static information in the elaborated program. The static information comes in the form of semantic representations of signatures and type information. 

\begin{lstlisting}
sig
   type t [$\rho_t$] 
   type u = int 
   structure M [$\rho_M$] : sig type s [$\rho_s$] end
end
\end{lstlisting}
 
The entity environment contains static information that may have been occulted by shadowing and the functor actions describing the production of new static information during functor application. Much of elaboration is concerned with constructing the correct entity environment and using them to interpret entity paths. 

\subsection{Semantic Objects}
A semantic signature is a sequence of signature elements, symbol to spec bindings. Signature elements can be volatile ($s^p$), definitional ($\mathbb{C}^\lambda$), or a value spec ($\mathbb{T}$). Note that all signature spec elements must be relativized. Nonvolatile elements including definitional tycons $\mathbb{C}^\lambda$ and value specs $\mathbb{T}$ need only specify their fixed static description. Volatile primary specs ($s^p$) such open ones $arity$, structures $\Sigma$, and functors $\Sigma^f$ may be instantiated by signature matching and thus must have a corresponding binding in the entity environment indexed by entity variables. A \emph{full signature M} gives a full semantic description of a structure. It is comprised of a semantic signature $\Sigma$ and a structure entity $R$ that interprets all the open specifications in $\Sigma$. 

A semantic functor signature $\Sigma^f$ binds an entity variable for the functor parameter $\rho$ in the functor result signature. A full functor signature $F$ is comprised a semantic functor signature $\Sigma^f$ and a functor entity $\psi$ that when evaluated will interpret all the open specifications in the functor result signature. 

$\gamma$ is a static binding, to which the static environment $\Gamma$ maps identifiers. For value identifiers, the static description is a semantic type expression $\mathfrak{T}$. For tycon definitions, the static description is $\mathfrak{C}^\lambda$. There is no static binding for open tycon because all tycons are either defined or instantiated in the static environment.  For signature and functor signature identifiers, the static descriptions are semantic signatures ($\Sigma$) and semantic functor signature ($\Sigma^f$). For structure and functor identifiers, the static descriptions are full signatures and full functor signatures respectively. Some static binding (namely for structures and functors) consist of the full signature or full functor signature coupled with the entity variable for that structure or functor. The entity variable is used to construct entity paths during signature extraction and elaboration. 

Tycons in signatures and in static environments differ in that tycons
in the former will have been relativized during signature elaboration
or extraction. Unlike static environments that may be extended
throughout the elaboration process, signatures do not change. Hence to
ensure that volatile tycons in signatures have an appropriate
interpretation, they must be relativized with respect to the entity
environment. 

\begin{figure}
\begin{center}
\includegraphics[scale=0.5]{../dissertation/figs/fig-staticenv-sigs}
\end{center}
\caption{Schematic of static environment}
\label{fig:staticenv-sigs}
\end{figure}

In Fig.~\ref{fig:staticenv-sigs}, the static environment depicted
exhibits the heterogeneous form of the definition. The first layer
contains semantic tycons, those types directly bound by the static
environment. The second layer consist of the tycons $s, u,$ and $w$ bound in semantic
signatures $\Sigma_0$ and $\Sigma_1$ embedded inside of the static
environment. These semantic signatures contain relativized tycons. The
full signature for structures also include the structure entity
expressions $R_0$ and $R_1$ which define the instantiation of the open
tycons in the corresponding semantic signature.  


\section{Notation}\label{sec:elabnotation}

If $p$ is a symbolic path and $\Sigma$ is a semantic signature, then $p\in\Sigma$ means that following $p$ in $\Sigma$ reaches a spec. If $p$ is a singleton, then $\Sigma$ must contain a binding $p\mapsto spec$. Otherwise, if $p$ is nonsingleton, then $p=xp'$ such that $x$ is a symbol and $p'$ is a symbolic path such that $\Sigma$ contains a binding $x\mapsto (\rho,\Sigma')$ and $p'\in\Sigma$. 

$\Sigma(p)$ is the spec reached by following $p$ in $\Sigma$. The notation $\EP(\Sigma,p)$ denotes the entity path associated with the signature spec referred to by symbolic path $p$. The entity path is comprised of the entity variables on the path to the element. For example, if the signature is $\Sigma = [A\mapsto(\rho_A,[B\mapsto (\rho_B, [t \mapsto (\rho_t, 0)])])]$, then $\Sigma_{ep}(A.B.t) = \rho_A\rho_B\rho_t$. The same notation is extended to static environments. 

Static environment lookup is expressed as $\Gamma(p)$ where $p$ is the symbolic path to the static binding. If $p$ is a singleton, then the static environment lookup would simply return the corresponding static binding. As will be demonstrated below, static environment lookup sometimes requires an entity environment lookup. This is the case when the component being looked up is a definitional tycon in a nonsingleton path. Depending on what kind of entity $p$ refers to, the lookup is handled differently:
\begin{description}
\item[tycon]~
\begin{description}
\item[singleton path $p=x$] The semantic tycon is $\Gamma(x)$.
\item[nonsingleton $p=q.x$] $\Gamma(q)$ produces a full signature ($\Sigma_q,R_q$). Let $\Upsilon_q = \Uclo\Uloc$ where $R_q = \langle \Uloc, \Uclo\rangle$. 

If $\Sigma_q(x) = (\rho_x,n)$, then $\Gamma(p) = \Upsilon_q(\rho_x)$. 

If $\Sigma_q(x) = \mathbb{C}^\lambda$, then $\Gamma(p) = $ the interpretation of $\mathbb{C}^\lambda$ under $\Upsilon_q$. 

Note that all tycons are interpreted using the structure entity closest to the occurrence. 
\end{description}
\item[full signature or a full functor signature] $\Gamma(p)$ denotes a pair $(\vec{\rho}, M)$ such that $\vec{\rho}$ is the entity path to the structure static binding and $M$ is the full signature of that structure. For example, for $\Gamma=[A\mapsto(\rho_A,([B\mapsto(\rho_B, \Sigma_B)], R_A))]$, $\Gamma(A.B) = (\rho_A\rho_B, (\Sigma_B,R_A(\rho_A\rho_B)))$. 
\end{description}

\section{Elaboration Modes}
During elaboration, entity expressions are both produced and consumed to aid in typechecking. Elaboration occurs in two simultaneous modes: the \emph{direct mode} and the \emph{entity compilation mode}. Direct mode consists of core language type checking, direct construction of entity expressions (such as tycon declaration elaboration and signature instantiation), and evaluation of entity expressions from the static information uncovered during elaboration. The main results of this mode are a static environment mapping symbolic names to static descriptions and an entity environment mapping entity variables to entities. The evaluation of entity expressions may produce new entities which added to static and entity environments. The entity compilation mode compiles functor actions into entity expressions.   

Elaboration is entirely a compile-time process. The entity language is distinct from core and module languages. The language is parallel to the semantic representation and the syntactic language. Elaboration translates core and module languages to typed abstract syntax and entity expressions. The part of elaboration that produces entity expressions and declaration is called \emph{static entity compilation}. Because the entity language is intended to describe functor actions, which are not encoded in the typed abstract syntax, the two are complementary. When the elaborator reaches a functor application in the source, the corresponding application entity expression must be evaluated to produce the static information for the result. Entity expression evaluation yields structure entities. 
   
\section{Entity Compilation Mode}
Besides the direct elaboration mode for the evaluation of entity expressions, described in chapter~\ref{ch:entitycalc}, the elaborator must have an entity compilation mode that produces the entity expressions and semantic representations of the modules from the syntax. The process of the compilation mode is the bulk of the elaboration semantics. Entity expressions for both structures and functors are compiled from the raw implicitly typed abstract syntax trees and the contextual environments used during elaboration. The compilation mode elaboration is the subject of the remainder of this chapter. 

The compilation mode elaboration compiles abstract
syntax trees to entity expressions. All of elaboration takes place
under a static environment $\Gamma$. Recall that semantic
signatures pair all static primary components with entity variables
and replace all occurrences of such primaries with a canonical entity path to the corresponding static entity in the entity environment, which is calculated by relativization. Values are classified by their type. Structures are described by their full signature consisting of a structure entity and a signature. A functor static description is a full functor signature, comprised of a functor entity expression (\ie, a $\lambda$-expression) and a functor signature. The main elaboration judgments are the following:\\
 
\begin{tabular}{ll}
        $\Gamma,\Upsilon,\Sigma\vdash C^s \Rightarrow_{mt} \mathfrak{C}^s$ & monotype elaboration\\
        $\Gamma,\Upsilon,\Sigma\vdash C^\lambda \Rightarrow_{tyc} \mathfrak{C}^\lambda$ & tycon elaboration\\
        $\Gamma,\Upsilon,\Sigma\vdash T \Rightarrow_{te} \mathfrak{T}$ & type elaboration\\
\end{tabular}\\

The above judgments produce semantic monotypes/tycons/type expressions from syntactic ones. Tycon elaboration's sole role is during elaboration of tycon declarations (rule~\ref{eq:typedefdecl}). 

\begin{tabular}{ll}       
        $\Upsilon\vdash \mathfrak{C}^s \searrow^{mt} \mathbb{C}^s$ & monotype relativization\\
        $\Upsilon,\Sigma\vdash \mathfrak{C}^\lambda \searrow^{tyc} \mathbb{C}^\lambda$ & tycon relativization\\
        $\Upsilon,\Sigma\vdash T \searrow^{te} \mathbb{T}$ & type expression relativization
\end{tabular}\\

The relativization judgment produce relativized tycons from syntactic ones. The entity environment $\Upsilon$ is used to relativize the nonlocally defined tycons. The signature $\Sigma$ is used to construct relativized entity paths for locally defined tycons. Signature extraction and elaboration rely on relativization. \\

\begin{tabular}{ll}      
$\Gamma,\Upsilon,\Sigma\vdash sigexp \Rightarrow_{sig} \Sigma'$ & signature elaboration\\
$\Gamma,\Upsilon,\Sigma\vdash fsgexp \Rightarrow_{fsg} \Sigma^f$ & functor sig elaboration\\
        $\Uclo,\Uloc\vdash \Sigma \uparrow \Uloc$ & signature instantiation\\
        $\Gamma,\Upsilon\vdash d^m \Rightarrow_{decl} (\eta,\Gamma',\Upsilon')$ & module decl elaboration\\
        $\Gamma,\Upsilon\vdash strexp \Rightarrow_{str} (M, \varphi)$ & structure expr elaboration\\
        $\Upsilon\vdash\Gamma\hookrightarrow \Sigma$ & signature extraction\\
        $\Upsilon\vdash(M,\varphi):\Sigma\Rightarrow_{m} (M_c,\varphi_c)$ & signature matching\\
        $\Upsilon\vdash F \preceq \Sigma^f \Rightarrow_{fsgm} (\psi_c, \theta_c)$ & functor signature matching
\end{tabular}

\section{Type Constructors}
The syntactic type language is a subset of the semantic tycon language. Before proceeding, the elaborator must first elaborate the syntactic types to semantic tycons. The elaboration is simply a syntax-directed recursive translation. 

The syntactic type language elaborates to the semantic type language. Elaboration interprets the symbolic paths in tycon application $p(\vv{C^s})$ and evaluates the application by standard $\beta$-reduction. Note that tycon elaboration $\Rightarrow_{tyc }$ elaborates and therefore reduces under $\lambda$-abstraction. This ensures that tycon definitions are fully reduced. Because $\lambda$s cannot be nested, this reduction is well-defined and normalizing. The normal form is defined as $\mathfrak{C}^{nf}$ in fig.~\ref{fig:semtypesystem}. 

Note that the tycon may be occuring inside a signature spec, in which case it may refer to entity paths for preceding specs. 

\begin{lstlisting}
sig 
  type t
  type u = t
end
\end{lstlisting}

During the elaboration of the above, t will be given an entity variable. When elaborating the occurrence of tycon t in the definition of u, t is not the static environment. It can only be found in the partial semantic signature produced by elaborating the open spec for t. Signature specs may contain relativized tycons, entity paths,
referencing entities declared earlier in the same semantic signature. These preceding signature specs (forming a semantic signature $\Sigma$ itself)
help construct an entity path for symbolic paths not defined in the
static environment. Rule~\ref{eq:tycapp} uses $\entpath$ to calculate the entity path using static and entity environments. In order
to fully relativize such a symbolic path, the $\entpath$ metafunction
needs to first lookup the symbolic path in the preceding signature
specs $\Sigma$, which contains all the preceding specs in the current signature and only if that fails does it look up in the static environment.  


The type elaboration judgments preserve the well-kinding defined in chapter~\ref{ch:typesystem}.

\begin{lemma}[Monotype Elaboration Preserves Kinding]
If $\Gamma,\emptyset_{knds}\vdash C^s : \Omega$ and $\Gamma,\Upsilon\vdash C^s \Rightarrow_{mt} \mathfrak{C}^s$, then $\emptyset_{knds}\vdash \mathfrak{C}^s : \Omega$. 
\end{lemma}

\begin{lemma}[Tycon Elaboration Preserves Kinding]
If $\Gamma,\emptyset_{knds}\vdash C^\lambda : \Omega^n \Rightarrow
\Omega$ and $\Gamma,\Upsilon\vdash C^\lambda \Rightarrow_{tyc}
\mathfrak{C}^\lambda$, then $\emptyset_{knds}\vdash \mathfrak{C}^\lambda : \Omega^n \Rightarrow \Omega$.
\end{lemma}

\section{Signature Elaboration}
The role of signature elaboration is to relativize tycons, to reduce where type clauses to type definitions, and to decorate all specs corresponding to static entities with  entity variables. The elaboration judgment uses static and entity environment to interpret symbolic paths in tycon definitions. However, not all symbolic paths are bound in the static environment. For example, in the following signature, the type definition for u mentions tycon t which does not have a corresponding structure entity at this point, hence tycon t will not be in static and entity environment. 

\begin{lstlisting}
sig type t type u = t end
\end{lstlisting}

Rule~\ref{eq:specs} composes the result of elaborating the individual specs. Elaborating subsequent specs in the same signature will require a context (a signature) that includes all the previously elaborated specs $\Sigma$ and the newly elaborated spec $\Sigma'$.  

Signature spec elaboration produces entity variables for each static
component (\emph{i.e.}, open type specs, structure spec, and functor
spec) and puts them in the resultant semantic
signature. Rules~\ref{eq:typedefspec} and~\ref{eq:valspec} relativize
semantic tycons and type expressions respectively. 

In particular, the signature $\Sigma$ is needed when relativizing specs in a signature $\Sigma'$ that contain symbolic paths defined within the same $\Sigma$. Latter specs can contain symbolic paths declared in earlier specs within the same signature. Because the signature is not yet fully elaborated and does not correspond to any full signature, it is neither defined in the static environment nor the entity environment, each of which only mapping paths defined outside of the signature currently being elaborated. 


Rule~\ref{eq:fctspec} elaborate the formal parameter signature $sigexp_1$ and then the functor body signature $sigexp_2$ with the signature context extended with a spec corresponding to the formal parameter. 

Let $AT(\cdot)$ denote the set of all atomic tycons ($\tau^n$) in $\cdot$. 
The following lemma guarantees that all tycons are fully relativized by the relativization judgment. 

\begin{lemma}
If $AT(\Sigma) = \emptyset$, for all $\Sigma_i\in\Gamma.AT(\Sigma_i)=\emptyset$, and $\Gamma,\Upsilon,\Sigma\vdash sigexp \Rightarrow_{sig} \Sigma'$, then $AT(\Sigma') = \emptyset$. 
\end{lemma}

\section{Signature Instantiation}\label{sec:siginst}

Signature instantiation produces a free instantiation of a given
semantic signature, where free is in the context of both a closure and
a local entity environment. Instantiation produces an entity
environment that is local, meaning exclusive of closure entity
environment bindings (see rule~\ref{eq:inst-empty}). 

Most of the
judgments ignore the signature element. The elements that matter are
the those corresponding to static entities. Rule~\ref{eq:inst-open}
produces a fresh atomic tycon $\tau^n$ of the appropriate arity
$n$. The tycon must be fresh in both closure and local entity
environments. Subsequent signature elements must be instantiated in
the context of the local entity environment extended with the binding
to the new tycon $[\rho\mapsto\tau^n]$. This new binding serves two
roles. First, it ensures that $\tau^n$ is not reused when
instantiating the rest of the signature elements. Second, the new
binding may be included as part of the closure entity environment when
instantiating a structure and functor specs.  

Rule~\ref{eq:inst-str} instantiates a structure spec by recursively
instantiating its semantic signature. The structure's semantic signature may mention
either entities in $\Uclo$ and $\Uloc$, that is,
preceding entities in the same signature. The resulting entity environment
is combined with a closure $\Uclo\Uloc$ to form a
structure entity. Rule~\ref{eq:inst-fct} instantiates a functor spec
by producing a functor entity contains a formal functor functor entity
expression $\lambda\rho_x.\Sigma_r$ and a closure entity
environment. 

\begin{lemma}[Signature Instantiation Terminates]
$\Upsilon\vdash \Sigma \uparrow \Upsilon'$ terminates.
\end{lemma}

% \section{Top Level Declaration Elaborations}

% Elaboration of top level declaration is
% straightforward. The semantics is given in Fig.~\ref{fig:toplevel}. Rule~\ref{eq:sigdec} elaborates a signature
% expression and extends the static environment with a binding of the
% signature name to the semantic signature. Rule~\ref{eq:topmoddec}
% elaborates module declarations using the $\Gamma,\Upsilon\vdash d^m
% \Rightarrow_{decl} (\eta,\Gamma',\Upsilon')$ judgment. The judgment
% can safely discard the entity declarations from the module
% declarations because top level declarations will not be wrapped in a
% functor and therefore lead to functor actions. 

\section{Signature Extraction}\label{sec:sigextract}

Fig.~\ref{fig:extractsig} gives the rules for signature extraction, the process of synthesizing a semantic signature for a structure given only the static environment produced by elaborating that structure and an entity environment. Because the signature must contain only relativized type expressions and tycons, rules~\ref{eq:extraval} and~\ref{eq:extratypedef} must relativize the semantic type expression and tycon in the static environment. Rule~\ref{eq:extraatomictyc} produces a spec from an atomic tycon binding, which specifies the arity $n$ of the tycon. The rule looks up the atomic tycon in the ``inverse'' of $\Upsilon$. This rule assumes that $\Upsilon$ and $\Gamma$ are synchronized. In particular, since $t$ is a local name in the static environment (\emph{i.e.}, its binding is not nested inside some signature in $\Gamma$), $\tau^n$ should also be local in $\Upsilon$ and therefore have a singleton entity path. 
 
\begin{lemma}[Synchronization of Static and Entity Environments]
If $\Gamma,\Upsilon \vdash d^m \Rightarrow_{decl} (\eta, \Gamma', \Upsilon')$ and $EV(\Gamma)\subseteq dom(\Upsilon)$, then $EV(\Gamma')\subseteq dom(\Upsilon')$. 
\end{lemma}

For full signatures and full functor signatures, signature extraction is simple. Rules~\ref{eq:extrastr} and~\ref{eq:extrafct} forms structure and functor specs by projecting out the entity variable and semantic signature (or semantic functor signature) from the static environment mapping for the structure and functor respectively. 

\section{Signature Matching}\label{sec:sigmatch}
Signature matching plays three principal roles during elaboration. It
coerces functor arguments to the form dictated by the functor
parameter signature in
rule~\ref{eq:strapp}. Rules~\ref{eq:transascription}
and~\ref{eq:opaqueascription} use signature matching to constrain the
full signature of the structure for transparent and opaque ascription
respectively. Figs.~\ref{fig:sigmatch} and~\ref{fig:specmtch} describe 
the signature matching judgment and its subsidiary judgment respectively. The main judgment for signature matching $\Upsilon\vdash(M,\varphi):\Sigma\Rightarrow_{match} (R_c,\varphi_c)$ forms the \emph{coercion structure entity expression} $\varphi_c$ which binds the uncoerced, original entity expression to a fresh entity variable $\rho_u$ for use by the coercion entity declarations $\eta$. In general, $\eta$ may alias components of $\varphi$ as is in the case in rule~\ref{eq:coerceopen}.  The coercion structure entity expression needs both $\varphi$ and $\eta$ because the elaborator needs to evaluate $\varphi$ at least for its functor actions and $\eta$ are the actual exported entity variables. The entity environment for signature matching is a composite of the context $\Upsilon$, actual structure local environment $\Upsilon_a$, and actual structure closure environment $\Uclo$. All three are necessary because $\Upsilon$ closes the spec signature $\Sigma_s$, $\Upsilon_a$ the actual $\Sigma_a$, and $\Uclo$ the local environment $\Upsilon_a$. 

A subsidiary judgment $\Upsilon,\Sigma_a,\rho_u\vdash \Sigma_s \Rightarrow_{coerce} (\Upsilon', \eta)$ matches actual structure components to individual specs. The actual structure signature $\Sigma_a$ is used to match against each spec. The entity variable $\rho_u$ provides access to the uncoerced structure entity expression in case the elaborator needs to alias components. The judgment will produce both a semantic signature and a local entity environment, used by the match judgment to produce a coerced full signature. 

Rule~\ref{eq:coerceempty} matches against an empty spec signature, in
which case the coercion signature, entity environment, and entity
declarations are empty. Rule~\ref{eq:coerceval} matches value specs
only when the value's type expressions are equivalent when interpreted
under the entity environment. For open tycon specs, there are two
cases. Rule~\ref{eq:coerceopen} matches an open tycon spec against an
open tycon spec in actual. In that case, the rule will use the
structure entity for the actual and an alias to the entity path for
the actual $\rho_u\rho_a$ for the entity
declaration. Rule~\ref{eq:coerceopenwithdef} matches an open tycon
spec against a definitional tycon spec in the actual. The arities of
the definitional tycon and the open tycon spec must match
up. Rule~\ref{eq:coercedefdef} matches a definitional tycon spec in
the spec signature to a definitional tycon spec in the actual. Again,
this match requires the equivalence of the spec and actual
definitional tycons interpreted under the entity
environment. Rule~\ref{eq:coercedefwithdt} matches a definition tycon
spec in the spec signature to an open tycon in the actual, which should be consistent with the tycon in entity environment $\Upsilon(\rho)$. Rules~\ref{eq:coercestr} and \ref{eq:coercefct} match structure and functor specs respectively. Being specs for entities, these rules must produce a new entity environment binding and entity declaration. Rule~\ref{eq:coercestr} forms the bindings using the full signature and structure entity expression from performing signature matching on the signature in the structure spec. The full signature the rule will match against is formed by the spec signature $\Sigma_x$ and the corresponding structure entity $\Upsilon(\rho_x)$. Rule~\ref{eq:coercefct} works similarly. 

The relationship between the resultant structure entity, the spec
signature, and actual signature is precise:

\begin{lemma}
If $\Upsilon \vdash ((\Sigma_a,R_a),\varphi) : \Sigma_s \Rightarrow_{match} (R_c,
\varphi_c)$, then for all $[x\mapsto s]\in\Sigma_s$, $[x\mapsto
s']\in\Sigma_a$ such that $R_c(s)=R_a(s')$.
\end{lemma}

An important property is that the structure entity expression
constructed by signature matching should evaluate to the coerced
entity environment up to isomorphism. The role of the structure entity
expression is to evaluate to an entity environment that instantiates
the spec signature to an actual argument structure in the current
entity environment.  

\begin{lemma}
If $\Upsilon \vdash ((\Sigma_a,R_a),\varphi) : \Sigma_s
\Rightarrow_{match} (R_c,\varphi_c)$, then $\Upsilon\vdash \varphi_c
\Downarrow_{str} R'$ such that $R_c$ is isomorphic to $R'$. 
\end{lemma}

\section{Functor Signature Matching}
Fig.~\ref{fig:fsgmtch} defines the functor signature matching judgment
$\Rightarrow_{fsgmtch}$ which is composed of a two rules,
rule~\ref{eq:fsgmtch-real} and~\ref{eq:fsgmtch-formal}. Both rules calculate a coerced functor entity
$\psi_c$ and functor entity expression $\theta_c$. To match the
functor spec, the functor spec's parameter signature $\Sigma_{spar}$
is matched against a full signature formed by the argument 
signature $\Sigma_{apar}$ and the instantiation of $\Sigma_{apar}$
plus a structure entity expression for the
argument. Rule~\ref{eq:fsgmtch-real} uses the structure entity
expression $\varphi$ for the a standard functor entity expression
$\lambda\rho.\varphi$. Rule~\ref{eq:fsgmtch-formal} only has a formal
functor entity expression $\lambda\rho.\Sigma$, 
The functor spec's result signature $\Sigma_{sres}$ is then
instantiated and that instantiation is used to form a full signature
for the functor result in order to match against the actual functor
spec's result signature $\Sigma_{ares}$. The resultant structure
entity expression can be used to form the final coerced $\psi_c$ and
$\theta_c$.  

\section{Module Elaboration}\label{sec:modelab}

The module elaboration judgment calls for a static environment and an
entity environment as its context. The static environment serves to
elaborate tycons and structures, by looking up symbolic paths. The
entity environment plays a role in signature elaboration and
instantiation of functor parameters.

Fig.~\ref{fig:elabmod} gives the rules for elaborating module
declarations. The judgment computes an entity declaration, a static
environment, and an entity environment for the module
declarations. The two environments will only contain bindings
representing the information in the module declarations and not the
closure. Each module declaration elaboration rule calculates a
semantic representation of the declaration value (\emph{i.e.}, type
expressions, (definitional) tycons, atomic tycons, full signatures,
and full functor signatures) and binds that representation in the
static environment (and the entity environment if the entity in
question is primary).

Rules~\ref{eq:valdecl} and~\ref{eq:typedefdecl} elaborate values to a
semantic type expression and syntactic tycon to semantic tycon
respectively. Rule~\ref{eq:valdecl} assumes a core expression
elaboration (typechecking) judgment of the form $\Gamma\vdash e
\Rightarrow_{core} \mathfrak{T}$, which is standard. Neither of these
produce any entity declarations and entity environment because they do
not contain static entities. Rule~\ref{eq:dtdecl} generates a fresh
atomic tycon $\tau^n$ for a datatype. This atomic tycon is bound in
both the static and entity environments. The elaborator further
produces an entity declaration $\rho_t =_{tyc} \newx(n)$ that records
the functor action attributed to the datatype declaration. The entity
declaration is reserved for evaluation upon functor application of the
possible enclosing functor. When evaluated, it will produce another
atomic tycon distinct from the $\tau^n$ generated
here. Rule~\ref{eq:strdecl} elaborates the structure expression to a
full signature and a structure entity
expression. Rule~\ref{eq:fctdecl} elaborates a functor declaration via
several steps:
\begin{enumerate}
\item elaborate the functor parameter signature $\Sigma_x$
\item instantiate it $\Upsilon_x$
\item form a full signature using the result of the previous two steps $(\Sigma_x,R_x)$ where $R_x=\langle \Upsilon_x,\Upsilon\rangle$. 
\item elaborate the functor body using a static environment extended with this full signature and the entity environment extended with the structure entity 
\item form a full functor signature, a functor entity, and a functor entity expression using the structure entity expression from above
\end{enumerate}

Fig.~\ref{fig:strexpelab} elaborates a structure expression into a full signature and structure entity expression. Rule~\ref{eq:strpath} elaborates a structure path. The structure entity expression is an entity path, calculated by accumulating the entity variables in $\Gamma$ leading up to the element denoted by $p$. Rule~\ref{eq:basestr} must extract a semantic signature from the static environment produced by elaborating the base structure declarations. Rule~\ref{eq:strapp} elaborates a functor application in several steps:
\begin{enumerate}
\item looks up the entity path and full functor signature of the functor denoted by symbolic path $p$
\item elaborates the argument structure
\item coerces the argument structure and structure entity expression using the functor parameter signature by signature matching
\item forms the structure entity expression for the application 
\item evaluates the structure entity expression using the current entity environment
\end{enumerate}

Rule~\ref{eq:letexp} elaborates structure let expressions in the expected way. Rule~\ref{eq:transascription} elaborates transparent ascription by signature matching. Rule~\ref{eq:opaqueascription} elaborates opaque ascription by signature matching and then instantiating the spec signature to get fresh types for the open type specs. 

% Is the opaque ascription rule totally correct? It seems that using the spec signature and free instantion might be too much. 

An important invariant that must be maintained for module declaration elaboration is that all the atomic tycons in the static environment are also in the entity environment. This property guarantees that all atomic tycons can be relativized by the entity environment. 

\begin{lemma}
If $AT(\Gamma) \subseteq AT(\Upsilon)$ and $\Gamma,\Upsilon\vdash d^m \Rightarrow_{decl} (\eta,\Gamma',\Upsilon')$, then $AT(\Gamma') \subseteq AT(\Upsilon')$. 
\end{lemma}

The relationship between the semantic signature $\Sigma$ and structure
entity $R$ produced by elaboration is precisely related. $R$ is said
to \emph{interpret} $\Sigma$, which is defined as follows: 

\begin{definition}
$\Upsilon$ interprets $\Sigma$ if for all specs in $\Sigma$, one of the
following must be true:
\begin{enumerate}
\item If the spec is open$(\rho,n)$, then $\Upsilon(\rho)=\tau^n$
  or $\Upsilon(\rho)=\mathbb{C}^\lambda$ such that $\Upsilon\vdash
  \mathbb{C}^\lambda :: \Omega^n \to \Omega$. 
\item If the spec is a structure $(\rho,\Sigma')$, then $\Upsilon(\rho)=R'$ and $R'$ interprets $\Sigma'$. 
\item If the spec is a functor $(\rho,\Sigma^f)$, then 
  $\Upsilon(\rho)=\psi$. 
\end{enumerate}
\end{definition}

\begin{lemma}
If $\Upsilon$ interprets the extracted signature of $\Gamma$ and 
$\Gamma,\Upsilon\vdash strexp \Rightarrow_{str} ((\Sigma, R),
\varphi)$, then $R$ interprets $\Sigma$.
\end{lemma}

\section{Translation}

THO can be translated into an applied System
F$_\omega$ by decoupling the static and dynamic contents of modules.
Module systems that permit such decoupling are said to admit
\emph{phase separation} \cite{hmm:phasedist}. The elaboration
semantics given in the previous chapter is sufficient 
for typechecking. However, to support translation into F$_\omega$,
elaboration must annotate the abstract syntax with semantic objects. 

The translation rules assume an annotated module language that was
produced by an error-free elaboration. Since the program was
successfully elaborated, the semantics can make some assumptions about
the program, especially about what variables will or will not be accessed,
and thereby simplify the rules. %% Clarify or give example
The key information that must be retained are the entity variables,
the functor signature (particularly the semantic parameter signature),
and the full signature for arguments in functor applications. 

To translate structure expressions, we need both the semantic
signature and realization in the full signature for the
structure. Semantic signatures alone do not fully define the tycon
content of a structure, hence the realization is needed to look those
up. 

Translation of structure declarations and expressions is in the form
of the first two judgments in Fig.~\ref{fig:xlate-rules-summary}. The
third judgment constructs the kind information from the semantic
signatures corresponding to functor formal parameters. 
In the fourth judgment, the full
signature of a functor argument is needed to produce the type argument $c$
for the corresponding type application $e_\omega[c]$ because type
information lies in both the semantic signature and
realization. Similarly, the full functor signature is needed to
construct the F$_\omega$ tycon. 

\begin{figure}
\begin{tabular}{ll}
$d^m \leadsto_{dec} d$ & declarations\\
$strexp \leadsto_{exp} e_\omega$ & expressions\\
$\vdash \Sigma \leadsto_{knd} k$ & sem. signatures (kinds)\\
$\vdash M \leadsto_{tyc} c$ & full signatures\\
$\vdash F \leadsto_{fctspec} c$ & full functor signature\\
$\vdash \mathfrak{C}^{nf}
\leadsto_{type}^{nf} t$ & \\
$\Delta, \Upsilon\vdash \mathbb{C}^s
\leadsto_{type}^{tyc} t$ & \\
$\Upsilon\vdash\mathbb{T}\leadsto_{type}^{t}
t$ & \\
$\Upsilon\vdash \Sigma \leadsto_{type} lts$ & \\
\end{tabular}
\caption{Translation Rules}
\label{fig:xlate-rules-summary}
\end{figure}

% The notation $dom(d)$ here denotes the set of
% all the bound names,\ie, the $\rho$ in $\rho=e$. 

Rules~\ref{eq:transdec-str}
and~\ref{eq:transdec-fct} must produce declarations binding the entity
variable of the structure or functor instead of the syntactic
variable. % Is this necessary? Yes, structures and functors are static
          % entities but these rules only care about the dynamic
          % components for which there is no avoidance problem. 
The rule~\ref{eq:transdec-fct} will use the judgment $\vdash \Sigma
\leadsto_{sig} k$ defined in Fig.~\ref{fig:semsigtokinds} to extract
the kind information from the semantic signature for the functor
parameter. The type for the F$_\omega$ $\lambda$ abstraction is
calculated separately from the same semantic signature. 

Fig.~\ref{fig:transexp} gives the translation of the module
language expressions to F$_\omega$. Rule~\ref{eq:transexp-app} translates
structure applications. The functor being applied can be translated by
translating its entity path to the corresponding F$_\omega$ record
projection form. The actual argument structure expression is
translated to $e_\omega$, but the functor is expecting a parameter of
the form defined in full signature $M$. The associated coercion
structure expression $\letin{\rho_u=\varphi_u}{\llparenthesis \eta
  \rrparenthesis}$ can help produce coerced type and value
arguments. For the type argument, the rule translates the coercion entity
declaration to F$_\omega$ via the $\tycon$ function defined in
Fig.~\ref{fig:xlate-entdec}. For the value argument, reusing the
uncoerced expression by aliasing $\rho_{par} = \rho_u$ is sufficient
because the prior elaboration already guarantees that none of
components in $\rho_u$ that is not specified in the formal parameter
signature will be accessed. Furthermore, none of the variables are
being renamed. 

The F$_\omega$ kinds, tycons, and types for tycon content of
structures, type content of structures, and structures themselves are
record kinds, record tycons, and record types respectively. Each
label-field pair is a pair of an entity variable and the kind, tycon,
and type of the entity referred to by that entity variable. Let $lks$,
$lcs$, and $lts$ be a sequence of record label-field for kinds,
tycons, and types respectively. The notation $lks\uplus lks'$ appends
two record kinds. The notation is extended in the usual way to append
tycons and types. No shadowing is expected because all records field
names will be entity variables.

Fig.~\ref{fig:semsigtokinds} gives the rules for producing $F_\omega$
kinds from semantic signatures. Value specs and type definition specs
do not contribute to the kind (rules~\ref{eq:f-semsig-val} and~
\ref{eq:f-semsig-typedef}). Open tycon specs do
contribute. Rule~\ref{eq:f-semsig-opentype} produces the kind field
$\rho::\Omega^n \Rightarrow \Omega$ such that $n$ is the arity of the
open tycon spec. Rules~\ref{eq:f-semsig-str} and~\ref{eq:f-semsig-fct}
construct kinds for structure and functor specs from the semantic
signature and functor signature respectively. 

Fig.~\ref{fig:f-tycon-synthesis} defines the judgment that calculates
the tycons from the full signature of a structure. Again, value specs,
and type definition specs do not contribute to the tycon
(rules~\ref{eq:transspec-val} and~\ref{eq:transspec-typedef}).
Rule~\ref{eq:transspec-opentype} translates an open spec by looking up
the entity environment for the tycon entity associated with the open
tycon spec. The rule~\ref{eq:transspec-str} translates the structure
spec signature in the context of the entity environment calculated
from the structure entity
($\Upsilon(\rho)=\langle\Uloc,\Uclo\rangle=\Uclo\Uloc$).  To calculate
the tycon for a functor component, rule~\ref{eq:transspec-fct} must
supply rule~\ref{eq:trans-fctspec} the functor signature and entity
from looking up the entity environment. Rule~\ref{eq:trans-fctspec}
calculates the kind for the functor parameter using the parameter
signature and also the tycon for the functor body from the functor
body signature and closure entity environment. The judgment relies on
$\vdash \varphi \leadsto^{strexp}_{tyc} c$ which translates the
structure entity expression to the corresponding F$_\omega$ tycon
expression, which is the same because there is an embedding of the
structure entity expression language to the F$_\omega$ tycon
expression language. The above statement fully defines $\vdash \varphi
\leadsto^{strexp}_{tyc} c$.

Fig.~\ref{fig:fty-sig} gives the rules
for producing $F_\omega$ types from semantic signatures. These two
judgments decompose semantic signatures into kinds (for classifying
the static components) and types (for classifying the dynamic
components). Kind synthesis is used in rule~\ref{eq:fty-fct} to
produce the kind annotation for the polymorphic quantifier. 

Let the $\mathsf{env}(lts) = [\rho:t]$ where $\rho_i:t_i \in lts$ for
the purpose of fig.~\ref{fig:xlate-entdec}.

In the module system, subtyping in functor application may ``thin''
out an argument structure. To model this behavior in F$_\omega$, we
use a value-level coercion primitive $\coerce$. 
Fig.~\ref{fig:xlate-entdec} defines the function $\coerce$ that
coerces an F$_\omega$ expression $e_\omega$ to a record type $lts$. 
It thins out the value part by dropping components not
in the specified type. The resultant expression should have the target
type $\{lts\}\{c/\rho\}_{tyc}$ where $lts$ is parameterized by
$\rho$. The type-level coercion was already taken care of by
F$_\omega$ tycon synthesis. 

\begin{lemma}[Well-Typing of Coercions]
Let $E$ be a static environment (type and kind environment). 
If $E\vdash \rho_u : t_u$, $t_c\{c/\alpha\} = t_u$, and
$\coerce(\rho_u, c, t_c) = e_\omega$, then $E\vdash e_\omega : t_c\{c/\alpha\}$. 
\end{lemma}

\section{Soundness}

\begin{theorem}
If a closed structure expression $strexp$ elaborates to $(M, \_)$ and $strexp$
translates to $e_\omega$, then $\vdash e_\omega : t$ and $\vdash M \leadsto_{type} t$. 
\end{theorem}

The proof of the above lemma is sketched out in more detail in the
proof appendix. It relies on much of the same machinery as Shao's
proof~\cite{shao98}. The proof diverges in Shao's memoization of
pre-translated F$_\omega$ tycon and types in the functor
representation during elaboration of the functor. Furthermore, this
proof must deal with the coercive signature matching semantics which
is not present in Shao's main elaboration-translation semantics. 

\section{Type Generativity}

Shao's calculus and many of the related accounts of the module system
do not fully support the type generativity present in ML. Type
generativity stems from two constructs, opaque ascription and datatype
declarations. 

Seemingly benign examples that feature datatype declarations are not supported. 

\begin{lstlisting}
structure M = 
struct 
  datatype t
  val id : t -> t = fn x:t => x
end
\end{lstlisting}

\begin{lstlisting}
functor F() = 
struct
  datatype t
  val id : t -> t = fn x:t => x
end
\end{lstlisting}

Datatype declarations are an interesting case because unlike the rest
of the static content of a module, datatype declarations translate to
F$_\omega$ tycons that are not referentially transparent. Whereas all
other forms of F$_\omega$ tycons can be duplicated and be supplied as
arguments to type applications, the tycons from datatype declarations
cannot. This is because the identity of the tycon from a datatype must
be maintained. The tycon cannot be copied. Consequently, such a tycon
must be bound (by the special let tyc form) to a type variable that is
in the scope of all subsequent occurrences. It turns out that in
general, the expressions constructing these tycons are exactly the
entity expressions from the module system. The referentially
transparent static content such as type definitions can continue to be
packaged together in a tycon record to which $\Lambda$ type
abstractions can be directly applied.

Another difference between datatype declarations and type definitions
is what is translated into F$_\omega$. For datatype declarations, the
entity expression is translated. For type definitions, the full
signature is directly translated to an F$_\omega$ tycon. 

Translation decomposes functors into a tycon part and a value
part. The hat notation $\widehat{x}$ denotes the variable is a type
variable that refers to the type part of a structure or functor x. Let
$k$ represent $\Omega^0 \to \Omega$. 

\begin{lstlisting}
functor f(x:sig type s type t end) = 
struct datatype w type v = x.t end
\end{lstlisting}
\[\lettycline{\widehat{f}=\lambda \widehat{x}::\{s::k,t::k\}.\{w =
  \newx(0), v=\widehat{x}.t \}}
{\letin{f = \Lambda\widehat{x}::\{s::k, 
t:: k
    \}.\lambda x:\{\}.\{\}}
 {\ldots}}
\]

For the above example functor $f$, the primary tycon part is a tycon
function $\lambda \widehat{x}
. \{w = \newx(0) \}$, which is exactly a straightforward
translation of the structure entity expression for the functor
body. The value part is $\Lambda\widehat{x}::\{s::k, 
t :: k \}.\lambda x.\{\}.\{\}$. The
secondary tycon part $v = \widehat{x}.t$ corresponds to the type definitions
\lstinline{type v = x.t}.

The above translation is sufficient in absence of value components,
whose type annotations may refer to tycons (the type part of the
functor). The value components in the functor parameter may refer to
tycons in the functor parameter. The value components in the functor
body may refer to tycons in either the functor parameter or
body. However, since the tycons in the functor body are not accessible
until the type part of the functor is applied, the value part of the
functor must take an extra type parameter, the result of applying the
type part of the functor. 

\begin{lstlisting}
functor f(x:sig type s end) = 
struct datatype w val n : w -> w = fn z : w => z end
\end{lstlisting}

\[\lettycline{\widehat{f}=\lambda\widehat{x}::\{s::k\}.\{ w = \newx(0) \}}
  {~\letx~f = \Lambda \widehat{x}::\{s::k\}.\Lambda
      \widehat{f_{res}}::\{ w :: k \} . \lambda x::\{\}.\\
      ~~~~~~~~~~~~~~~~~~\{n = \lambda z:\widehat{f_{res}}.w\}\\
    \inx~\ldots}
\]

The first curried type abstraction $\Lambda\widehat{x}::\{s::k\}$ is
the type part of the functor parameter. The second type
abstraction $\Lambda \widehat{f_{res}}::\{ w :: k \}$ is for the
result of applying the type part $\widehat{f}$ to the same type part
of the functor argument $\widehat{x}$. The type annotation in the
body of the value part $n$ can refer to the tycon $w$ through
$\widehat{f_{res}}.w$. 
 
Functor application must coerce both the tycon and value parts
of the argument structure. 

\begin{lstlisting}
structure m = f(struct datatype s type t = s end)
\end{lstlisting}
\[\begin{array}{l}
  \letx~\tyc~\widehat{u} = \{s'=\newx(0) \}\\
  \inlet~\tyc~\widehat{m} = \widehat{f}(\{s = \widehat{u}.s', t =
  \widehat{u}.s' \})\\
  \inlet~m = f[\{s = \widehat{u}.s', t =
  \widehat{u}.s'\}](\{ \})\\
  \inx~\ldots
 \end{array}\]

In the above example, the translation first decomposes the argument
structure into a
primary tycon part $\{s'=\newx(0)\}$, a value part $\{ \}$, and a
secondary tycon part $t = \widehat{u}.s'$. Note that the entity
variable for the argument structure $s'$ that is distinct from
the entity variable in the formal parameter $s$. The entity
variable $\widehat{u}$ binds the raw, uncoerced primary tycon part of the
argument structure. The raw, uncoerced secondary tycon part is
directly inlined because the syntactic functor application inlines the
argument structure. The tycon part of $\widehat{f}$ is applied to the coerced
tycon part of the argument structure, $\widehat{f}(\{s=\widehat{u}.s',
t=\widehat{u}.s'\})$ where $\widehat{f}$ here refers to the tycon
function bound in the previous example. The value part of $f$ is
applied to the coerced tycon and value parts of the argument
structure, $f[\{s=\widehat{u}.s',t=\widehat{u}.s'\}]
(\{\})$.

Since the tycon part of functor is a translation of the functor entity
expression, the tycon part also represents the nested functors in the
functor body. 

\begin{lstlisting}
functor f() = struct functor g() = struct datatype t end end
\end{lstlisting}
\[ \begin{array}{l}
\letx~\tyc~\widehat{f} = \lambda().\{\widehat{g} = \lambda().\{ t =
\newx(0) \} \}\\
   \inlet~f = \Lambda()::\{\}.\lambda():\{\}.\{\}
\end{array}
\]

The tycon part of the nested functor $g$ is $\lambda().\{t =
\newx(0)\}$. Thus, the tycon part $\widehat{f}$ must be the first line in the
example above. In this example, the value part is degenerate since
there are no value components. 

Formal functors are handled in the same way as above. 

\begin{lstlisting}
functor f(x:sig functor g(y: sig type t end) : sig type v end end) =
struct end

structure m = f(struct 
                  functor g(y: sig type t end) = 
                    struct type v = y.t end 
             end)
\end{lstlisting}

The above example translates to the following F$_\omega$ program.
\[\begin{array}{l}
\letx~\tyc~\widehat{f} = \lambda\widehat{x}::\{\widehat{g}::\{\widehat{y}::\{t :: k\}\}\to\{ v :: k \}\}.\{\}\\
\inlet~f = \Lambda\widehat{x}::\{ \widehat{g}::\{\widehat{y}::\{t :: k\}\}\to\{ v :: k \}
\}.\\
~~~~~~~~~~~~~~~~~\lambda x:\{ g : \forall\widehat{y}::\{ t ::
k \}\to \{ v :: k \}\}. \{\} \}\\
\inlet~\tyc~\widehat{u} = \{ \rho_g' = \lambda\rho_y'.\{ \} \}\\
\inlet~u = \{ g' = \Lambda \widehat{y'}::\{ \widehat{g'} :: \{ t'
:: k\} \to
\{ v' :: k\} \}.\lambda y'.\{ \} \}\\
\inlet~\tyc~\widehat{m} = \widehat{f}(\{\widehat{g} = u.\widehat{g'} \})\\
\inlet~m = f[\{ \widehat{g} = \lambda \widehat{y'} :: \{ \}  . \{ v' =
\widehat{y'}.t  \} \}](\{ g = u.g' \})
\end{array}\]

The arrow kinds are given to the tycon abstractions representing the formal functor, reflective of how functors can be viewed as type operators. 
The tycon and value parts
of the uncoerced functor argument are $\{\widehat{g'}=\lambda \widehat{y'}. \{
\}\}$ and
$\{g'=\lambda y'.\{\}\}$ respectively.  

Support for type generativity requires some modification of the
translation rules for functor declaration and functor application.

        \begin{equation}
          \infer{
            \begin{array}{c}
              \mathbf{functor}~f\an{\rho,F,\Upsilon_{ins}}(X:sigexp)=strexp\\
            \leadsto_{dec} \rho=_{tyc} \theta, \rho=\Lambda \rho_x::k.\lambda
            \rho_x:t.e_\omega
          \end{array}}
          {\begin{array}{c}
              F=(\Pi\rho_x:\Sigma_{par}.\Sigma', \langle\theta; \Uclo\rangle)\qquad
            \vdash \Sigma_{par} \leadsto_{knd} k\\ \Upsilon_{ins}\vdash \Sigma_{par}
            \leadsto_{type} t\qquad
             strexp \leadsto_{exp}  e_\omega
          \end{array}}
       \end{equation}

     \begin{equation}
       \infer{ \begin{array}{c}
         \structure~x\an{\rho_x}=p\an{\vec{\rho},\rho_{par}}
         (strexp\an{M_c,\rho_u}) \\
         \leadsto_{exp}
         \letx~\tyc~\rho_x= \vec{\rho}(\coerce_{tyc}(\rho_u,c))\\
          \inx~\letx~\rho_x=
         \vec{\rho}(\coerce_{tyc}(\rho_u,c)),
         \letin{\rho_u=e_{\omega_u}}{\vec{\rho}[c](e_{\omega_c})}
       \end{array}}
       {\begin{array}{c}  
           strexp \leadsto_{exp} e_\omega\qquad
           M_c \leadsto_{tyc}  c\qquad M_c=(\Sigma, R) \\
           R\vdash \Sigma\leadsto_{type} lts_c\qquad
           e_{\omega_c} = \coerce(\rho_u,c,\{lts_c\})
         \end{array}}
     \end{equation}

\bibliography{modules}

\appendix 
% \section{Module Language}
% \input{../dissertation/figs/fig-typesystem}
% \input{../dissertation/figs/fig-wellkinding}     
% \input{../dissertation/figs/fig-semtypesystem}
% \input{../dissertation/figs/fig-wellkinding-semantic}
% \input{figs/fig-tyceval}

\pagebreak 

\section{Elaboration}
% \input{figs/fig-semobj}
\input{../dissertation/figs/fig-typeelab} 
\input{figs/fig-elabsig}    
\input{../dissertation/figs/fig-inst}
\input{../dissertation/figs/fig-toplevel}
\input{figs/fig-elabmod}
\input{figs/fig-extractsig}
\input{../dissertation/figs/fig-strsigmtch0}
\input{../dissertation/figs/fig-strsigmtch}
\input{../dissertation/figs/fig-fsgmtch}  
          
\pagebreak 

\section{Translation}
Fig.~\ref{fig:annotatedlang} gives the grammar for the module language
annotated with semantic objects (enclosed by double angle brackets
$\an{}$). 

\subsection{Annotated Module Language}
Translation of functor application makes argument coercions
explicit by projecting the appropriate subset of components as
required by the functor parameter signature. 



Functor
must further be annotated with the  
formal parameter entity variable used to produce the necessary
coercions to get the type and value  
content of an argument structure into the proper form. 

The argument
structure should be annotated with its coercion full signature and coercion
structure entity expression. The associated entity variable should
annotate both structure and functor declarations. The functor
declaration further requires the annotation of a full functor
signature and free instantiation entity environment. All this
information is readily available during the elaboration process. Thus,
annotating is straightforward. Below, I show a select modified rule:  

\begin{equation} 
\infer{
\begin{array}{c}
\Gamma,\Upsilon\vdash p(strexp)
\\ \Rightarrow_{str}
(p\an{\vec{\rho},\rho_{par}}(strexp\an{M_{c},\rho_u}),(\Sigma_{body},R_{app}),\varphi_{app})
\end{array}}
	{
\begin{array}{c}
\Gamma(p) = (\vec{\rho}, (\Pi \rho_{par}:\Sigma_{par}.\Sigma_{body},
\langle\theta; \Upsilon'\rangle)) \\
\Gamma,\Upsilon\vdash strexp\Rightarrow_{str}
(M,\varphi)\\ 
\Upsilon\vdash (M,\varphi) : \Sigma_{par} \Rightarrow_{match}
(M_{c},\letin{\rho_u=\varphi}{\llparenthesis \eta \rrparenthesis})\\
\varphi_{app} = \vec{\rho}(\varphi_{c})\qquad \Upsilon\vdash \varphi_{app} \Downarrow_{str} R_{app}
\end{array}}
%\label{eq:annotating-strapp}
\end{equation}

As shown in the above rule, the entity path for the functor and the
functor parameter entity variable are in the
static environment at elaboration time. 
%The coercion full signature
%$M_c$ and entity variable $\rho_u$ for the uncoerced argument
%structure. 

\subsection{Target Language: System F$_\omega$}
Fig.~\ref{fig:fomega} gives the grammar for the applied
System F$_\omega$. The language is nearly identical to the one Shao
used~\cite{shao98}. It is an F$_\omega$ core enriched with record
types and declarations. 

An F$_\omega$ kind $k$ is either a monokind or an arrow kind. A tycon
$c$ can be a type variable, an atomic tycon $\mathsf{inj}(\tau^n)$, an
explicitly kinded tycon-level $\lambda$ abstraction, and a tycon
application. The tycon for a record is represented as
$\{l_0 : c_0,\ldots,l_n : c_n\}$ where $l_i$'s are record field labels and
$c_i$'s are the tycons for the fields corresponding to those
labels. The tycon form $c.l$ can project out the field type of field
$l$ assuming that $c$ is a record type containing a field of that
label. Type expressions $t$ are either a tycon or an explicitly quantified
and kinded polymorphic type $\forall\alpha::k.t$. Unlike the version of
the F$_\omega$ type system given by Shao, this type
system includes atomic tycons. Also, this type system simplifies
Shao's by subsuming base types (int) and arrow types $\tau\to\tau'$ using an atomic tycon
and type application $\to^2(\tau)(\tau')$. Types $t$ omit arrow and
record types from Shao's version. 

F$_\omega$ expressions include variables, an explicitly-typed
$\lambda$-abstractions, applications of expressions, an explicitly-kinded type
abstraction $\Lambda\alpha::k.e_\omega$, and type application
$e_\omega[c]$. An expression can also be a record expression
$\{l_0=e_{\omega_0},\ldots,l_n=e_{\omega_n}\}$, a record field
projection $e_\omega.l$, or a let expression. Within let expressions
are declarations, which are sequences of variables bound to
expressions terminated by $\cdot$, the empty declaration. The same
environment is used for both kinding $\alpha::k$ and typing $x:t$. Note that the
abstraction ($\lambda x:t.e_\omega$) and type application
$e_{\omega}[t]$ both permit application to polymorphic types
$\forall\alpha::k.t$. This is necessary because functors and
functor applications in the module language support abstraction over
polymorphic types ($\mathsf{functor}~F(X:\mathsf{sig~val}~id :
\forall\alpha.\alpha\to\alpha~\mathsf{end})=\mathsf{struct~end}$) and
application to such types. When these are translated to F$_\omega$,
the polymorphism must be maintained. 

\subsection{Kind System}
Fig.~\ref{fig:fomega-kinding} describes well-kinding of F$_\omega$
tycons. The kind system is standard. The judgment relies only on the
kind part of the environment. Rule~\ref{eq:f-k-at} gives the curried
kind for the $n$-ary atomic tycon. The resultant kind is curried $n$
times.  Rules~\ref{eq:f-k-rec}
and~\ref{eq:f-k-proj} kind record tycons and record projection tycons
respectively in the usual way. 

\subsection{Type System}
Fig.~\ref{fig:fomegatype} gives the type system for
F$_\omega$. $\vdash t~\mathsf{type}$ is an axiom. In particular
$\vdash k~\mathsf{type}$ is not true. Type application
(rule~\ref{eq:ftapp}) assumes that the left-hand side has a type
$\lambda\alpha.k.t'$. The type of the type application is
$t'\{t/\alpha\}$. Rule~\ref{eq:frec} gives the record tycon
$\{l_0:c_0,\ldots,l_n:c_n\}$ for a
record expression $\{l_0=e_0, \ldots, l_n=e_n\}$ as long as all its
field expressions have the correct type,\ie, $e_i : t_i$. 

The notation $\{c/\alpha\}_{tyc}$ denotes tycon substitution. This
kind of substitution does not act on values that may coincidentally
share the same name $\alpha$. This distinct form of substitution is
necessary because tycons and values will have distinct namespaces. 
      

% \input{figs/fig-annotated}
 \input{../dissertation/figs/fig-fomega}
 \input{../dissertation/figs/fig-fomega-kinding}
 \input{../dissertation/figs/fig-fomega-typesystem}
 \input{../dissertation/figs/fig-xlate}
 \input{../dissertation/figs/fig-xlate-sig}
 \input{../dissertation/figs/fig-xlate-entdec}

\end{document}
