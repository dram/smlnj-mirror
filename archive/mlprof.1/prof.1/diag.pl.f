hello there
[Loading CompVax]
[Loading VaxGlue]
[Loading VaxCodes]
[Loading VaxMCode]
[Loading BasicVax]
[Loading Backpatch]
[Loading Dynamic]
[Loading ErrorMsg]
[Executing ErrorMsg]
[Executing Dynamic]
[Executing Backpatch]
[Executing BasicVax]
[Loading BitOps]
[Executing BitOps]
[Loading RealConst]
[Loading Bigint]
[Executing Bigint]
[Executing RealConst]
[Executing VaxMCode]
[Loading VaxAsCode]
[Loading VaxAssem]
[Executing VaxAssem]
[Executing VaxAsCode]
[Loading VaxPeephole]
[Executing VaxPeephole]
[Loading VaxGen]
[Loading VaxPrim]
[Loading Symbols]
[Loading Symbol]
[Executing Symbol]
[Loading Token]
[Executing Token]
[Executing Symbols]
[Loading Prim]
[Loading Access]
[Executing Access]
[Loading Basics]
[Loading Table]
[Executing Table]
[Loading PrintUtil]
[Executing PrintUtil]
[Executing Basics]
[Loading Sort]
[Executing Sort]
[Loading BasicTypes]
[Loading Tuples]
[Executing Tuples]
[Executing BasicTypes]
[Executing Prim]
[Loading EnvAccess]
[Loading Env]
[Loading EnvBind]
[Executing EnvBind]
[Loading EnvFunc]
[Executing EnvFunc]
[Executing Env]
[Loading PrintType]
[Loading List2]
[Executing List2]
[Executing PrintType]
[Loading Ascii]
[Executing Ascii]
[Loading Intmap]
[Executing Intmap]
[Loading BinSort]
[Executing BinSort]
[Loading TypesUtil]
[Executing TypesUtil]
[Loading Absyn]
[Loading BareAbsyn]
[Executing BareAbsyn]
[Executing Absyn]
[Executing EnvAccess]
[Loading CGoptions]
[Executing CGoptions]
[Executing VaxPrim]
[Executing VaxGen]
[Executing VaxCodes]
[Loading Invoke]
[Loading Lambda]
[Loading PrintBasics]
[Executing PrintBasics]
[Executing Lambda]
[Loading Codegen]
[Loading Switcher]
[Executing Switcher]
[Loading Codenv]
[Loading Opt]
[Loading Intset]
[Executing Intset]
[Executing Opt]
[Executing Codenv]
[Executing Codegen]
[Loading MCprint]
[Loading PrintAbsyn]
[Executing PrintAbsyn]
[Executing MCprint]
[Loading Typecheck]
[Loading Overload]
[Executing Overload]
[Executing Typecheck]
[Loading Translate]
[Loading Unboxed]
[Executing Unboxed]
[Loading Equal]
[Executing Equal]
[Loading Nonrec]
[Executing Nonrec]
[Loading MC]
[Loading MCopt]
[Executing MCopt]
[Executing MC]
[Executing Translate]
[Loading PrintDec]
[Loading PrintVal]
[Executing PrintVal]
[Executing PrintDec]
[Loading Parse]
[Loading Topsort]
[Executing Topsort]
[Loading ConRep]
[Executing ConRep]
[Loading Sharing]
[Loading Siblings]
[Loading Unionfind]
[Executing Unionfind]
[Executing Siblings]
[Executing Sharing]
[Loading SigMatch]
[Executing SigMatch]
[Loading FirstSets]
[Loading Lex]
[Loading CharBuffer]
[Executing CharBuffer]
[Executing Lex]
[Executing FirstSets]
[Executing Parse]
[Executing Invoke]
[Executing VaxGlue]
[Loading Compile]
[Loading M68options]
[Executing M68options]
[Executing Compile]
[Executing CompVax]
[Loading boot/perv.sig]
signature REF
signature LIST
signature ARRAY
signature BYTEARRAY
signature BASICIO
signature IO
signature BOOL
signature STRING
signature INTEGER
signature REAL
signature GENERAL
signature PERVASIVES
[closing boot/perv.sig]
[Loading boot/assembly.sig]
signature ASSEMBLY
[closing boot/assembly.sig]
[Loading boot/system.sig]
signature RUNTIMECONTROL
signature MCCONTROL
signature CGCONTROL
signature PRINTCONTROL
signature CONTROL
signature TIMER
signature TAGS
signature STATS
signature SYSTEM
[closing boot/system.sig]
[Compiling boot/math.sml]
signature MATH
functor Math
[closing boot/math.sml]
[Compiling boot/perv.sml]
functor PervFunc
[closing boot/perv.sml]
[Loading boot/assembly.sml]
structure Dummy
structure Initial
[closing boot/assembly.sml]
[Loading boot/overloads.sml]
structure Overloads
[closing boot/overloads.sml]
hello there
[globalhandle := false]
[dumpCore := true]
[Compiling boot/loader.sml]
signature Startup
functor Loader
[closing boot/loader.sml]
[Compiling util/errormsg.sml]
signature ERRORMSG
structure ErrorMsg
[closing util/errormsg.sml]
[Compiling util/dynamic.sml]
signature STATIC_ARRAY
signature DYNAMIC_ARRAY
functor Dynamic
[closing util/dynamic.sml]
[Compiling util/sort.sml]
structure Sort
[closing util/sort.sml]
[Compiling util/binsort.sml]
structure BinSort
[closing util/binsort.sml]
[Compiling util/list2.sml]
structure List2
[closing util/list2.sml]
[Compiling util/intset.sml]
structure Intset
[closing util/intset.sml]
[Compiling util/intmap.sml]
structure Intmap
[closing util/intmap.sml]
[Compiling util/topsort.sml]
structure Topsort
[closing util/topsort.sml]
[Compiling util/union.sml]
signature UNIONFIND
structure Unionfind
signature SIBLINGS
structure Siblings
[closing util/union.sml]
[Compiling basics/token.sml]
signature TOKEN
structure Token
[closing basics/token.sml]
[Compiling basics/symbol.sml]
signature SYMBOL
structure Symbol
[closing basics/symbol.sml]
[Compiling util/printutil.sml]
signature PRINTUTIL
structure PrintUtil
[closing util/printutil.sml]
[Compiling lex/ascii.sml]
structure Ascii
[closing lex/ascii.sml]
[Compiling lex/symbols.sml]
signature SYMBOLS
structure Symbols
[closing lex/symbols.sml]
[Compiling lex/charbuff.sml]
signature CHAR_BUFFER
structure CharBuffer
[closing lex/charbuff.sml]
[Compiling lex/lex.sml]
signature LEX
structure Lex
[closing lex/lex.sml]
[Compiling basics/table.sml]
signature TABLE
structure Table
basics/table.sml, line 75: Warning: binding not exhaustive
        x :: b = ...
[closing basics/table.sml]
[Compiling basics/access.sig]
signature ACCESS
[closing basics/access.sig]
[Compiling basics/access.sml]
structure Access
[closing basics/access.sml]
[Compiling basics/basics.sig]
signature BASICS
[closing basics/basics.sig]
[Compiling basics/basics.sml]
structure Basics
[closing basics/basics.sml]
[Compiling basics/tuples.sig]
signature TUPLES
[closing basics/tuples.sig]
[Compiling basics/tuples.sml]
structure Tuples
[closing basics/tuples.sml]
[Compiling basics/basictypes.sig]
signature BASICTYPES
[closing basics/basictypes.sig]
[Compiling basics/basictypes.sml]
structure BasicTypes
[closing basics/basictypes.sml]
[Compiling basics/printtype.sml]
signature PRINTTYPE
structure PrintType
basics/printtype.sml, line 140: Warning: binding not exhaustive
        domain :: range :: nil = ...
basics/printtype.sml, line 140: Warning: binding not exhaustive
        TYCON {stamp=arrowStamp,...} = ...
[closing basics/printtype.sml]
[Compiling basics/typesutil.sig]
signature TYPESUTIL
[closing basics/typesutil.sig]
[Compiling basics/typesutil.sml]
structure TypesUtil
basics/typesutil.sml, line 356: Warning: binding not exhaustive
        ty2 :: argTys' = ...
basics/typesutil.sml, line 356: Warning: binding not exhaustive
        STRstr {env=env,...} = ...
[closing basics/typesutil.sml]
[Compiling basics/printbas.sml]
structure PrintBasics
[closing basics/printbas.sml]
[Compiling basics/conrep.sml]
structure ConRep
[closing basics/conrep.sml]
[Compiling absyn/bareabsyn.sig]
signature BAREABSYN
[closing absyn/bareabsyn.sig]
[Compiling absyn/bareabsyn.sml]
structure BareAbsyn
[closing absyn/bareabsyn.sml]
[Compiling absyn/absyn.sml]
structure Absyn
[closing absyn/absyn.sml]
[Compiling env/prim.sml]
structure Prim
env/prim.sml, line 120: Warning: match not exhaustive
        (s' :: rest,n) => ...
[closing env/prim.sml]
[Compiling env/env.sml]
signature BIND
signature ENV
functor EnvFunc
env/env.sml, line 293: Warning: binding not exhaustive
        OPEN s :: _ = ...
env/env.sml, line 293: Warning: binding not exhaustive
        OPEN s :: _ = ...
env/env.sml, line 293: Warning: binding not exhaustive
        OPEN s :: _ = ...
structure EnvBind
structure Env
[closing env/env.sml]
[Compiling env/envaccess.sig]
signature ENVACCESS
[closing env/envaccess.sig]
[Compiling env/envaccess.sml]
structure EnvAccess
env/envaccess.sml, line 703: Warning: binding not exhaustive
        str as STRstr {stamp=stamp,...} = ...
env/envaccess.sml, line 703: Warning: binding not exhaustive
        STRstr {env={s=s,t=t},...} = ...
env/envaccess.sml, line 703: Warning: match not exhaustive
        (STRstr {env=env,table=table,...},id,ap) => ...
env/envaccess.sml, line 703: Warning: match not exhaustive
        (STRstr {env=env,table=table,...},id,ap) => ...
env/envaccess.sml, line 703: Warning: match not exhaustive
        (tv as ref (UBOUND id')) :: resttvs => ...
        nil => ...
env/envaccess.sml, line 703: Warning: binding not exhaustive
        OPENbtv (ref l) = ...
env/envaccess.sml, line 703: Warning: binding not exhaustive
        VARbind (VALvar {vtype=ref ty,...}) = ...
env/envaccess.sml, line 703: Warning: binding not exhaustive
        VARbind v = ...
env/envaccess.sml, line 703: Warning: match not exhaustive
        (pl as (varRef as ref <pat>) :: pl',tl) => ...
        (nil,tl) => ...
env/envaccess.sml, line 703: Warning: match not exhaustive
        (STRstr {env=env,table=table,...},id,ap) => ...
env/envaccess.sml, line 703: Warning: match not exhaustive
        (STRstr {env=env,table=table,...},id,ap) => ...
env/envaccess.sml, line 703: Warning: binding not exhaustive
        ref (UNDEFtyc id) = ...
env/envaccess.sml, line 703: Warning: match not exhaustive
        (STRstr {env=env,table=table,...} : Structure,id : symbol) => ...
env/envaccess.sml, line 703: Warning: match not exhaustive
        STRvar {access=PATH p,binding=STRstr {env=<pat>,table=<pat>,...},...} :: r => ...
        nil => ...
[closing env/envaccess.sml]
[Compiling absyn/printabsyn.sml]
signature PRINTABSYN
structure PrintAbsyn
[closing absyn/printabsyn.sml]
[Compiling typing/overload.sig]
signature OVERLOAD
[closing typing/overload.sig]
[Compiling typing/overload.sml]
structure Overload
[closing typing/overload.sml]
[Compiling typing/typecheck.sig]
signature TYPECHECK
[closing typing/typecheck.sig]
[Compiling typing/typecheck.sml]
structure Typecheck
typing/typecheck.sml, line 343: Warning: binding not exhaustive
        VALvar {vtype=refty,...} = ...
typing/typecheck.sml, line 343: Warning: binding not exhaustive
        VARpat (VALvar {vtype=refty,...}) = ...
[closing typing/typecheck.sml]
[Compiling typing/sharing.sml]
signature SHARING
structure Sharing
typing/sharing.sml, line 194: Warning: binding not exhaustive
        STRstr {stamp=s2,...} = ...
typing/sharing.sml, line 194: Warning: binding not exhaustive
        STRstr {stamp=s1,...} = ...
typing/sharing.sml, line 194: Warning: binding not exhaustive
        str2 as STRstr {stamp=s2,...} = ...
typing/sharing.sml, line 194: Warning: binding not exhaustive
        str1 as STRstr {stamp=s1,...} = ...
typing/sharing.sml, line 194: Warning: binding not exhaustive
        STRstr {env=env,kind=kind,sign=sign,stamp=stamp,table=table} = ...
typing/sharing.sml, line 194: Warning: match not exhaustive
        (str1 as STRstr {env={s=<pat>,t=<pat>,...},kind=k1,stamp=s1,...},str2 as STRstr {env={s=<pat>,t=<pat>,...},kind=k2,stamp=s2,table=table,...}) => ...
typing/sharing.sml, line 194: Warning: match not exhaustive
        (p' as STRstr {stamp=p,...},q' as STRstr {stamp=q,...}) => ...
typing/sharing.sml, line 194: Warning: match not exhaustive
        (nil,str) => ...
        (id :: rest,STRstr {env={s=s,...},table=table,...}) => ...
[closing typing/sharing.sml]
[Compiling typing/sigmatch.sml]
signature SIGMATCH
structure SigMatch
typing/sigmatch.sml, line 371: Warning: binding not exhaustive
        str' as STRstr {sign=sign',stamp=stamp',...} = ...
typing/sigmatch.sml, line 371: Warning: binding not exhaustive
        STRstr {kind=SIGkind {stampcounts={s=<pat>,t=<pat>},...},...} = ...
typing/sigmatch.sml, line 371: Warning: binding not exhaustive
        DATACON {rep=VARIABLE access,typ=typ',...} = ...
typing/sigmatch.sml, line 371: Warning: match not exhaustive
        (STRstr {env=env,sign=sign,stamp=stamp,table=table,...},str as STRstr {env=env',...}) => ...
        (INDstr i,_) => ...
typing/sigmatch.sml, line 371: Warning: match not exhaustive
        (sgn as STRstr {kind=SIGkind <pat>,...},str) => ...
[closing typing/sigmatch.sml]
[Compiling print/printval.sig]
signature PRINTVAL
[closing print/printval.sig]
[Compiling print/printval.sml]
structure PrintVal
print/printval.sml, line 158: Warning: match not exhaustive
        (nf,l :: nil,ty :: nil) => ...
        (nf,l :: restl,ty :: restty) => ...
        (nf,nil,nil) => ...
print/printval.sml, line 158: Warning: match not exhaustive
        "nil" => ...
        "::" => ...
print/printval.sml, line 158: Warning: match not exhaustive
        CONty (_,dom :: _) => ...
        POLYty (TYFUN {body=CONty (<pat>,<pat>),...}) => ...
print/printval.sml, line 158: Warning: redundant patterns in match
        ABStyc => ...
        DEFtyc _ => ...
        DATAtyc _ => ...
        RECORDtyc nil => ...
        RECORDtyc labels => ...
  -->   _ => ...
print/printval.sml, line 158: Warning: match not exhaustive
        (obj,TYCON {kind=DATAtyc (ref <pat>),...}) => ...
[closing print/printval.sml]
[Compiling print/printdec.sig]
signature PRINTDEC
[closing print/printdec.sig]
[Compiling print/printdec.sml]
structure PrintDec
print/printdec.sml, line 98: Warning: match not exhaustive
        TYCON {arity=arity,kind=DATAtyc dcons,name=name,...} => ...
print/printdec.sml, line 98: Warning: match not exhaustive
        TYCON {kind=ABStyc,name=name,...} => ...
print/printdec.sml, line 98: Warning: match not exhaustive
        TYCON {kind=DEFtyc (TYFUN {arity=<pat>,body=<pat>}),name=name,...} => ...
print/printdec.sml, line 98: Warning: match not exhaustive
        RVB {var=VALvar {access=LVAR <pat>,name=name,vtype=ref <pat>},...} => ...
print/printdec.sml, line 98: Warning: match not exhaustive
        VALdec vbl => ...
        VALRECdec rvbl => ...
        TYPEdec tycl => ...
        DATATYPEdec {datatycs=datatycs,withtycs=withtycs} => ...
        ABSTYPEdec {abstycs=abstycs,body=body,withtycs=withtycs} => ...
        EXCEPTIONdec ebl => ...
        STRdec strbs => ...
        FCTdec fctbs => ...
        SIGdec _ => ...
        LOCALdec (decIn,decOut) => ...
        SEQdec decl => ...
        OPENdec strvl => ...
[closing print/printdec.sml]
[Compiling parse/first.sml]
structure FirstSets
[closing parse/first.sml]
[Compiling parse/parse.sig]
signature PARSE
[closing parse/parse.sig]
[Compiling parse/parse.sml]
parse/parse.sml, line 230: Warning: Capitalized variable in rule: Notfound_Table
parse/parse.sml, line 1040: Warning: Capitalized variable in rule: Notfound_Table
parse/parse.sml, line 1045: Warning: Capitalized variable in rule: Notfound_Table
structure Parse
parse/parse.sml, line 1527: Warning: binding not exhaustive
        STRstr {kind=SIGkind {stampcounts={s=<pat>,t=<pat>},...},...} = ...
parse/parse.sml, line 1527: Warning: binding not exhaustive
        (param as STRvar {access=LVAR <pat>,binding=pstr,name=pname},pmode) = ...
parse/parse.sml, line 1527: Warning: binding not exhaustive
        sgn as STRstr {kind=SIGkind {stampcounts=<pat>,...},...} = ...
parse/parse.sml, line 1527: Warning: binding not exhaustive
        (STRvar {binding=INDstr i,...},(p,_)) = ...
parse/parse.sml, line 1527: Warning: binding not exhaustive
        firstId :: rest = ...
parse/parse.sml, line 1527: Warning: binding not exhaustive
        ref (INDtyc x) = ...
parse/parse.sml, line 1527: Warning: binding not exhaustive
        STRvar {binding=INDstr k,...} = ...
parse/parse.sml, line 1527: Warning: match not exhaustive
        (id :: nil,STRstr {table=table,...}) => ...
        (id :: rest,STRstr {env={s=s,...},table=table,...}) => ...
parse/parse.sml, line 1527: Warning: binding not exhaustive
        VARexp (ref (v as VALvar {vtype=<pat>,...})) = ...
parse/parse.sml, line 1527: Warning: binding not exhaustive
        DATATYPEdec {datatycs=datatycs,withtycs=withtycs} = ...
parse/parse.sml, line 1527: Warning: match not exhaustive
        ((sym,const,typ) :: restdcl,rep :: restsign) => ...
        (nil,nil) => ...
parse/parse.sml, line 1527: Warning: binding not exhaustive
        TYPEdec x = ...
parse/parse.sml, line 1527: Warning: binding not exhaustive
        SOME id = ...
parse/parse.sml, line 1527: Warning: binding not exhaustive
        _ :: rest = ...
parse/parse.sml, line 1527: Warning: binding not exhaustive
        _ :: rest = ...
parse/parse.sml, line 1527: Warning: match not exhaustive
        TYCON {kind=DEFtyc (TYFUN {body=<pat>,...}),...} => ...
parse/parse.sml, line 1527: Warning: match not exhaustive
        (stamp' :: stamps,tyc :: tycs) => ...
        (nil,_) => ...
parse/parse.sml, line 1527: Warning: match not exhaustive
        (TYCON {arity=arity,home=home,kind=DATAtyc <pat>,name=name,stamp=stamp} :: rest,stamps,abstycs,dconss) => ...
        (nil,stamps,abstycs,dconss) => ...
parse/parse.sml, line 1527: Warning: binding not exhaustive
        STRvar {access=PATH ap,binding=binding,...} = ...
parse/parse.sml, line 1527: Warning: binding not exhaustive
        (firstId :: rest,lastId) = ...
parse/parse.sml, line 1527: Warning: binding not exhaustive
        STRvar {access=SLOT n,binding=binding,...} = ...
parse/parse.sml, line 1527: Warning: match not exhaustive
        (nil,str,ap) => ...
        (id :: rest,STRstr {env={s=s,...},table=table,...},ap) => ...
parse/parse.sml, line 1527: Warning: match not exhaustive
        (TYCON {name=a,...},TYCON {kind=DEFtyc (TYFUN <pat>),...}) => ...
[closing parse/parse.sml]
[Compiling basics/lambda.sml]
signature LAMBDA
structure Lambda
basics/lambda.sml, line 85: Warning: match not exhaustive
        (DATACON {rep=TAGGED i,...},e) => ...
        (DATACON {rep=TRANSPARENT,...},e) => ...
        (DATACON {rep=TRANSU,...},e) => ...
        (DATACON {rep=TRANSB,...},e) => ...
        (DATACON {rep=REF,...},e) => ...
        (DATACON {const=true,rep=VARIABLE (PATH <pat>),...},e) => ...
        (DATACON {rep=VARIABLE (PATH <pat>),...},e) => ...
        (DATACON {rep=CONSTANT i,...},e) => ...
basics/lambda.sml, line 85: Warning: match not exhaustive
        i :: nil => ...
        a :: r => ...
[closing basics/lambda.sml]
[Compiling codegen/opt.sml]
signature OPT
structure Opt
codegen/opt.sml, line 296: Warning: match not exhaustive
        (FN (v,a),b) => ...
codegen/opt.sml, line 296: Warning: match not exhaustive
        FN (v,e) => ...
codegen/opt.sml, line 296: Warning: match not exhaustive
        v :: nil => ...
        i :: p => ...
codegen/opt.sml, line 296: Warning: binding not exhaustive
        VAR w = ...
codegen/opt.sml, line 296: Warning: match not exhaustive
        v :: nil => ...
        i :: r => ...
[closing codegen/opt.sml]
[Compiling translate/mcprint.sml]
signature MCprint
structure MCprint
translate/mcprint.sml, line 172: Warning: match not exhaustive
        (c,l) :: nil => ...
        (c,l) :: more => ...
translate/mcprint.sml, line 172: Warning: match not exhaustive
        (v :: nil,l :: nil) => ...
        (v :: vs,l :: ls) => ...
        (nil,nil) => ...
[closing translate/mcprint.sml]
[Compiling translate/mcopt.sml]
signature MCopt
structure MCopt
translate/mcopt.sml, line 233: Warning: match not exhaustive
        APPpat (DATACON {name=r2,...},_) => ...
        CONpat _ => ...
translate/mcopt.sml, line 233: Warning: match not exhaustive
        CONpat (DATACON {name=r2,...}) => ...
        APPpat _ => ...
translate/mcopt.sml, line 233: Warning: match not exhaustive
        INTpat j => ...
translate/mcopt.sml, line 233: Warning: match not exhaustive
        REALpat s => ...
translate/mcopt.sml, line 233: Warning: match not exhaustive
        STRINGpat t => ...
[closing translate/mcopt.sml]
[Compiling translate/mc.sml]
signature MC
structure MC
translate/mc.sml, line 493: Warning: binding not exhaustive
        ((con,lexp) :: nil,_) = ...
translate/mc.sml, line 493: Warning: binding not exhaustive
        ((DATAcon dcon,list) :: nil,_) = ...
translate/mc.sml, line 493: Warning: match not exhaustive
        INTpat j => ...
translate/mc.sml, line 493: Warning: match not exhaustive
        REALpat s => ...
translate/mc.sml, line 493: Warning: match not exhaustive
        STRINGpat t => ...
[closing translate/mc.sml]
[Compiling translate/nonrec.sml]
structure Nonrec
[closing translate/nonrec.sml]
[Compiling translate/equal.sml]
signature EQUAL
structure Equal
translate/equal.sml, line 127: Warning: binding not exhaustive
        VALvar {access=PATH p,...} = ...
[closing translate/equal.sml]
[Compiling translate/unboxed.sml]
structure Unboxed
[closing translate/unboxed.sml]
[Compiling translate/translate.sml]
signature TRANSLATE
structure Translate
[closing translate/translate.sml]
[Compiling codegen/cgoptions.sml]
structure CGoptions
[closing codegen/cgoptions.sml]
[Compiling codegen/codenv.sml]
signature CODENV
functor Codenv
codegen/codenv.sml, line 191: Warning: match not exhaustive
        (freevars,(e as FN (<pat>,<pat>),env,_)) => ...
        (freevars,(FIX (vl as <pat>,el,b),env,offset)) => ...
codegen/codenv.sml, line 191: Warning: match not exhaustive
        (freevars,(e as FN (<pat>,<pat>),env,_)) => ...
        (freevars,(FIX (vl as <pat>,el,b),env,offset)) => ...
codegen/codenv.sml, line 191: Warning: match not exhaustive
        (nil,free,close) => ...
        (v :: vl,free,_ :: close) => ...
codegen/codenv.sml, line 191: Warning: match not exhaustive
        (nil,free,close) => ...
        (v :: vl,free,_ :: close) => ...
codegen/codenv.sml, line 191: Warning: match not exhaustive
        (nil,nil) => ...
        (v :: vl,acc :: accl) => ...
[closing codegen/codenv.sml]
[Compiling codegen/machine.sig]
signature MACHINE
signature MACHINECODE
signature ASSEMBLYCODE
[closing codegen/machine.sig]
[Compiling codegen/switcher.sml]
signature SWITCHER
functor Switcher
[closing codegen/switcher.sml]
[Compiling codegen/codegen.sml]
signature CODEGEN
functor Codegen
codegen/codegen.sml, line 260: Warning: binding not exhaustive
        frag :: rest = ...
codegen/codegen.sml, line 260: Warning: binding not exhaustive
        (_,(frag as (_,_,env)) :: nil,close) = ...
[closing codegen/codegen.sml]
[Compiling codegen/reopen.sml]
signature SYS
functor Reopen
codegen/reopen.sml, line 157: Warning: binding not exhaustive
        CLOSUREval x = ...
codegen/reopen.sml, line 157: Warning: match not exhaustive
        f' as FN (v,b) => ...
        f' as VAR w => ...
[closing codegen/reopen.sml]
[Compiling codegen/backpatch.sml]
signature BACKPATCH
functor Backpatch
[closing codegen/backpatch.sml]
[Compiling bignums/bitops.sml]
structure BitOps
[closing bignums/bitops.sml]
[Compiling bignums/bigint.sig]
signature BIGINT
[closing bignums/bigint.sig]
[Compiling bignums/bigint.sml]
structure Bigint
[closing bignums/bigint.sml]
[Compiling bignums/realconst.sml]
signature PRIMREAL
signature REALCONST
functor RealConst
bignums/realconst.sml, line 229: Warning: match not exhaustive
        0 => ...
        1 => ...
[closing bignums/realconst.sml]
[Compiling build/invoke.sml]
signature CODES
signature INVOKE
functor Invoke
build/invoke.sml, line 536: Warning: binding not exhaustive
        pervStrs as STRvar {access=PATH <pat>,...} :: _ = ...
build/invoke.sml, line 536: Warning: match not exhaustive
        STRB {strvar=STRvar {access=LVAR <pat>,name=name,...},...} => ...
build/invoke.sml, line 536: Warning: match not exhaustive
        STRB {strvar=STRvar {access=LVAR <pat>,name=name,...},...} => ...
build/invoke.sml, line 536: Warning: match not exhaustive
        FCTB {fctvar=FCTvar {access=LVAR <pat>,name=name,...},...} => ...
build/invoke.sml, line 536: Warning: match not exhaustive
        STRvar {binding=STRstr {table=table,...},...} => ...
build/invoke.sml, line 536: Warning: match not exhaustive
        STRB {strvar=STRvar {access=LVAR <pat>,name=name,...},...} => ...
build/invoke.sml, line 536: Warning: match not exhaustive
        STRB {strvar=STRvar {access=LVAR <pat>,name=name,...},...} => ...
build/invoke.sml, line 536: Warning: match not exhaustive
        FCTB {fctvar=FCTvar {access=LVAR <pat>,name=name,...},...} => ...
build/invoke.sml, line 536: Warning: match not exhaustive
        SIGdec _ => ...
        STRdec sbs => ...
        ABSdec sbs => ...
        FCTdec fbs => ...
build/invoke.sml, line 536: Warning: match not exhaustive
        sb as STRB {strvar=STRvar {access=<pat>,name=<pat>,...},...} => ...
build/invoke.sml, line 536: Warning: match not exhaustive
        sb as STRB {strvar=STRvar {access=<pat>,name=<pat>,...},...} => ...
build/invoke.sml, line 536: Warning: match not exhaustive
        fb as FCTB {fctvar=FCTvar {access=<pat>,name=<pat>,...},...} => ...
build/invoke.sml, line 536: Warning: match not exhaustive
        SIGdec _ => ...
        STRdec sbs => ...
        ABSdec sbs => ...
        FCTdec fbs => ...
[closing build/invoke.sml]
[Compiling vax/vaxcoder.sig]
signature VAXCODER
[closing vax/vaxcoder.sig]
[Compiling vax/vaxpeep.sml]
functor VaxPeephole
[closing vax/vaxpeep.sml]
[Compiling vax/vaxmcode.sml]
signature BASICVAX
structure BasicVax
vax/vaxmcode.sml, line 105: Warning: match not exhaustive
        (MODE,2,s,d) => ...
        (MODE,3,s,d) => ...
        (MODE,5,s,d) => ...
        (WHICH (ref i,_,_),_,_,_) => ...
        (COND _,1,s,d) => ...
        (COND _,4,s,d) => ...
        (COND _,7,s,d) => ...
        (JBR,2,s,d) => ...
        (JBR,3,s,d) => ...
        (JBR,6,s,d) => ...
structure VaxMCode
vax/vaxmcode.sml, line 306: Warning: match not exhaustive
        address lab => ...
        displace (k,reg 15) => ...
vax/vaxmcode.sml, line 306: Warning: match not exhaustive
        displace (i,reg 15) => ...
vax/vaxmcode.sml, line 306: Warning: match not exhaustive
        displace (i,reg 15) => ...
vax/vaxmcode.sml, line 306: Warning: match not exhaustive
        (immed i,arg2,arg3) => ...
vax/vaxmcode.sml, line 306: Warning: match not exhaustive
        (immed 0,arg,address lab) => ...
        (arg1,arg2,address lab) => ...
vax/vaxmcode.sml, line 306: Warning: match not exhaustive
        (immed 0,arg,address lab) => ...
        (arg1,arg2,address lab) => ...
vax/vaxmcode.sml, line 306: Warning: match not exhaustive
        address lab => ...
vax/vaxmcode.sml, line 306: Warning: match not exhaustive
        1 => ...
        2 => ...
        4 => ...
vax/vaxmcode.sml, line 306: Warning: match not exhaustive
        1 => ...
        2 => ...
        4 => ...
vax/vaxmcode.sml, line 306: Warning: match not exhaustive
        direct (reg r) => ...
        autoinc (reg r) => ...
        autodec (reg r) => ...
        immed i => ...
        displace (i,reg r) => ...
        deferred (i,reg r) => ...
        index (ea,reg r) => ...
[closing vax/vaxmcode.sml]
[Compiling vax/vaxascode.sml]
structure VaxAssem
structure VaxAsCode
vax/vaxascode.sml, line 154: Warning: match not exhaustive
        (immed i,arg2,arg3) => ...
[closing vax/vaxascode.sml]
[Compiling vax/vaxprim.sml]
signature MACHINEPRIM
functor VaxPrim
vax/vaxprim.sml, line 274: Warning: binding contains no variables
        () = ...
vax/vaxprim.sml, line 274: Warning: binding not exhaustive
        VARbind (VALvar {access=INLINE i,...}) = ...
vax/vaxprim.sml, line 274: Warning: match not exhaustive
        ((s,2),f) => ...
vax/vaxprim.sml, line 274: Warning: binding not exhaustive
        VARbind (VALvar {access=INLINE i,...}) = ...
[closing vax/vaxprim.sml]
[Compiling vax/vaxgen.sml]
functor VaxGen
vax/vaxgen.sml, line 180: Warning: match not exhaustive
        i :: nil => ...
        i :: 0 :: (more as _ :: _) => ...
        i :: (more as _ :: _) => ...
vax/vaxgen.sml, line 180: Warning: match not exhaustive
        0 :: nil => ...
        j :: nil => ...
        j :: 0 :: (more as _ :: _) => ...
        j :: (more as _ :: _) => ...
[closing vax/vaxgen.sml]
[Compiling vax/vaxglue.sml]
structure VaxCodes
structure VaxGlue
[closing vax/vaxglue.sml]
[Compiling m68/m68coder.sig]
signature M68CODER
[closing m68/m68coder.sig]
[Compiling m68/m68peep.sml]
functor M68Peephole
[closing m68/m68peep.sml]
[Compiling m68/m68mcode.sml]
signature BASICM68
structure BasicM68
m68/m68mcode.sml, line 102: Warning: match not exhaustive
        (Jcc opcode,2,s,d) => ...
        (Jcc opcode,4,s,d) => ...
        (Jcc opcode,6,s,d) => ...
        (LEA opcode,4,s,d) => ...
        (LEA opcode,8,s,d) => ...
        (FJcc cond,4,s,d) => ...
        (FJcc cond,6,s,d) => ...
structure M68MCode
m68/m68mcode.sml, line 488: Warning: match not exhaustive
        (src,dest as Direct (FloatReg f)) => ...
        (src as Direct (FloatReg f),dest) => ...
m68/m68mcode.sml, line 488: Warning: match not exhaustive
        Address lab => ...
m68/m68mcode.sml, line 488: Warning: match not exhaustive
        Address lab => ...
m68/m68mcode.sml, line 488: Warning: match not exhaustive
        Address lab => ...
m68/m68mcode.sml, line 488: Warning: match not exhaustive
        Address lab => ...
m68/m68mcode.sml, line 488: Warning: match not exhaustive
        Address lab => ...
m68/m68mcode.sml, line 488: Warning: match not exhaustive
        Address lab => ...
m68/m68mcode.sml, line 488: Warning: match not exhaustive
        Address lab => ...
        dest as Displace (AddrReg _,_) => ...
m68/m68mcode.sml, line 488: Warning: match not exhaustive
        Address lab => ...
        arg as Displace (AddrReg _,_) => ...
m68/m68mcode.sml, line 488: Warning: match not exhaustive
        Address lab => ...
m68/m68mcode.sml, line 488: Warning: match not exhaustive
        Address lab => ...
m68/m68mcode.sml, line 488: Warning: match not exhaustive
        Address lab => ...
m68/m68mcode.sml, line 488: Warning: match not exhaustive
        Address lab => ...
m68/m68mcode.sml, line 488: Warning: match not exhaustive
        Address lab => ...
m68/m68mcode.sml, line 488: Warning: match not exhaustive
        Address lab => ...
m68/m68mcode.sml, line 488: Warning: match not exhaustive
        (Direct _,_) => ...
        (PreDec _,_) => ...
        (PostInc _,_) => ...
        (Immed _,_) => ...
        (Address lab,Direct (AddrReg a)) => ...
        (src,Direct (AddrReg a)) => ...
m68/m68mcode.sml, line 488: Warning: match not exhaustive
        (_,Direct (AddrReg _)) => ...
        (_,Immed _) => ...
        (Direct (DataReg d),dest) => ...
        (Immed i,dest) => ...
m68/m68mcode.sml, line 488: Warning: match not exhaustive
        (_,Immed _) => ...
        (src,Direct (DataReg d)) => ...
        (src,Direct (AddrReg a)) => ...
        (Immed i,dest) => ...
        (PostInc (AddrReg y),PostInc (AddrReg x)) => ...
m68/m68mcode.sml, line 488: Warning: match not exhaustive
        (src,Direct (DataReg d)) => ...
m68/m68mcode.sml, line 488: Warning: match not exhaustive
        (src,Direct (DataReg d)) => ...
m68/m68mcode.sml, line 488: Warning: match not exhaustive
        (_,Immed _) => ...
        (src as Immed i,dest as Direct (AddrReg a)) => ...
        (src,Direct (AddrReg a)) => ...
        (src as Immed i,dest) => ...
        (src,Direct (DataReg d)) => ...
        (Direct (DataReg d),dest) => ...
m68/m68mcode.sml, line 488: Warning: match not exhaustive
        (_,Immed _) => ...
        (src as Immed i,dest as Direct (AddrReg a)) => ...
        (src,Direct (AddrReg a)) => ...
        (src as Immed i,dest) => ...
        (src,Direct (DataReg d)) => ...
        (Direct (DataReg d),dest) => ...
m68/m68mcode.sml, line 488: Warning: match not exhaustive
        (Direct (AddrReg a),Direct (AddrReg b)) => ...
        (Direct (DataReg a),Direct (DataReg b)) => ...
        (Direct (AddrReg b),Direct (DataReg a)) => ...
        (Direct (DataReg a),Direct (AddrReg b)) => ...
m68/m68mcode.sml, line 488: Warning: match not exhaustive
        (opcode,Direct (FloatReg a),Direct (FloatReg b)) => ...
        (opcode,src,Direct (FloatReg f)) => ...
        (opcode,Direct (FloatReg f),dest) => ...
m68/m68mcode.sml, line 488: Warning: match not exhaustive
        Immed i => ...
        Abs i => ...
        Direct _ => ...
        Displace (_,0) => ...
        PostInc _ => ...
        PreDec _ => ...
        Displace (_,i) => ...
        Index (_,disp,DataReg d,Word) => ...
        Index (_,disp,DataReg d,Long) => ...
        Index (_,disp,AddrReg d,Word) => ...
        Index (_,disp,AddrReg d,Long) => ...
        Address _ => ...
m68/m68mcode.sml, line 488: Warning: match not exhaustive
        Direct (DataReg _) => ...
        Direct (AddrReg _) => ...
        Displace (AddrReg _,0) => ...
        PostInc (AddrReg _) => ...
        PreDec (AddrReg _) => ...
        Displace (AddrReg _,_) => ...
        Index (AddrReg _,_,_,_) => ...
        Abs _ => ...
        Immed _ => ...
        Address _ => ...
m68/m68mcode.sml, line 488: Warning: match not exhaustive
        Direct (DataReg d) => ...
        Direct (AddrReg a) => ...
        PostInc (AddrReg a) => ...
        PreDec (AddrReg a) => ...
        Displace (AddrReg a,_) => ...
        Index (AddrReg a,_,_,_) => ...
        Abs i => ...
        Immed _ => ...
        Address _ => ...
[closing m68/m68mcode.sml]
[Compiling m68/m68ascode.sml]
structure M68Assem
structure M68AsCode
m68/m68ascode.sml, line 313: Warning: match not exhaustive
        arg as (src,dest as Direct (FloatReg <pat>)) => ...
        arg as (src as Direct (FloatReg <pat>),dest) => ...
m68/m68ascode.sml, line 313: Warning: match not exhaustive
        arg as Address lab => ...
m68/m68ascode.sml, line 313: Warning: match not exhaustive
        arg as Address lab => ...
m68/m68ascode.sml, line 313: Warning: match not exhaustive
        arg as Address lab => ...
m68/m68ascode.sml, line 313: Warning: match not exhaustive
        arg as Address lab => ...
m68/m68ascode.sml, line 313: Warning: match not exhaustive
        arg as Address lab => ...
m68/m68ascode.sml, line 313: Warning: match not exhaustive
        arg as Address lab => ...
m68/m68ascode.sml, line 313: Warning: match not exhaustive
        arg as Address lab => ...
        arg as Displace (AddrReg _,_) => ...
m68/m68ascode.sml, line 313: Warning: match not exhaustive
        arg as Address lab => ...
        arg as Displace (AddrReg a,i) => ...
m68/m68ascode.sml, line 313: Warning: match not exhaustive
        arg as Address lab => ...
m68/m68ascode.sml, line 313: Warning: match not exhaustive
        arg as Address lab => ...
m68/m68ascode.sml, line 313: Warning: match not exhaustive
        arg as Address lab => ...
m68/m68ascode.sml, line 313: Warning: match not exhaustive
        arg as Address lab => ...
m68/m68ascode.sml, line 313: Warning: match not exhaustive
        arg as Address lab => ...
m68/m68ascode.sml, line 313: Warning: match not exhaustive
        arg as Address lab => ...
m68/m68ascode.sml, line 313: Warning: match not exhaustive
        (Direct _,_) => ...
        (PreDec _,_) => ...
        (PostInc _,_) => ...
        (Immed _,_) => ...
        (src as Address _,dest as Direct (AddrReg _)) => ...
        (src,dest as Direct (AddrReg a)) => ...
m68/m68ascode.sml, line 313: Warning: match not exhaustive
        (_,Direct (AddrReg _)) => ...
        (_,Immed _) => ...
        (src as Direct (DataReg d),dest) => ...
        (src as Immed i,dest) => ...
m68/m68ascode.sml, line 313: Warning: match not exhaustive
        (_,Immed _) => ...
        (src,dest as Direct (DataReg d)) => ...
        (src,dest as Direct (AddrReg a)) => ...
        (src as Immed i,dest) => ...
        (src as PostInc (AddrReg y),dest as PostInc (AddrReg x)) => ...
m68/m68ascode.sml, line 313: Warning: match not exhaustive
        (_,Immed _) => ...
        (src as Immed i,dest as Direct (AddrReg a)) => ...
        (src,dest as Direct (AddrReg a)) => ...
        (src as Immed i,dest) => ...
        (src,dest as Direct (DataReg d)) => ...
        (src as Direct (DataReg d),dest) => ...
m68/m68ascode.sml, line 313: Warning: match not exhaustive
        (_,Immed _) => ...
        (src as Immed i,dest as Direct (AddrReg a)) => ...
        (src,dest as Direct (AddrReg a)) => ...
        (src as Immed i,dest) => ...
        (src,dest as Direct (DataReg d)) => ...
        (src as Direct (DataReg d),dest) => ...
m68/m68ascode.sml, line 313: Warning: match not exhaustive
        arg as (Direct (AddrReg a),Direct (AddrReg b)) => ...
        arg as (Direct (DataReg a),Direct (DataReg b)) => ...
        arg as (Direct (AddrReg b),Direct (DataReg a)) => ...
        arg as (Direct (DataReg a),Direct (AddrReg b)) => ...
m68/m68ascode.sml, line 313: Warning: match not exhaustive
        Immed i => ...
        Abs i => ...
        Direct r => ...
        Displace (ra,0) => ...
        PostInc ra => ...
        PreDec ra => ...
        Displace (r,i) => ...
        Index (ra,disp,r,Word) => ...
        Index (ra,disp,r,Long) => ...
        Address lab => ...
m68/m68ascode.sml, line 313: Warning: match not exhaustive
        DataReg 0 => ...
        DataReg 1 => ...
        DataReg 2 => ...
        DataReg 3 => ...
        DataReg 4 => ...
        DataReg 5 => ...
        DataReg 6 => ...
        DataReg 7 => ...
        AddrReg 0 => ...
        AddrReg 1 => ...
        AddrReg 2 => ...
        AddrReg 3 => ...
        AddrReg 4 => ...
        AddrReg 5 => ...
        AddrReg 6 => ...
        AddrReg 7 => ...
        FloatReg 0 => ...
        FloatReg 1 => ...
        FloatReg 2 => ...
        FloatReg 3 => ...
        FloatReg 4 => ...
        FloatReg 5 => ...
        FloatReg 6 => ...
        FloatReg 7 => ...
[closing m68/m68ascode.sml]
[Compiling m68/m68prim.sml]
signature MACHINEPRIM
structure M68options
functor M68prim
m68/m68prim.sml, line 301: Warning: binding contains no variables
        () = ...
m68/m68prim.sml, line 301: Warning: binding not exhaustive
        VARbind (VALvar {access=INLINE i,...}) = ...
m68/m68prim.sml, line 301: Warning: match not exhaustive
        ((s,2),f) => ...
m68/m68prim.sml, line 301: Warning: binding not exhaustive
        VARbind (VALvar {access=INLINE i,...}) = ...
[closing m68/m68prim.sml]
[Compiling m68/m68gen.sml]
functor M68Gen
m68/m68gen.sml, line 182: Warning: match not exhaustive
        i :: nil => ...
        i :: more => ...
m68/m68gen.sml, line 182: Warning: match not exhaustive
        0 :: nil => ...
        j :: nil => ...
        j :: more => ...
[closing m68/m68gen.sml]
[Compiling m68/m68glue.sml]
structure M68Codes
structure M68Glue
[closing m68/m68glue.sml]
[Compiling build/compile.sml]
functor Compile
build/compile.sml, line 278: Warning: match not exhaustive
        "0" => ...
        "1" => ...
        "2" => ...
        "3" => ...
        "4" => ...
        "5" => ...
        "6" => ...
        "7" => ...
        "8" => ...
        "9" => ...
build/compile.sml, line 278: Warning: binding not exhaustive
        STRvar {binding=STRstr {table=table,...},...} = ...
[closing build/compile.sml]
[Compiling build/glue.sml]
functor Interact
structure CompVax
structure CompM68
structure IntVax
structure IntM68
[closing build/glue.sml]
[globalhandle := true]
[dumpCore := false]
[Exporting to upto.all]
hello there
[summary()]
16296 lines
parse, 268.566677s
translate, 14.966663s
codeopt, 15.866666s
codegen, 158.766668s
execution, 0.0s
total 458.166674s
