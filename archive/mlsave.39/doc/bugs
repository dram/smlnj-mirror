Known bugs, SML of NJ Version 0.18, 7 March 1988

Key: L = local
     E = Edinburgh
     SB = Stony Brook
     P = U Penn

--------------------------------------------------------------------------------
2. (L.3):  Mispelled nonnullary constructors in patterns [parser]
Problem: 
  Mispelling a constructor with arguments in a pattern leads to misleading
  error messages.
Version: 0.18
Code:  (in typing/typecheck.sml)
      ...
	       app genType rvbs
	   end
       | EXCEPTIONdec(ebs) =>
	   let fun checkWeak(VARty(ref(UNBOUND id))) =
				       ^ -- should have been UBOUND
		     if tyvarWeakness id > abs
		     then condemn "type variable in exception type too strong"
      ...
Comment:
  probably requires rewrite of pattern parsing [dbm]
Status: open

--------------------------------------------------------------------------------
4. (L.5):  duplicate specifications not checked
Problem:
  No checking for duplicated specifications in signatures.
Version: 0.18
Comment:
  This should be done when building the signature symbol table.
Status: open

--------------------------------------------------------------------------------
7. (L.8):  constructor representation
Problem:
  There is a bug involving constructor representation.  The compiler
  examines the structure of a datatype and tries to determine an efficient
  runtime representation for it.  For example, for the list datatype, nil
  can be represented as an integer, and :: can just be a pointer to its
  tuple argument (integers and tuples are distinct).  This fails in our system
  at the structure level.  For example:
Version: 0.18
Code:
    signature S = sig
	type 'a t
	datatype 'a list = nil | :: of 'a t
    end
    structure A : S = struct
	datatype 'a list = nil | :: of 'a t
	withtype 'a t = 'a * 'a list
    end
Comment:
  Here the compiler can deduce the efficient representation for the
  (local) list datatype in structure A; but this cannot be deduced in
  the signature S (an object of type 'a t might not be a pointer).
Status: open

--------------------------------------------------------------------------------
8. (L.9):  interactive error recovery
Problem:
  In the interactive mode, parser error recovery should be suppressed
  (but isn't); the parser may continue to look for input after an error,
  when the user would expect to be back at top level.
Version: 0.18
Status: open

--------------------------------------------------------------------------------
10. (L.11):  exhaustiveness messages at top-level
Problem: Top level bindings should not report on exhaustiveness, but they do.
Version: 0.18
Status: open

--------------------------------------------------------------------------------
11. (L.12):  poor error messages [parser]
Problem: Poor error message (parens are needed around the hd::tl pattern):
Version: 0.18
Code:
   -  fun f hd::tl = 4;
Messages:
    Error: expected EQUAL, found ID (::)
    Error: expected nonfix-identifier, found ID ::
    Error: unbound variable bogus
    Error: type error: operator and operand don't agree
    operator : ((wrong*wrong list) -> wrong list)
    operand : (wrong*('aA list -> 'aA list))
    expression:
      bogus :: tl
    - 
Comment:
    The "unbound variable bogus" in particular is confusing.
Status: open

--------------------------------------------------------------------------------
12. (L.14):  loss of information in value printing
Problem:
  When printing values formed using constructors created by functor application,
  the argument type of the constructor can sometimes be lost, resulting in
  inability to print the value accurately.
Version: 0.18
Code:
	- functor F(type t) =
	= struct
	=   datatype r = C of t end
	= end;

	- structure S = F(type t = int);

	- S.C 3;
  [1]   val it = C - : S.r

  But
  	- signature SS = sig type t datatype r = C of t end;

        - structure S = struct type t = int  datatype r = C of t end;

	- S.C;
	val it = fn : ?.t -> S.r

	- S.C 3;
	val it = C 3 : S.r

  and
	- structure S': SS = struct type t = int  datatype r = C of t end;
	- S'.C;
	val it = fn : ?.t -> S'.r
	- S'.C 3;
	val it = C 3 : S'.r

Comments:
  It does not seem possible to recover the context from the structure S, because
  there is no simple way to get back from the type S.r or the DATACON C to the 
  structure environment.  This may be a reason for having type constructors
  contain a pointer to their home structure rather than just the symbolic
  path.  Another alternative would be to follow the path in S.r to find the
  structure S so that we can use it as context for the type of C.
Status: open (no longer prints ?.t in last two examples) 

--------------------------------------------------------------------------------
13. (L.15):  printing of types from abstraction structure
Problem:
  Printing of types from an abstraction is not quite right.
Code: (test/sigs/test7)
    signature FOO = 
    sig
       type T1 and T2
       val x1: T1 and x2: T2
       sharing type T1 = T2
    end

    abstraction Foo: FOO =
    struct
       datatype T1 = CON
       type T2 = T1
       val x1 = CON and x2 = CON
    end

    [Foo.x1,Foo.x2];
Messages:
    [-,-] : ?.T1   (* should be Foo.T1 *)
Status: open

--------------------------------------------------------------------------------
15. (E.12):  Error message
Problem: Unfortunate error message (I left out `type'):
Version: ?
Code: 
	- signature STWO = sig structure X:SIG and Y:SIG sharing X.t=Y.t end;
Messages:
	Error: bad path is sharing specification
Comments:
   (It's also misspelled.)
Status:  No change (except spelling is corrected).

--------------------------------------------------------------------------------
17. (E.25):  Inaccurate line numbers
Problem:
	Misleading line numbers for some things (eg. type errors in multi-line
	datatype declarations). Could the system print something like
	"Line 33ff", or a line range a la LaTeX, for these?
Version:
Code:
Messages:
Comments:
Status: open

--------------------------------------------------------------------------------
18. (E.35a):  Bad error messages for illegal record expression [parser]
Version: 0.19
Problem:
	inaccurate diagnostic for a bad record expression
Code:
	- {3};
Messages:
	Error: expected EQUAL after label, found INT
Comment:
Status: fixed in 0.31, except for spacing of new error message

--------------------------------------------------------------------------------
19. (E.38):  Exception declaration with ":"
Problem: This gives a type error rather than a syntax error: odd:
Version: ?
Code:
	- signature FOO = sig exception Foo of string end;

	- structure Foo: FOO = struct exception Foo: string end;
		                                       =-> ^ <-=
Messages:
	Error: Type in structure doesn't match signature
	name = Foo
	spec = (string -> exn)
	actual = exn
Comments:
  Without signature constraint ":FOO" in declaration of Foo you get a syntax
  error: "expected END, found COLON".  With the signature, you get the above
  type error but no complaint about the ":".
Status: open

--------------------------------------------------------------------------------
20. (E.47):  "print" is overloaded rather than polymorphic
Problem: print should be implemented as a pseudo-polymorphic function like =
Version: 0.19
Code:
	- datatype Foo = FOO1 | FOO2;
	- print FOO1;
Messages:
	Error: type error: no match for overloaded variable:
	print
Comments:
	according to the original SML report, both "print" and "makestring"
	should be polymorphic identity functions. In our [Edinburgh]
	compiler, "print" is correctly polymorphic. "makestring" is
	(incorrectly) overloaded, disallowing "makestring FOO1". Needless
	to say, I want to be able to do "makestring" on datatypes.
Status: open

--------------------------------------------------------------------------------
21. (E.48):  Bad error recovery in the typechecker:
Problem:
Version: 0.15a
Code:
	- signature SIG = sig
	     exception Foo of int
	     val A: int
	     val B: int
	     val C: int
	  end;

	- structure S: SIG =
	     struct
		exception Foo: int
			     ^
		val A = 1
		val B = 2
		val C = 3
	     end
Messages:
	Error: Type in structure doesn't match signature
	name = Foo
	spec = (int -> exn)
	actual = exn
	Error: unmatched val spec: A
	Error: unmatched val spec: B
	Error: unmatched val spec: C
	^ there can be a lot of these!
Comments:
	Sometimes the exception error doesn't appear, just giving the unmatched
	spec errors, rather misleadingly.
Status: open

--------------------------------------------------------------------------------
24. (E.56): incomplete write
Problem: [nick]
    I'm trying to put in some bullet-proof error recovery into my
    subprocess software, so that "^C" at ML top-level doesn't
    confuse the daemon. What happens if an "output" operation is
    active when ^C is hit - does it do a partial write? I seem to be
    getting some buffer corruption somewhere, as a partial write is
    immediately followed by another complete write. It might make
    my life easier if "output" could be guaranteed atomic under "^C"
    (i.e. any single output operation will complete before Interrupt
    gets raised).
       Just a thought. I'll perhaps put timers into the daemon and ML code
    so that they flush and restart properly - this may solve the problem.
Version:  ?
Comments:
   [Andrew] there should be a way to enable and disable interrupt.
Status: open

--------------------------------------------------------------------------------
26. (E.58):  export ML within a use
Problem:
	Awkward behaviour when exportML is called while a file is being
	"use"'d - the saved state falls over with Io_failure. Shouldn't
	restarting clear the use stack?
Version:
Code:
Messages:
Comments:
Status:
  Modified in version 18 so the image doesn't die.  It still raises
  Io_failure, though. (tyj)

--------------------------------------------------------------------------------
29. (E.62):  use_string in structure definition
Submitter: Nick
Date: 3/24/88
Version: 0.18
Problem: use_string can cause uncaught Intmap exception
Code:
    - structure Foo =
       struct
	  val x = use_stream(open_string "val _ = Foo.x;")
       end;
Messages: 
    [opening <instream>]
    [closing <instream>]
    uncaught exception Runbind
Comments: This code shouldn't work, but the Intmap exception should be caught.
Status: "Doctor, Doctor, it hurts when I do this."
        "Don't do it, then!"

--------------------------------------------------------------------------------
35. (L.23): Compiler bug: abstractType
Submitter: Andrew
Date: 4/6/88
Version: 0.18
Problem: type error in functor definition causes Compiler bug error
Code:
    signature FORMULA =
     sig
	 type formula
	 val NUM : formula
     end

    functor Parse(F : FORMULA) = 
    struct

       fun parse() : F.formula = (0, F.NUM)
    (*  val parse : unit -> F.formula = (fn () => (0, F.NUM))  -or-
    (*  val parse : F.formula = (0, F.NUM) -- don't cause abstractType error *)

    end
Messages:
    Error: expression and constraint don't agree (tycon mismatch)
      expression: int * ?.formula
      constraint: ?.formula
      in expression:
	(0,NUM)
    Error: Compiler bug: abstractType
Comments:
Status: open.

--------------------------------------------------------------------------------
36. (L.26): overloading resolution and order of recursive definitions
Submitter: Dave
Date: 5/2/88
Version: 0.18
Problem: 
    overloading resolution can depend on the order in which mutually
    recursive definitions occur
Code:
    fun f x = length x
    and g() = f "abc"
      (* length is not resolved *)
    fun g() = f "abc"
    and f x = length x
      (* length is resolved *)    
Messages:
Comments:
    Maybe this will remain a "feature".
Status: open

--------------------------------------------------------------------------------
40. (L.28): Exception aliasing (match compiler)
Submitter: Dave
Date: 5/12/88
Version: 0.19
Problem:
   Match compiler doesn't cope with exception aliasing (through functor
   parameters, for instance).
   Exceptions in different structures with the same name, or identical
   exceptions with different names can cause problems for the match
   compiler.  Currently, in building the decision tree, the match
   compiler examines constructor names to descriminate among them.
   In a match like
	  A.foo =>
	| B.foo =>
   the second rule will be found redundant, even if the exceptions are
   different.  And in
	  exception foo
	  exception bar = foo

	  bar =>
	| foo =>
   the second rule will not be recognized as redundant.
   The situation is even worse for exceptions which are functor parameters.
   For example:
	structure A = struct exception foo end
	structure B = struct exception foo end
	functor F(exception foo) =
	  struct
	    fun f A.foo = 1
	      | f foo = 2
	      | f B.foo = 3
	  end
   Now in F(A.foo) the second case is redundant; in F(B.foo) the third case
   is redundant; and in F(exception foo) no case is redundant.  Redundancy
   can't be computed statically while compiling F; and the match compiler
   can't build a fancy decision tree without watching for functor parameters.
   Here, the only correct tree would be a case by case check; things get more
   complicated when tuples are involved.
   
   One solution would be to assign stamps statically to exception declarations.
   Exception specs would get a different class of stamp than exception
   declarations.  This would allow us to correctly produce efficient matches
   in most cases, and detect cases where the runtime-dependent check is
   necessary.
Code:
Messages:
Comments: a fairly nasty one!
Status: open

--------------------------------------------------------------------------------
46. equality type checking and flexrecords
Submitter: Dave
Date: 6/3/88
Version: 0.20
Problem:
    when flexrecords are used a nonequality type may be accepted in a context
    where an equality record type is required
Code:
    fun f(r as {a,...},true) = (r = r)  (* checks only that a admits equality *)
      | f({b,...},false) = b 3 (* oops, the b field is a function! *)
Messages:
    val f = fn : {a:''a,b:int -> bool} * bool -> bool
    (* argument type is not an equality type *)
Comments:
    A fix probably requires a change in the way flexrecords are represented.
Status: open

--------------------------------------------------------------------------------
48. printing of identity withtype declarations
Submitter: Dave
Date: 6/9/88
Version: 0.20
Problem:
  A simple identity declaration in the withtype clause of a datatype declaration
  will not be printed properly.
Code:
  datatype foo = A
  withtype t = int;
Messages:
  datatype  foo
  con A : foo
  type  t = t
Comments:
  This happens because the backpatching of the type constructor puts the new
  name in the defining type as well as in the defined type binding.
Status: open

---------------------------------------------------------------------------
57. open_out causes SystemCall exception
Submitter: dbm
Date: 11/10/88
Version: 0.23
System: --
Problem: opening nonwriteable file causes uncaught exception SystemCall
Code: 
    LexGen.lexGen "ml.lex";
    uncaught exception SystemCall
    - system "ls -l";
    total 38
    -r--r--r--  2 dbm           993 Nov  9 12:03 ascii.sml
    -r--r--r--  2 dbm          3207 Nov  9 12:03 hookup.sml
    -r--r--r--  2 dbm          2813 Nov  9 12:03 ml.lex
    -r--r--r--  2 dbm         23900 Nov  9 12:03 ml.lex.sml
    -r--r--r--  2 dbm          2698 Nov  9 12:03 symbols.sml
    -r--r--r--  2 dbm          2599 Nov  9 12:03 timelex.sml
    val it = () : unit
Messages:
Comments:  Attempting to open an unreadable file for input raises Io_failure,
	   but attempting to open an unwriteable file for output raises
	   SystemCall.
Status: open

---------------------------------------------------------------------------
58. incorrect string value in Io_failure exception
Submitter: dbm
Date: 11/10/88
Version: 0.23
System: vax/v9
Problem: string returned by Io_failure invoked by open_in is bogus
Code:
  [assume "all" is the name of an unreadable file]
    (open_in "all"; "abc") handle Io_failure s => s;
Messages:
    val it = "open_in: open" : string  
Comments: should be "open_in: all"
Status: open

---------------------------------------------------------------------------
63. curried, clausal def of infix function
Submitter: Paulson
Version: Version 0.20, 13 June 1988
System: Sun3/SunOS
Problem: parsing of infixes 
Code: (minimal code fragment that causes bug)
    - infix orelf;
    - fun (f orelf g) x = 0;
    Error: expected EQUAL, found RPAREN
    Error: atomic expression expected
    Error: declaration or expression expected, found RPAREN

    - fun f orelf g = fn x => 0;
    val orelf = fn : 'a * 'b -> 'c -> int
Comments: 
  This use of an infix in a pattern seems legal and is accepted by Poly/ML.
Status: open

---------------------------------------------------------------------------
64. unclosed comment is not reported
Submitter: Duba
Date: 12/2/88
Version: 0.22 and later
System: Any
Problem: unclosed comment is not reported
Code: (* ...
Status: open

---------------------------------------------------------------------------
68. (E.72) spurious error message -- doesn't match sig spec
Submitter: Nick
Date: 11/24/88
Version: 0.24
System: Sun 3
Code:
	- structure S: sig val x: int end = struct val x = hd "s" end;
	Error: operator and operand don't agree (tycon mismatch)
	  operator domain: 'S list
	  operand:         string
	  in expression:
	    hd "s"
	Error: value type in structure doesn't match signature spec
	  name: x
	  spec:   int
	  actual: error
Status: open

---------------------------------------------------------------------------
69. (E.73) printing of exn spec in inferred signature
Submitter: Nick
Date: 11/24/88
Version: 0.24
System: Sun 3
Code:
	- structure Blah = struct exception BLAH end;
	structure Blah :
	  sig
	    exception BLAH of exn  (* "of exn" should not appear *)
	  end
Status: open

---------------------------------------------------------------------------
70. (E.74) constructor shouldn't appear in printed structure signature
Submitter: Nick
Date: 11/24/88
Version: 0.24
System: Sun 3
Code:
	signature SIG =
	    sig
		type t
	    end

	structure S:SIG =
	    struct
		datatype t = foo of int
		val x = 3
	    end
Messages:
	structure S :
	    sig
		datatype t
		  con foo : int -> t  (* shouldn't be printed *)
	    end
Comment: constructor foo is not accessible as component of S
    Also, from Dave Berry (2/2/89):
    NJ ML prints the constructors of a datatype when that datatype is
    matched against a "type" in a signature, even if the signature
    doesn't include the constructors.

    This seems a trivial point (except that it's confusing for the novices on
    the course we teach).  However, with some complicated programs the compiler
    bombs out, raising the subscript exception.  You are left in the ML system,
    but it won't compile your code.

    I don't have a small example of this.  It first hit me preparing
    examples for the aforementioned course, and it's just hit me again.
Status: open

---------------------------------------------------------------------------
71. (E.75) Failure to restore enviroment after exception in "use"
Submitter: Nick
Date: 11/24/88
Version: 0.24
System: Sun 3
Code:
      For a file "y.sml" containing "val y = 4";

	- val x = (use "y.sml";
		   let exception X in raise X end
		  );
	[opening y.sml]
	val y = 4 : int
	[closing y.sml]
	uncaught exception X
	- (* so far so good... *)
	- x;
	uncaught exception Runbind
Comment: needs to be a protect around use to trap exceptions and restore env
Status: open

---------------------------------------------------------------------------
72. equality types with abstype declarations
Submitter: kevin
Date: 11/30/88
Version: 0.24?
System: Sun 3
Code:
    (* The following definition is accepted by the compiler, resulting in
       the declaration test: ''a foo -> bool *)

    abstype 'a foo = Foo of 'a list
    with fun test(Foo x) = (x = []) end;

    (* The next declaration fails with the error
      Error: operator and operand don't agree (equality type required)
      operator domain: ''S * ''S
      operand:         'T foo * 'U foo
      in expression:
	x = Foo nil  *)

    abstype 'a foo = Foo of 'a list
    with fun test(x as Foo _) = (x = Foo []) end;

    (* I'm not sure why one should be allowed and not the other - the old
       Edinburgh compiler accepted both.  *)
Status: open

---------------------------------------------------------------------------
73. strange function definition
Submitter: Trevor
Date: 12/10/88
Version: 0.24?
System: vax
Problem:
Code:
    - fun add-a x = x+1;
    val a = fn : int -> int
    - a 3;
    val it = 4 : int
Comments:
    The intent was to have a hyphen in a function name
    (something like "fun add_a ...".
Status: open

---------------------------------------------------------------------------
74. withtype with identity type definition (printing only?)
Submitter: Nick
Date: 12/15/88
Version: 0.22
Code:
        - datatype Foo = FOO of Forest
        =    withtype Forest = Tree list
        =         and Tree = Foo;
        datatype  Foo
        con FOO : Forest -> Foo
        type  Forest = Tree list
        type  Tree = Tree               <-= Huh?
Comments: probably an artifact of printing from symbol table, not abstract syntax
Status: open

---------------------------------------------------------------------------
75. improper type variable causes Substring exception
Submitter: John Reppy
Date: 12/17/89
Version: 0.24
System: Sun 3
Code:
    - (nil : ' list);
    uncaught exception Substring
or
    - signature FRED = sig type Fred val x : ' Fred end;
    uncaught exception Substring

Status: open

---------------------------------------------------------------------------
76. parenthesized infix expression in fun lhs
Submitter: Dave Berry
Date: 12/22/88
Version: 0.24?
Code: 
    infix o;
    fun (f o g) x = f (g x);
Comments: This is correct according to the Definition (according to Berry)
Status: open

---------------------------------------------------------------------------
77. unparenthesized infix expressions in fun lhs
Submitter: Dave Berry
Date: 12/22/88
Version: 0.24?
Code: 
    infix 4 %;
    infix 3 %%;

    datatype foo = op % of int * int;
    fun a % b %% c % d = 0;

    NJ ML accepts this, as does Edinburgh ML.  It is incorrect; brackets
    are required as follows:

    fun (a % b) %% (c % d) = 0;

    This is defined on page 68 of the definition.  The lhs and rhs of the
    infixed operator being defined are required to be atomic patterns.
Status: open

---------------------------------------------------------------------------
79. withtype
Submitter: Simon (from abstract hardware) via Mike Fourman
Date: 1/31/88
Version: 0.24
Problem:
    "Did you know that the following is not valid ML?

	datatype type1 = T of type2 * type3
	withtype type2 = int (* this could be a large expression *)
	and      type3 = type2 * string;

    The reason is that the "datatype datbind withtype typbind" construct is
    expanded out into "datatype datbind'; type typbind" where "datbind'" is
    the the result of using "typbind" to expand "datbind". Note that this
    construct does *not* expand "typbind" itself, so "type2" is out of scope
    in its occurrence in "type3". This simultaneous definition property of
    "withtype" is quite annoying, especially as there is no way to get the
    effect of sequential definition (other than manually expanding out the
    body of "type3" - but that is precisely the problem that "withtype" is
    supposed to solve)."

Code:
    - 
	datatype type1 = T of type2 * type3
	withtype type2 = int (* this could be a large expression *)
	and      type3 = type2 * string;


    - = = Error: Compiler bug: defineEqTycon/eqtyc 1
    - 
	datatype type1 = T of type2 * type3
	withtype type3 = type2 * string
	withtype type2 = int (* this could be a large expression *);


    - = = Error: unbound type constructor (in datatype): type2
    Error: unbound type constructor (in datatype): type2
    Error: Compiler bug: defineEqTycon/eqtyc 1
    - 
Status: open

---------------------------------------------------------------------------
80. simultaneous type declarations
Submitter: Dave Berry
Date: 2/1/89
Version: 0.24
Code:
    - type type2 = int
    = and  type3 = type2 * string;
    type  type2 = int
    type  type3 = type2 * string
Comments:
    This is wrong: type2 shouldn't be bound before the declaration of type3.
Status: open

---------------------------------------------------------------------------
81. repeated specs in signatures
Submitter: John Reppy
Date: 2/12/89
Version: 0.24
Problem:
    I noticed that a signature of the form

	    sig
		    val x : int
		    val x : string
	    end

    is acceptable.  Although this is in keeping with redeclaration in other
    scopes, it isn't very useful, and lets detectable errors get by.  I would
    suggest that redeclaration of identifiers in signatures ought to at least
    generate a warning message (if not an error).
Comments:
Status: open

---------------------------------------------------------------------------
83. unexpected parsing of erroneous datatype declaration
Submitter: Carl Gunter
Date: 2/24/88
Version: 0.20
Code:
    - datatype complex = Complex (real,real);
    datatype  complex
    con Complex : complex
    val it = (fn,fn) : (int -> real) * (int -> real)
Comments:
    implicit "val it = " inserted after constructor Complex breaks the
    declaration into a valid datatype declaration and a top-level value
    expression (implicit value declaration).  This could probably be 
    detected and suppressed.
Status: open

---------------------------------------------------------------------------
85. bad error message for failed signature match
Submitter: John Reppy
Date: 3/6/89
Version: 0.28
Code:
    - structure Foo : sig
    =   type foo
    =   val f : foo -> int
    = end = struct
    =   type Foo = int
    =   fun f x = x
    = end;
    Error: unmatched type spec: foo
    tycStamp: INDtyc []
    Error: Compiler bug: tycStamp
Status: open

---------------------------------------------------------------------------
86. incorrectly allows redefining of "="
Submitter: Dave Berry
Date: 3/15/89
Version: 0.29
Problem:
    NJML handles the = symbol incorrectly in some cases.

    - val op = = op = ;
    - nonfix =;
    - = (true, true);
    Error: declaration or expression expected, found EQUAL

    The = symbol may not be redefined (Definition, page 4).  The top definition
    does seem to redefine =, despite the lack of response from the system.
    I can't see anything in the Definition that forbids making = nonfix,
    so I suppose it should be possible to use it in a nonfix way.

    Poly/ML gets this right.

    > val op = = op = ;
    Error- Pattern expected but = was found
    Exception static_errors raised
    > nonfix =;
    nonfix =
    > = (true, true);
    val it = true : bool

    It would be more pleasant if the error message said "Can't redefine =".

    Edinburgh ML 3.5 (for what it's worth) forbids the rebinding, and doesn't
    allow = to be nonfix.

    - val op = = op = ;

    Parse error:
	Was expecting a Prefix/infix/suffix-identifier
    In:  ... val op <?> =

    - nonfix =;

    Parse error:
	Insufficient repetition
    In:  ... nonfix <?> =

    The "Insufficient repetition" message is the model of clarity we should all
    be aiming for :-).
Status: open

---------------------------------------------------------------------------
87. execute subprocess dies on interrupt on blocked input
Submitter: dbm
Date: 3/19/89
Version: 0.31
System: Sun3/100, SunOS 4.0.1; VAX8550, V9
Problem: interrupting blocked call of input from execute subprocess
	 kills subprocesss
Code:
	val (ins,outs) = execute "cat"
	input ins 5;
	^Cuncaught exception Interrupt
Messages:
   After interrupt, System.system("ps x"), indicates that "cat"
   subprocess has disappeared, and subsequent attempt to flush output
   to outs raises exeption Io("output: write failed").
Comments:
   end_of_stream also blocks, and interrupting a call of end_of_stream
   seems to have the same effect.
Status: open

---------------------------------------------------------------------------
89. continuation line string escape at beginning of string
Submitter: dbm
Date: 4/3/89
Version: 0.33
System: Sun 3, SunOS 4.0.1
Code:
    - "\			(* CR after \ at beginning of string *)
    - akdk";
    Error: unclosed string
    =		    		(* second CR typed *)
    Error: unclosed string
    Error: unbound variable kdk
    = ;
    Error: operator is not a function
      operator: string
      in expression:
	"" kdk
Status: open

---------------------------------------------------------------------------
90. secondary prompt is not set in multi-line strings and comments.
Submitter: dbm and duba
Date: 4/3/89
Version: 0.33
System: All
Status: open

---------------------------------------------------------------------------
91. misparsing of fun lhs
Submitter: dbm and duba
Date: 4/3/89
Version: 0.33
System: All
Code:
    - fun a+b (x) = a;
    Error: Compiler bug: generalizeTy -- bad arg
      b : 'S -> undef
Status: open

---------------------------------------------------------------------------
92. uncaught Nth exception after type constructor arity mismatch in sigmatch
Submitter: David Tarditi, Princeton University, drt@notecnirp.princeton.edu
Date: 6/23/89
Version: 0.33
System: Vax/4.3 BSD
Problem: Mismatching arities on types causes uncaught exception Nth
	 later in signature checking.

Example:

functor OrdSet(B : sig
			type elem
			val gt : elem * elem -> bool
			val eq : elem * elem -> bool
		   end) =
struct
end

structure Bad =
    struct
	type 'a elem = int * 'a
	val gt = fn ((a:int,_),(b,_)) => a > b
	val eq = fn ((a:int,_),(b,_)) => a = b
    end

structure  X = OrdSet(Bad)

Result:

Standard ML of New Jersey, Version 0.33, 1 April 1989
val it = () : unit
std_in, line 18: Error: mismatching tycon arities: elem
uncaught exception Nth

Comments:

The uncaught exception Nth appears to occur while matching the actual types
of eq and gt against the types in the signature of the formal
structure parameter.

---------------------------------------------------------------------------
95. infix declaration interferes with type parsing
Submitter: David Tarditi, Princeton University, drt@notecnirp
Date: 4/30/89
Version: 0.33
System: Vax/4.3 BSD
Problem: Spurious declaration of infix for an identifier causes problems
	 when it is used as a type constructor later.

Sample Run:

Standard ML of New Jersey, Version 0.33, 1 April 1989
val it = () : unit
- type ('a,'b) --> = 'a -> 'b;
type ('a,'b)  --> = 'a -> 'b

- val a = fn _ => 5;
val a = fn : 'a -> int

- a : ('a,int) -->;
val it = fn : 'a -> int

- infix -->;

- a : ('a,int) -->;
Error: (user) bound type variable propagated out of scope
  it : 'aU -> int


Comments:
	The declaration of an identifier to be infix should not
affect type constructors.  Infix declarations apply only to data
constructors and value identifiers.  The declaration of '-->' to
be infix should not affect the use of '-->' as a type constructor,
even though the declaration is spurious.

P.S.
	Maybe there should be a way to declare type identifiers to be
infix.  I was trying to declare '-->' to be infix because I was creating
different kinds of arrows for my effects inference.  --> could denote
a function that is pure, while -*-> could denote a function with an
effect.  I need to do this to bootstrap the pervasive environment
without assuming that all built-in functions have side-effects.

Status: open

---------------------------------------------------------------------------
100. constructor not printed after open declaration
Submitter: Nick Rothwell
Date: 7/18/89
Version: 0.33
Problem:
  In this case, a datatype is being printed as a type: the constructor isn't
  shown (although it's still bound):
Code:

    - signature X = sig datatype T = T end;
    signature X =
      sig
	datatype T
	  con T : T
      end

    - structure X: X = struct datatype T = T end;
    structure X :
      sig
	datatype T
	  con T : T
      end

    - open X;
    type  T = T

Status: open

---------------------------------------------------------------------------
101. Duplicate labels (in either types or values) are not detected
Submitter: Simon Finn (simon%abstract-hardware-ltd.co.uk@nsfnet-relay.ac.uk)
Date: 7/28
Version: 0.33
Code:
    - {x=1,x=true} : {x:int,x:bool};
    val it = {x=1,x=true} : {x:int,x:bool}
Status: open

---------------------------------------------------------------------------
102. One-tuples are not printed sensibly.
Submitter: Simon Finn (simon%abstract-hardware-ltd.co.uk@nsfnet-relay.ac.uk)
Date: 7/28
Version: 0.33
Code:
    - (* a one-tuple *) {1 = 999};
    val it = (999) : int
    - it = 999;
Messages:
 Error: operator and operand don't agree (tycon mismatch)
   operator domain: (int) * (int)
   operand:         (int) * int
   in expression:
     it = 999
Status: open

---------------------------------------------------------------------------
103. Space missing in an error message (which might be more informative).
Submitter: Simon Finn (simon%abstract-hardware-ltd.co.uk@nsfnet-relay.ac.uk)
Date: 7/28
Version: 0.33
Code:
   - {999};
Messages:
   Error: numeric label abbreviation999
Status: open

---------------------------------------------------------------------------
104. Labels with leading zeroes should not be accepted (this is made
     explicit on page 5 of version 3 of the Standard).
Submitter: Simon Finn (simon%abstract-hardware-ltd.co.uk@nsfnet-relay.ac.uk)
Date: 7/28
Version: 0.33
Code:
    - {0000002 = 999};
    val it = {2=999} : {2:int}
Status: open

---------------------------------------------------------------------------
105. Large numeric labels are disallowed.    
Submitter: Simon Finn (simon%abstract-hardware-ltd.co.uk@nsfnet-relay.ac.uk)
Date: 7/28
Version: 0.33
Code:
    -  {9999999999999999999999 = 999};
Messages:
    Error: integer too large
    Error: nonpositive integer label, found 0

---------------------------------------------------------------------------
106. Something strange is happening with "it".
Submitter: Simon Finn (simon%abstract-hardware-ltd.co.uk@nsfnet-relay.ac.uk)
Date: 7/28
Version: 0.33
Code:
    Standard ML of New Jersey, Version 0.33, 1 April 1989
    val it = () : unit
    - raise it;
    Error: argument of raise is not an exception
      raised: unit
      in expression:
	raise it
    - raise it;
    Error: argument of raise is not an exception
      raised: unit
      in expression:
	raise it
    - raise it;
    uncaught exception Runbind
    - raise it;
    uncaught exception Runbind
    - 
Comment:
    The problem of an exception leaving the system in an uncertain 
    state seems to occur in other contexts too.

---------------------------------------------------------------------------
107. NJML disappears into an infinite loop when trying to parse large real numbers;
     presumably some error recovery code is flakey.
Submitter: Simon Finn (simon%abstract-hardware-ltd.co.uk@nsfnet-relay.ac.uk)
Date: 7/28
Version: 0.33
Code:
    - 1.0E308;
    val it = 1.0E308 : real
    - 1.0E309;
    Error: Real constant  out of range
    - 2.0E308; (* wait a long time ... *)
    val it = uncaught exception Interrupt
    - 
Comment:
Furthermore, a failing program elaboration or evaluation (such as the above)
should not rebind the variable "it" (ML Standard v3, rules 194 and 195).
NJML sometimes does (as above).

Furthermore, trying to print "it" when it has been bound to such an
exception sometimes seems to crash the system (it refuses to respond to
further input); at other times the exception Runbind is raised.

Does anyone know why the largest integer NJML will parse is 1073741775 ?
This is 2^30 - 49, which seems a funny number to choose. (Mike Crawley
suggests the fact that 49 is the ASCII code for "1" may be significant.)

Status: open

---------------------------------------------------------------------------
108. More faulty error recovery?
Submitter: Simon Finn (simon%abstract-hardware-ltd.co.uk@nsfnet-relay.ac.uk)
Date: 7/28
Version: 0.33
Code:
    - 
    (* calculates ~ 2^30 *) ~1073741775 - 49;

    [Increasing heap to 4096k]

    [Major collection... 99% used (973164/976372), 8020 msec]

    [Increasing heap to 7568k]
    val it = uncaught exception Interrupt
    - 
Status: open

---------------------------------------------------------------------------
109. sharing of datatypes not handled properly
Submitter: Simon Finn (simon%abstract-hardware-ltd.co.uk@nsfnet-relay.ac.uk)
Date: 7/28
Version: 0.33
Code:
    signature EQSIG =
    sig
      type r
      datatype s = S of r
	   and t = T of s
      sharing type r = t
    end;

    functor F(X : EQSIG) =
    struct
      fun test(x : X.t) = (x = x);
    end;
Messages:

    signature EQSIG =
      sig
	type r
	datatype s
	  con S : r -> s
	datatype t
	  con T : s -> t
      end
    Error: operator and operand don't agree (equality type required)
      operator domain: ''S * ''S
      operand:         ?.t * ?.t
      in expression:
	x = x
    Error: Compiler bug: abstractType

Comment:
    Both are wrong, as the signature EQSIG elaborates to the same semantic object
    as the following (which both treat correctly):

    signature EQSIG =
    sig
      type r
      datatype s = S of t
	   and t = T of s
      sharing type r = t
    end;

Status: open

---------------------------------------------------------------------------
110. val rec
Submitter: Simon Finn, Abstract Hardware Ltd, simon@uk.co.ahl
Date: 7/18/89
Version: 0.33
System: Sun3/SunOS 4.0
Problem: val rec form of definition rejected
Code:

- val x = 1 and rec y = fn z => z; (* should compile *)
Error: expected an atomic pattern, found REC
Error: expected EQUAL, found REC
Error: atomic expression expected, found REC
Error: declaration or expression expected, found REC

Comment: the compiler should accept the above declaration.
Status: open

---------------------------------------------------------------------------
111. local polymorphic definitions
Submitter: Simon Finn, Abstract Hardware Ltd, simon@uk.co.ahl
Date: 7/18/89
Version: 0.33
System: Sun3/SunOS 4.0
Problem: local polymorphic definitions rejected
Code:

- val q = let exception x of '_a in 1 handle x _ => 2 end;
Error: type variable in exception type not weak enough

- local exception x of '_a in val q = 1 handle x _ => 2 end;
Error: type variable in exception type not weak enough


Comment: the compiler should accept both the above definitions,
         which are valid, since the imperative type variable '_a
         is *not* free in the top level declaration.
Status: open

---------------------------------------------------------------------------
112. equality
Submitter: Simon Finn, Abstract Hardware Ltd, simon@uk.co.ahl
Date: 7/18/89
Version: 0.33
System: Sun3/SunOS 4.0
Problem: equality misbehaving
Code:

(0.0 = ~0.0, 0.0 = ~ 0.0, ~0.0 = ~ 0.0);    (* (true,true,true) *)

infix eq; fun x eq y = x = y;
(0.0 eq ~0.0, 0.0 eq ~ 0.0, ~0.0 eq ~ 0.0); (* (true,false,false) *)

infix eq; fun (x:real) eq y = x = y;
(0.0 eq ~0.0, 0.0 eq ~ 0.0, ~0.0 eq ~ 0.0); (* (true,true,true) *)

Comment: the polymorphic equality function should give
         consistent results, even when the type of its
         argument is known to be real.
Status: open

---------------------------------------------------------------------------
113. empty declarations
Submitter: Simon Finn, Abstract Hardware Ltd, simon@uk.co.ahl
Date: 7/18/89
Version: 0.33
System: Sun3/SunOS 4.0
Problem: Parsing empty declarations
Code:

    let val x = 1; (* empty declaration *) ; val y = 2 in x + y end;
    Error: expected IN, found SEMICOLON
    Error: atomic expression expected, found SEMICOLON
    Error: atomic expression expected, found VAL
    Error: expected END, found VAL
    Error: declaration or expression expected, found IN

Comment: the above program is syntactically correct.
Status: open

---------------------------------------------------------------------------
115. cyclic signatures
Submitter: Simon Finn, Abstract Hardware Ltd, simon@uk.co.ahl
Date: 7/18/89
Version: 0.33
System: Sun3/SunOS 4.0
Problem: cyclic signatures
Code:

    (* shouldn't be allowed, since object (signature) is not cycle-free *)
    signature bad =
    sig
      structure A :
      sig
	structure B : sig end;
      end;
      sharing A = A.B;
    end;

Comment: NJML accepts the above signature declaration, which should be
         rejected because it elaborates to a cyclic semantic object;
         cyclic objects are not semantically admissible.

Status: not a bug?  (signature will never match a structure)

---------------------------------------------------------------------------
116. pattern declares no variables warning (?)
Submitter: Simon Finn, Abstract Hardware Ltd, simon@uk.co.ahl
Date: 7/18/89
Version: 0.33
System: Sun3/SunOS 4.0
Problem: Missing warning message
Code:

let val _ = 1 in 2 end;
local val _ = 1 in val it = 2 end;


Comment: Each of the above should produce a "Pattern declares
         no variables" warning message, but neither does.

Status: not a bug 

---------------------------------------------------------------------------
117. sharing and equality attributes
Submitter: Simon Finn, Abstract Hardware Ltd, simon@uk.co.ahl
Date: 7/18/89
Version: 0.33
System: Sun3/SunOS 4.0
Problem: problems with equality attribute
Code:

(***************************************************************************)
(* This is illegal in version 3 of the ML standard                         *)
(* s may only be elaborated to a non-equality type (+ extra bits)          *)
(* t may only be elaborated to an equality type (for consistency with its  *)
(* constructor environment)                                                *)
(* Hence s and t can't share                                               *)
(***************************************************************************)

signature BADSIG =
sig
  datatype s = Dummy of bool -> bool
  datatype t = Dummy of int
  sharing type s = t;
end;

Comment: NJML accepts this signature but shouldn't. Getting the
         equality attribute right in the presence of sharing
         constraints seems to be quite a tricky problem.

Status: open

---------------------------------------------------------------------------
118. deviation from Definition, div and mod
Submitter: Simon Finn, Abstract Hardware Ltd, simon@uk.co.ahl
Date: 7/18/89
Version: 0.33
System: Sun3/SunOS 4.0
Problem: div / mod give non-standard results
Code:

fun divmod (m,n) = (m div n,m mod n);
(* should give (1,2)   *) divmod(5,3);   (* gives (1,2)   *)
(* should give (~2,1)  *) divmod(~5,3);  (* gives (~1,~2) *)
(* should give (~2,~1) *) divmod(5,~3);  (* gives (~1,2)  *)
(* should give (1,~2)  *) divmod(~5,~3); (* gives (1,~2)  *)

Comments: I'd like the initial dynamic basis to conform to the Standard.
          (More efficient, non-standard versions should be hidden away.)
Status: intensional

---------------------------------------------------------------------------
119. deviation from Definition
Submitter: Simon Finn, Abstract Hardware Ltd, simon@uk.co.ahl
Date: 7/18/89
Version: 0.33
System: Sun3/SunOS 4.0
Problem: I/O functions are curried, Standard has them uncurried
Code:

    - input;
    val it = fn : instream -> int -> string

Comments: I'd like the initial dynamic basis to conform to the Standard.
          (More efficient, non-standard versions should be hidden away.)
Status: intensional

---------------------------------------------------------------------------
120. deviation from Definition
Submitter: Simon Finn, Abstract Hardware Ltd, simon@uk.co.ahl
Date: 7/18/89
Version: 0.33
System: Sun3/SunOS 4.0
Problem: Prelude functions raise the wrong exceptions
Code:

    0.0 / 0.0; (* raises Overflow *)
    1.0 / 0.0; (* raises Real *)

Comments: I'd like the initial dynamic basis to conform to the Standard.
          (More efficient, non-standard versions should be hidden away.)
This one is even trickier; Poly/ML doesn't raise any exception at all
for these (it prints NaN.0 and Infinity.0 respectively).
Status: intensional

---------------------------------------------------------------------------
121. Unimplemented parts of Standard
Submitter: Simon Finn, Abstract Hardware Ltd, simon@uk.co.ahl
Date: 7/18/89
Version: 0.33
System: Sun3/SunOS 4.0
Problem: open in signatures apparently unsupported
Code:

    - structure old = struct type t = int end;
    structure old :
      sig
	eqtype t
      end
    - signature new = sig open old end;
    Error: expected END, found OPEN
    Error: declaration or expression expected, found END
    - 


---------------------------------------------------------------------------
122. Unimplemented parts of Standard
Submitter: Simon Finn, Abstract Hardware Ltd, simon@uk.co.ahl
Date: 7/18/89
Version: 0.33
System: Sun3/SunOS 4.0
Problem: let and local for structures apparently unsupported
Code:

    - structure Y = struct local val x=1 in structure X = struct val y = 1 end end end;
    Error: expected END, found STRUCTURE
    Error: declaration or expression expected, found END

    - structure Y = let val x=1 in struct structure X = struct val y = 1 end end end;
    Error: expected a structure-expression, found LET
    - 

---------------------------------------------------------------------------
122. Unimplemented parts of Standard
Submitter: Simon Finn, Abstract Hardware Ltd, simon@uk.co.ahl
Date: 7/18/89
Version: 0.33
System: Sun3/SunOS 4.0
Problem: local in signature apparently unsupported
Code:

    - signature SIG =
    sig
      structure S : sig type t end;
      local open S; in val x : t; end;
    end;
    = = = Error: expected END, found LOCAL
    Error: unbound structure name: S
    Error: unbound type constructor: t
    Error: expected EQUAL, found SEMICOLON
    Error: atomic expression expected, found SEMICOLON
    - 
Status: open

---------------------------------------------------------------------------
123. error recovery
Submitter: Simon Finn, Abstract Hardware Ltd, simon@uk.co.ahl
Date: 18 July 1989
Version: 0.33
System: Sun3/SunOS 4.0
Problem: NJML error recovery is flakey
Code: 
    val it = () : unit
    - infix xxx;
    - fun (a xxx b) = 3;
    Error: expected EQUAL, found RPAREN
    Error: atomic expression expected, found RPAREN
    Error: declaration or expression expected, found RPAREN
    - fun output (s,w) = output s w;
    Error: pattern and expression in val rec dec don't agree (circularity)
      pattern:    'S -> 'T -> 'U
      expression: 'S * 'T -> 'U
      in declaration:
	output = (fn arg => (case arg
		  of <pat> => <exp>))
    - output;
    uncaught exception Runbind

Comments: The declaration of "xxx" should be accepted - this is a minor
          known (?) parsing bug. The redeclaration of "output" is a user
          error. The two in succession seem to severely confuse the
          compiler; either independently seems to be OK.
Status: open

---------------------------------------------------------------------------
124. compiler bug after incomplete qualified identifier
Submitter: David Tarditi, Princeton University, drt@notecnirp
Date: 4/21/89
Version: 0.33
System: Vax/4.3 BSD
Problem: compiler error results when incomplete qualified identifier is used.
Sample Run:

    Standard ML of New Jersey, Version 0.33, 1 April 1989
    val it = () : unit
    -Integer.;
    Error: incomplete qualified identifier
    Error: Compiler bug: EnvAccess.lookPathinStr.getStr
    -

Comments:
Caused by using an incomplete qualified identifier.

Status: open

---------------------------------------------------------------------------
126.  scope of explicit type variables
Submitter: Mads Tofte <mads%lfcs.edinburgh.ac.uk@NSFNET-RELAY.AC.UK>
Date: 7/11/89
Version: 0.33
Problem:
New Jersey ML (Version 33) does not accept the following declarations.
It complains that a user bound type variable escapes out of scope in `insert'.
But the scope of ''a and 'b is the whole of the fun declaration.  The problem
seems to be associated with mutual recursion.

  type (''a, 'b)map = (''a *  'b) list

  fun plus(l:(''a,'b)map ,[]: (''a, 'b)map ): (''a, 'b)map = l
    | plus(l,hd::tl) = plus(insert(l,hd), tl)
  and insert([], p) = [p]
    | insert((x,y)::rest, (x',y')) = 
        if x=x' then (x',y')::rest
        else (x,y) :: insert(rest,(x',y'));

Status: open (not a bug?)

---------------------------------------------------------------------------
127. sharing and equality types
Submitter: Mads Tofte <mads%lfcs.edinburgh.ac.uk@NSFNET-RELAY.AC.UK>
Date: 7/11/89
Version: 0.33
Problem: 
New Jersey ML does not accept the following functor declaration (it
complains that S.x is not of equality type).  According to the
Definition, two types share only if they have the same name (stamp).
In particular, since equality is an attribute of type names (Version
3, page 16), one admits equality iff the other does (one cannot have
different ``views'' of equality).  

Presumably the problem is a bug in the unification of type names.

Code:
    functor f(structure S : sig type t val x: t end
	      structure T : sig eqtype t end
	      sharing S = T
	     )=
    struct val b:bool = S.x = S.x
    end;
      
Status: open

---------------------------------------------------------------------------
128. question mark as reserved word
Submitter: Mads Tofte <mads%lfcs.edinburgh.ac.uk@NSFNET-RELAY.AC.UK>
Date: 7/11/89
Version: 0.33
Problem: 
New Jersey ML treats ? as a reserved word (it once was).

Status: open

---------------------------------------------------------------------------
132. rebinding of "=" allowed
Submitter: Mike Fourman (mikef%lfcs.ed.ac.uk)
Date: 6/8/89
Version: 0.33
Problem: NJML allows = to be rebound (contrary to page 4 of the definition)
Code:
    - val op = = op < : int * int -> bool;
    val = = fn : int * int -> bool
    - 
Status: open

---------------------------------------------------------------------------
133. overloading resolution is weaker than Edinburgh SML or Poly ML
Submitter: Larry Paulson (lcp@computer-lab.cambridge.ac.uk)
Date: 5/8/89
Version: 0.33
Problem:
Code:
    datatype 'a tree = Stree of 'a list * (string * 'a tree) list
    fun insert ((key::keys, x), Stree(xs,alist)) =
	  let fun inslist((keyi,tri)::alist) =
		    if key<keyi then alist else (keyi,tri) :: inslist alist
	  in  Stree(xs, inslist alist)  end;
Messages:
    Error: overloaded variable "<" cannot be resolved
Status: Open

---------------------------------------------------------------------------
134. type checking
Submitter: 
  Erik Tarnvik 
  Department of Computing Science
  University of Umea
  SWEDEN
  erikt@cs.umu.se
Date: 5/12/89
Version: 0.33
System: Sun3
Problem:
The compiler reports a type clash were it shouldn't.

Code:
    type 'a ft = (int * 'a) list;

    fun f ([]:'a ft) x = []:'a ft
      | f (((y,fy)::l):'a ft) x = 
	  if x = y
	  then l:'a ft
	  else (y,fy)::(f l x):'a ft

    and g (l:'a ft) (x,fx) = (x,fx) :: (f l x):'a ft;

Messages:
    type 'a  ft = (int * 'a) list
    line 10: Error: operator and operand don't agree (bound type var)
      operator domain: (int * 'aU) list
      operand:         'aU ft
      in expression:
	f l
Comments:
The Edinburgh SML (ver 3.3) does not report an error on this code.
If the 'and' in the last line is changed to 'fun', no error is reported.
I hope I haven't missunderstood something about SML. This is a bug, isn't it?

Status: open

---------------------------------------------------------------------------
135. eqtype vs abstype
Submitted: Bernard Sufrin (sufrin%prg.oxford.ac.uk@NSFnet-Relay.AC.UK)
Date: 7/26/89
Version: 0.33
Problem: interaction of abstype and eqtype

I ran into this problem whilst writing you a long note concerning
abstraction bindings structure bindings and their respect for type and
eqtype specifications. Here's a miniature version of the larger
problem.

We want a pair of types Open and Shut, and transfer functions between
them. The two signatures below are candidates for describing such a
structure: the latter leaves visible the equality on Open, the former
should not.

    signature T =
    sig
      type Shut
      type Open
      val Shut:Open->Shut
      and Open: Shut->Open
    end

    signature U =
    sig
      type Shut
      eqtype Open
      val Shut:Open->Shut
      and Open: Shut->Open
    end

Now we design a functor which simply wraps something up in order to shut it.

    functor absT(type Open)  =
    struct
      type Open = Open
      abstype Shut = SHUT of Open  with
	val Shut  = SHUT
	fun Open(SHUT x) = x
      end
    end

Now we instantiate it:

    structure b:T = absT(type Open=int)

Compiler yields:

    structure b :
    sig
      eqtype Shut         <----- can't be right, surely
      eqtype Open
      val Open : Shut -> Open
      val Shut : Open -> Shut
    end

The equality on Shut has leaked, despite the fact that the actual
representation of Shut is an abstype. (The same happens if absT is
itself constrained to yield a T)

    - b.Shut 3=b.Shut 4;
    val it = false : bool

On the other hand using an abstraction binding

    abstraction ab:T = absT(type Open=int)

Compiler yields, correctly,

    structure ab :
      sig
	type Shut
	type Open
	val Open : Shut -> Open
	val Shut : Open -> Shut
      end

but I cannot actually apply ab.Shut to an integer (its domain is not
int, but an opaque and different type, namely ab.Open).  Now let's try

    abstraction au:U = absT(type Open=int)

Compiler yields, correctly,

    structure au :
    sig
      type Shut                                    
      eqtype Open
      val Open : Shut -> Open
      val Shut : Open -> Shut
    end

but I still can't apply au.Shut to an integer. Incidentally in my
original note I asked (a) whether I ought to be able to, (b) if so,
whether eqtype was not getting a bit overloaded [equality visible AND
representation visible] (c) if not, how could one do this sort of
thing at all?

Meanwhile

    structure argh:U = absT(type Open=int)

still makes Open and Shut both eqtypes.  More bizarrely, we have

    abstype opaque = opaque of int with
     val hide = opaque
     val show = fn(opaque x)=>x
    end

    structure biz:T = absT(type Open=opaque)

Compiler yields

    structure biz :
      sig
	eqtype Shut                 <--- wow!
	type Open
	val Open : Shut -> Open
	val Shut : Open -> Shut
      end

Shut is now an eqtype despite being an abstype whose representation
includes another abstype!

Status: open

---------------------------------------------------------------------------
136. linkdata problem
Submitter: John Reppy (ulysses!jhr, jhr@cs.cornell.edu)
Date: 7/12/89
Version: 0.36
System: Sun 3, SunOS 4.0.3
Problem: failure to build
Code:
When I tried to build 0.36 on the sun-3, I got the message

	ld: : Is a directory

on the load of the runtime system.  The problem is with the allmo.o
file.  I am able to build the system using "-noshare".

Status: open

---------------------------------------------------------------------------
