= The `HashSetFn` functor
:Author: John Reppy
:Date: {release-date}
:stem: latexmath
:source-highlighter: pygments
:VERSION: {smlnj-version}

The `HashSetFn` functor provides a hash-table-based implementation
of imperative sets parameterized over a `Key` structure.

== Synopsis

[source,sml]
------------
signature MONO_HASH_SET
functor HashSetFn (Key : HASH_KEY) : MONO_HASH_SET
------------

== Functor Argument Interface

[source,sml]
------------
Key : HASH_KEY
------------

== Functor Argument Description

`Key : xref:sig:HASH_KEY.adoc[HASH_KEY]`::
  A structure that implements the xref:sig:HASH_KEY.adoc[HASH_KEY]`
  signature, where xref:sig:HASH_KEY.adoc#type:hash_key[`Key.hash_key`]
  will be the type of the elements in the hash set.

== Interface

[source,sml]
------------
structure Key : HASH_KEY

type item = Key.hash_key
type set

val mkEmpty : int -> set

val mkSingleton : item -> set

val mkFromList : item list -> set

val add  : set * item -> unit
val addc : set -> item -> unit

val addList : set * item list -> unit

val without : set * item -> unit

val delete : set * item -> bool

val member : set * item -> bool

val isEmpty : set -> bool

val isSubset : (set * set) -> bool

val numItems : set ->  int

val listItems : set -> item list

val map : (item -> item) -> set -> set
val app : (item -> unit) -> set -> unit
val fold : (item * 'b -> 'b) -> 'b -> set -> 'b
------------

== Interface Description

`[.kw]#structure# Key : HASH_KEY`::
  This substructure is the argument structure, which defines the type
  of set elements, and hash and equality functions on the key type.

`[.kw]#type# item = Key.hash_key`::
  The type of items in the sets.

`[.kw]#type# set`::
  The type of imperative sets of items.

`[.kw]#val# mkEmpty : int \-> set`::
  `mkEmpty n` creates an empty set that has initial space to store
  at least `n` items.

`[.kw]#val# mkSingleton : item \-> set`::
  `mkSingleton item` creates a set with `item` as its only initial element.

`[.kw]#val# mkFromList : item list \-> set`::
  `mkFromList items` creates a set with `items` as its initial elements.

[[val:toList]]
`[.kw]#val# toList : set \-> item list`::
  `toList set` returns a list of the items in `set`.

`[.kw]#val# add  : set * item \-> unit`::
  `add (set, item)` destructively adds the item to the set.

`[.kw]#val# addc : set \-> item \-> unit`::
   `addc set item` destructively adds the item to the set.

`[.kw]#val# addList : set * item list \-> unit`::
  `addList (set, items)` destructively adds the list of items to the set.

`[.kw]#val# subtract : set * item \-> unit`::
  `subtract (set, item)` removes the object `item` from `set`; it has no
  effect if `item` is not in `set`.

`[.kw]#val# delete : set * item \-> bool`::
  `subtract (set, item)` removes the object `item` from `set` (if present)
  and returns `true` if the item was removed and `false` if it was not
  present.

`[.kw]#val# member : set * item \-> bool`::
  `member (item, set)` returns `true` if, and only if, `item`
  is an element of `set`.

`[.kw]#val# isEmpty : set \-> bool`::
  `isEmpty set` returns true if, and only if, `set` is empty.

`[.kw]#val# isSubset : (set * set) \-> bool`::
  `isSubset (set1, set2)` returns true if, and only if, `set1`
  is a subset of `set2` (_i.e._, any element of `set1` is an
  element of `set2`).

`[.kw]#val# numItems : set \->  int`::
  `numItems set` returns the number of items in the `set`.

`[.kw]#val# map : (item \-> item) \-> set \-> set`::
  `map f set` creates a new set from the result of applying the
  function `f` to the elements of `set`.  This expression is
  equivalent to
+
[source,sml]
------------
mkFromList (List.map f (toList set))
------------

`[.kw]#val# app : (item \-> unit) \-> set \-> unit`::
  `app f set` applies the function `f` to the items in `set`.

`[.kw]#val# fold : (item * 'b \-> 'b) \-> 'b \-> set \-> 'b`::
  `foldl f init set` folds the function `f` over the items in
  `set` using `init` as the initial value.

=== Deprecated functions

`[.kw]#val# without : set * item \-> unit`::
  Use xref:#val:subtract[`subtract`] instead.

`[.kw]#val# listItems : set \-> item list`::
  Use xref:#val:toList[`toList`] instead.

== See Also

xref:sig-HASH_KEY.adoc[`HASH_KEY`],
xref:sig-MONO_ORD_SET.adoc[`MONO_ORD_SET`],
xref:smlnj-lib.adoc[__The Util Library__]
