= The `Controls` structure
:Author: John Reppy
:Date: {release-date}
:stem: latexmath
:source-highlighter: pygments
:VERSION: {smlnj-version}

The `Controls` structure defines the basic types and operations
for the *Controls Library*.

== Synopsis

[source,sml]
------------
signature CONTROLS
structure Controls : CONTROLS
------------

== Interface

[source,sml]
------------
type priority = int list
type 'a control

type 'a value_cvt = {
    tyName : string,
    fromString : string -> 'a option,
    toString : 'a -> string
  }

val control : {
        name : string,
        pri : priority,
        obscurity : int,
        help : string,
        ctl : 'a ref
      } -> 'a control

val genControl : {
        name : string,
        pri : priority,
        obscurity : int,
        help : string,
        default : 'a
      } -> 'a control

exception ValueSyntax of {tyName : string, ctlName : string, value : string}

val stringControl : 'a value_cvt -> 'a control -> string control

val name : 'a control -> string
val get : 'a control -> 'a
val set : 'a control * 'a -> unit
val set' : 'a control * 'a -> unit -> unit
val help : 'a control -> string
val info : 'a control -> {priority : priority, obscurity : int, help : string}

val mkOptionFlag : {
        ctl : bool control,
        short : string,
        long : string option
      } -> unit GetOpt.opt_descr

val mkOptionReqArg : {
        ctl : string control,
        arg : string,
        short : string,
        long : string option
      } -> unit GetOpt.opt_descr

val mkOption : {
        ctl : string control,
        arg : string,
        default : string,
        short : string,
        long : string option
      } -> unit GetOpt.opt_descr

val save'restore : 'a control -> unit -> unit

val compare : ('a control * 'a control) -> order
------------

== Description

`[.kw]#type# priority = int list`::
  something

`[.kw]#type# 'a control`::
  something

[[type:value_cvt]]
`[.kw]#type# 'a value_cvt = { ... }`::
  A value converter is used to convert between strings and another
  type.  The fields have the following meaning:
+
--
    `tyName : string`::
      The name of the type being converted,

    `fromString : string -> 'a option`::
      The function for converting from strings to the type.

    `toString : 'a -> string'`::
      The function for converting from the type to strings.
--

  (* create a new control *)
`[.kw]#val# control : {name, pri, obscurity, help, ctl} \-> 'a control`::
  something
+
--
    `name : string`::
        name of the control

    `pri : priority`::
        control's priority

    `obscurity : int`::
        control's detail level; higher means more obscure

    `help : string`::
        control's description

    `ctl : 'a ref`::
        ref cell holding control's state
--

  (* generate a control *)
`[.kw]#val# genControl : {name, pri, obscurity, help, ctl, default} \-> 'a control`::
  something

`[.kw]#exception# ValueSyntax of {tyName : string, ctlName : string, value : string}`::
  This exception is raised to communicate that there is a syntax error
  in a string representation of a control value.

`[.kw]#val# stringControl : 'a value_cvt \-> 'a control \-> string control`::
  `stringControl cvt ctl` creates a string-valued interface to the control `ctl`
  using the given value converter.

  (* control operations *)
`[.kw]#val# name : 'a control \-> string`::
  something

`[.kw]#val# get : 'a control \-> 'a`::
  something

`[.kw]#val# set : 'a control * 'a \-> unit`::
  something

`[.kw]#val# set' : 'a control * 'a \-> unit \-> unit (* delayed; error checking in 1st stage *)`::
  something

`[.kw]#val# help : 'a control \-> string`::
  something

`[.kw]#val# info : 'a control \-> {priority : priority, obscurity : int, help : string}`::
  something

  (* package a boolean control as a GetOpt option descriptor (NoArg) *)
`[.kw]#val# mkOptionFlag : {ctl, short, long} \-> unit GetOpt.opt_descr`::
  something
+
--
    `ctl : bool control`::
        the control that will be set by the command-line option

    `short : string`::
        the short name for the option; either zero or one chars

    `long : string option`::
        an optional long-name for the option
--

  (* package a string control as a GetOpt option descriptor with required argument (ReqArg)  *)
`[.kw]#val# mkOptionReqArg : {ctl, arg, short, long} \-> unit GetOpt.opt_descr`::
  something
+
--
    `ctl : string control`::
        the control that will be set by the command-line option

    `arg : string`::
        the name for the argument, which is used in the usage message

    `short : string`::
        the short name for the option; either zero or one chars

    `long : string option`::
        an optional long-name for the option
--

  (* package a string control as a GetOpt option descriptor with an optional argument (OptArg) *)
`[.kw]#val# mkOption : {ctl, arg, default, short, long} \-> unit GetOpt.opt_descr`::
  something
+
--
    `ctl : string control`::
        the control that will be set by the command-line option

    `arg : string`::
        the name for the argument, which is used in the usage message

    `default : string`::
        the default value for when no argument is given

    `short : string`::
        the short name for the option; either zero or one chars

    `long : string option`::
        an optional long-name for the option
--

`[.kw]#val# save'restore : 'a control \-> unit \-> unit`::
  ``save'restore ctl`` saves the current value of the control and
  returns a `unit -> unit` function that will restore the value.

  (* compare the priority of two controls *)
`[.kw]#val# compare : ('a control * 'a control) \-> order`::
  `compare (ctl1, ctl2)` returns the priority order of the two controls.

== See Also

xref:str-ControlUtil.adoc[`ControlUtil`],
xref:controls-lib.adoc[__The Controls Library__]
