= The `HashConsMap` structure
:Author: John Reppy
:Date: {release-date}
:stem: latexmath
:source-highlighter: pygments
:VERSION: {smlnj-version}

The `HashConsMap` structure ...

== Synopsis

[source,sml]
------------
signature HASH_CONS_MAP
structure HashConsMap : HASH_CONS_MAP
------------

== Interface

[source,sml]
------------
type 'a obj = 'a HashCons.obj

type ('a, 'b) map

val empty : ('a, 'b) map

val isEmpty : ('a, 'b) map -> bool

val singleton : ('a obj * 'b) -> ('a, 'b) map

val insert  : ('a, 'b) map * 'a obj * 'b -> ('a, 'b) map
val insert' : (('a obj * 'b) * ('a, 'b) map) -> ('a, 'b) map

val insertWith  : (('b * 'b) -> 'b)
      -> ('a, 'b) map * 'a obj * 'b -> ('a, 'b) map
val insertWithi :  (('a obj * 'b * 'b) -> 'b)
      -> ('a, 'b) map * 'a obj * 'b -> ('a, 'b) map

val find : ('a, 'b) map * 'a obj -> 'b option

val lookup : ('a, 'b) map * 'a obj -> 'b

val inDomain : (('a, 'b) map * 'a obj) -> bool

val remove : ('a, 'b) map * 'a obj -> ('a, 'b) map * 'b

val first : ('a, 'b) map -> 'b option
val firsti : ('a, 'b) map -> ('a obj * 'b) option

val numItems : ('a, 'b) map ->  int

val listItems  : ('a, 'b) map -> 'b list
val listItemsi : ('a, 'b) map -> ('a obj * 'b) list

val listKeys : ('a, 'b) map -> 'a obj list

val collate : ('b * 'b -> order) -> (('a, 'b) map * ('a, 'b) map) -> order

val unionWith  : ('b * 'b -> 'b) -> (('a, 'b) map * ('a, 'b) map)
      -> ('a, 'b) map
val unionWithi : ('a obj * 'b * 'b -> 'b) -> (('a, 'b) map * ('a, 'b) map)
      -> ('a, 'b) map

val intersectWith  : ('b * 'c -> 'd) -> (('a, 'b) map * ('a, 'c) map)
      -> ('a, 'd) map
val intersectWithi : ('a obj * 'b * 'c -> 'd) -> (('a, 'b) map * ('a, 'c) map)
      -> ('a, 'd) map

val mergeWith : ('b option * 'c option -> 'd option)
      -> (('a, 'b) map * ('a, 'c) map) -> ('a, 'd) map
val mergeWithi : ('a obj * 'b option * 'c option -> 'd option)
      -> (('a, 'b) map * ('a, 'c) map) -> ('a, 'd) map

val app  : ('b -> unit) -> ('a, 'b) map -> unit
val appi : (('a obj * 'b) -> unit) -> ('a, 'b) map -> unit

val map  : ('b -> 'c) -> ('a, 'b) map -> ('a, 'c) map
val mapi : ('a obj * 'b -> 'c) -> ('a, 'b) map -> ('a, 'c) map

val fold  : ('b * 'c -> 'c) -> 'c -> ('a, 'b) map -> 'c
val foldi : ('a obj * 'b * 'c -> 'c) -> 'c -> ('a, 'b) map -> 'c

val filter  : ('b -> bool) -> ('a, 'b) map -> ('a, 'b) map
val filteri : ('a obj * 'b -> bool) -> ('a, 'b) map -> ('a, 'b) map

val mapPartial  : ('b -> 'c option) -> ('a, 'b) map -> ('a, 'c) map
val mapPartiali : ('a obj * 'b -> 'c option) -> ('a, 'b) map -> ('a, 'c) map

val exists : ('b -> bool) -> ('a, 'b) map -> bool
val existsi : ('a obj * 'b -> bool) -> ('a, 'b) map -> bool

val all : ('b -> bool) -> ('a, 'b) map -> bool
val alli : ('a obj * 'b -> bool) -> ('a, 'b) map -> bool
------------

== Description

`[.kw]#type# 'a obj = 'a HashCons.obj`::
  something

`[.kw]#type# ('a, 'b) map`::
  something

`[.kw]#val# empty : ('a, 'b) map`::
  something
	(* The empty map *)

`[.kw]#val# isEmpty : ('a, 'b) map -> bool`::
  something
	(* Return true if and only if the map is empty *)

`[.kw]#val# singleton : ('a obj * 'b) -> ('a, 'b) map`::
  something
	(* return the specified singleton map *)

`[.kw]#val# insert  : ('a, 'b) map * 'a obj * 'b -> ('a, 'b) map`::
  something

`[.kw]#val# insert' : (('a obj * 'b) * ('a, 'b) map) -> ('a, 'b) map`::
  something
	(* Insert an item. *)

`[.kw]#val# insertWith  : (('b * 'b) -> 'b)`::
  something
	  -> ('a, 'b) map * 'a obj * 'b -> ('a, 'b) map
	(* Insert an item with a combining function to resolve collisions.
	 * The first argument to the combining function is the existing value,
	 * and the second argument is the value being inserted into the map.
	 *)

`[.kw]#val# insertWithi :  (('a obj * 'b * 'b) -> 'b)`::
  something
	  -> ('a, 'b) map * 'a obj * 'b -> ('a, 'b) map
	(* Like insertWith, except that the combining function also takes the
	 * key as an argument.
	 *)

`[.kw]#val# find : ('a, 'b) map * 'a obj -> 'b option`::
  something
	(* Look for an item, return NONE if the item doesn't exist *)

`[.kw]#val# lookup : ('a, 'b) map * 'a obj -> 'b`::
  something
	(* look for an item, raise the NotFound exception if it doesn't exist *)

`[.kw]#val# inDomain : (('a, 'b) map * 'a obj) -> bool`::
  something
	(* return true, if the key is in the domain of the map *)

`[.kw]#val# remove : ('a, 'b) map * 'a obj -> ('a, 'b) map * 'b`::
  something
	(* Remove an item, returning new map and value removed.
         * Raises LibBase.NotFound if not found.
	 *)

`[.kw]#val# first : ('a, 'b) map -> 'b option`::
  something

`[.kw]#val# firsti : ('a, 'b) map -> ('a obj * 'b) option`::
  something
	(* return the first item in the map (or NONE if it is empty) *)

`[.kw]#val# numItems : ('a, 'b) map ->  int`::
  something
	(* Return the number of items in the map *)

`[.kw]#val# listItems  : ('a, 'b) map -> 'b list`::
  something

`[.kw]#val# listItemsi : ('a, 'b) map -> ('a obj * 'b) list`::
  something
	(* Return an ordered list of the items (and their keys) in the map. *)

`[.kw]#val# listKeys : ('a, 'b) map -> 'a obj list`::
  something
	(* return an ordered list of the keys in the map. *)

`[.kw]#val# collate : ('b * 'b -> order) -> (('a, 'b) map * ('a, 'b) map) -> order`::
  something
	(* given an ordering on the map's range, return an ordering
	 * on the map.
	 *)

`[.kw]#val# unionWith  : ('b * 'b -> 'b) -> (('a, 'b) map * ('a, 'b) map)`::
  something
	  -> ('a, 'b) map

`[.kw]#val# unionWithi : ('a obj * 'b * 'b -> 'b) -> (('a, 'b) map * ('a, 'b) map)`::
  something
	  -> ('a, 'b) map
	(* return a map whose domain is the union of the domains of the two input
	 * maps, using the supplied function to define the map on elements that
	 * are in both domains.
	 *)

`[.kw]#val# intersectWith  : ('b * 'c -> 'd) -> (('a, 'b) map * ('a, 'c) map)`::
  something
	  -> ('a, 'd) map

`[.kw]#val# intersectWithi : ('a obj * 'b * 'c -> 'd) -> (('a, 'b) map * ('a, 'c) map)`::
  something
	  -> ('a, 'd) map
	(* return a map whose domain is the intersection of the domains of the
	 * two input maps, using the supplied function to define the range.
	 *)

`[.kw]#val# mergeWith : ('b option * 'c option -> 'd option)`::
  something
	  -> (('a, 'b) map * ('a, 'c) map) -> ('a, 'd) map

`[.kw]#val# mergeWithi : ('a obj * 'b option * 'c option -> 'd option)`::
  something
	  -> (('a, 'b) map * ('a, 'c) map) -> ('a, 'd) map
	(* merge two maps using the given function to control the merge. For
	 * each key k in the union of the two maps domains, the function
	 * is applied to the image of the key under the map.  If the function
	 * returns SOME y, then (k, y) is added to the resulting map.
	 *)

`[.kw]#val# app  : ('b -> unit) -> ('a, 'b) map -> unit`::
  something

`[.kw]#val# appi : (('a obj * 'b) -> unit) -> ('a, 'b) map -> unit`::
  something
	(* Apply a function to the entries of the map in map order. *)

`[.kw]#val# map  : ('b -> 'c) -> ('a, 'b) map -> ('a, 'c) map`::
  something

`[.kw]#val# mapi : ('a obj * 'b -> 'c) -> ('a, 'b) map -> ('a, 'c) map`::
  something
	(* Create a new map by applying a map function to the
         * name/value pairs in the map.
         *)

`[.kw]#val# fold  : ('b * 'c -> 'c) -> 'c -> ('a, 'b) map -> 'c`::
  something

`[.kw]#val# foldi : ('a obj * 'b * 'c -> 'c) -> 'c -> ('a, 'b) map -> 'c`::
  something
	(* Apply a folding function to the entries of the map *)

`[.kw]#val# filter  : ('b -> bool) -> ('a, 'b) map -> ('a, 'b) map`::
  something

`[.kw]#val# filteri : ('a obj * 'b -> bool) -> ('a, 'b) map -> ('a, 'b) map`::
  something
	(* Filter out those elements of the map that do not satisfy the
	 * predicate.  The filtering is done in increasing map order.
	 *)

`[.kw]#val# mapPartial  : ('b -> 'c option) -> ('a, 'b) map -> ('a, 'c) map`::
  something

`[.kw]#val# mapPartiali : ('a obj * 'b -> 'c option) -> ('a, 'b) map -> ('a, 'c) map`::
  something
	(* map a partial function over the elements of a map in increasing
	 * map order.
	 *)

`[.kw]#val# exists : ('b -> bool) -> ('a, 'b) map -> bool`::
  something

`[.kw]#val# existsi : ('a obj * 'b -> bool) -> ('a, 'b) map -> bool`::
  something
	(* check the elements of a map with a predicate and return true if
	 * any element satisfies the predicate. Return false otherwise.
	 * Elements are checked in key order.
	 *)

`[.kw]#val# all : ('b -> bool) -> ('a, 'b) map -> bool`::
  something

`[.kw]#val# alli : ('a obj * 'b -> bool) -> ('a, 'b) map -> bool`::
  something
	(* check the elements of a map with a predicate and return true if
	 * they all satisfy the predicate. Return false otherwise.  Elements
	 * are checked in key order.
	 *)

== See Also

link:str-hash-cons.html[`HashCons`],
link:hash-cons-lib.html[__The HashCons Library__]
