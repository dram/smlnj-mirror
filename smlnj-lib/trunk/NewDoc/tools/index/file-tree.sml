(* file-tree.sml
 *
 * COPYRIGHT (c) 2020 The Fellowship of SML/NJ (http://www.smlnj.org)
 * All rights reserved.
 *
 * The file tree represents the structure of the documentation as a three-level
 * tree.  This structure is generated by walking over the documentation source.
 *)

structure FileTree : sig

  (* the root file of the documentation *)
    datatype t = ROOT of {
	stem : string,		(* should be "index" *)
	libs : library list	(* list of libraries *)
      }

    and library = LIB of {
	dir : string,		(* directory relative to the root of the documentation *)
	stem : string,		(* file-name stem; e.g., "json-lib" *)
	title : string,		(* title of page *)
	tutorial : page option,	(* optional tutorial page *)
	pages : page list	(* list of manual pages for library *)
      }

    and page = PAGE of {
	dir : string,		(* directory relative to the root of the documentation *)
	stem : string,		(* file-name stem; e.g., "str-JSON" *)
	title : string,		(* title of page *)
	kind : string,		(* specifies the kind of the main module; will be
				 * one of "signature", "structure", or "functor"
				 *)
	name : string		(* the main module name *)
      }

  (* test equality by name *)
    val sameLib : library * library -> bool
    val samePage : page * page -> bool

  (* is a page in a library? *)
    val inLibrary : library -> page -> bool

  (* apply the functions to the nodes of the tree *)
    val app : {
	    root : t -> unit,
	    lib : t * library -> unit,
	    page : t * library * page -> unit
	  } -> t -> unit

  (* do a walk over the tree; for interior nodes (root and libraries),
   * the function is called with "true" on entry and with "false" after
   * visiting the node's kids.
   *)
    val walk : {
	    root : bool * t -> unit,
	    lib : bool * t * library -> unit,
	    page : t * library * page -> unit
	  } -> t -> unit

  (* convert between JSON objects and the file tree datatypes *)
    val fromJSON : JSON.value -> t
    val toJSON : t -> JSON.value

  end = struct

    structure U = JSONUtil

    datatype t = ROOT of {
	stem : string,
	libs : library list
      }

    and library = LIB of {
	dir : string,
	stem : string,
	title : string,
	tutorial : page option,
	pages : page list
      }

    and page = PAGE of {
	dir : string,
	stem : string,
	title : string,
	kind : string,
	name : string
      }

    fun sameLib (LIB lib1, LIB lib2) = (#dir lib1 = #dir lib2)

    fun samePage (PAGE p1, PAGE p2) =
	  (#dir p1 = #dir p2) andalso (#stem p1 = #stem p2)

    fun inLibrary (LIB lib) (PAGE p) = (#dir lib = #dir p)

    fun app {root, lib, page} (ft as ROOT{libs, ...}) = let
	  fun walkLib (l as LIB{tutorial, pages, ...}) = (
		lib (ft, l);
		Option.app (fn p => page(ft, l, p)) tutorial;
		List.app (fn p => page(ft, l, p)) pages)
	  in
	    root ft;
	    List.app walkLib libs
	  end

    fun walk {root, lib, page} (ft as ROOT{libs, ...}) = let
	  fun walkLib (l as LIB{tutorial, pages, ...}) = (
		lib (true, ft, l);
		Option.app (fn p => page(ft, l, p)) tutorial;
		List.app (fn p => page(ft, l, p)) pages;
		lib (false, ft, l))
	  in
	    root (true, ft);
	    List.app walkLib libs;
	    root (false, ft)
	  end

    datatype value = datatype JSON.value

    fun fromJSON root = let
	  fun jsonToLib obj = let
		val get = U.lookupField obj
		in
		  LIB{
		      dir = U.asString(get "dir"),
		      stem = U.asString(get "stem"),
		      title = U.asString(get "title"),
		      tutorial = (case U.findField obj "tutorial"
			 of NONE => NONE
			  | SOME NULL => NONE
			  | SOME obj => SOME(jsonToPage obj)
			(* end case *)),
		      pages = U.arrayMap jsonToPage (get "pages")
		    }
		end
	  and jsonToPage obj = let
		val get = U.lookupField obj
		in
		  PAGE{
		      dir = U.asString(get "dir"),
		      stem = U.asString(get "stem"),
		      title = U.asString(get "title"),
		      kind = U.asString(get "kind"),
		      name = U.asString(get "name")
		    }
		end
	  val get = U.lookupField root
	  in
	    ROOT{
		stem = U.asString(get "stem"),
		libs = U.arrayMap jsonToLib (get "libraries")
	      }
	  end

    fun toJSON (ROOT{stem, libs}) = let
	  fun libToJSON (LIB{dir, stem, title, tutorial, pages}) = OBJECT[
		  ("dir", STRING dir),
		  ("stem", STRING stem),
		  ("title", STRING title),
		  ("tutorial", case tutorial of SOME p => pageToJSON p | _ => NULL),
		  ("pages", ARRAY(map pageToJSON pages))
		]
	  and pageToJSON (PAGE{dir, stem, title, kind, name}) = OBJECT[
		  ("dir", STRING dir),
		  ("stem", STRING stem),
		  ("title", STRING title),
		  ("kind", STRING kind),
		  ("name", STRING name)
		]
	  in
	    OBJECT[
		("stem", STRING stem),
		("libraries", ARRAY(map libToJSON libs))
	      ]
	  end

  end
