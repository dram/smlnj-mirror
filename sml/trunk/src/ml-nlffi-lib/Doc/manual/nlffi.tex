% -*- latex -*-
\documentclass[titlepage,letterpaper]{article}
\usepackage{times}
\usepackage{hyperref}

\marginparwidth0pt\oddsidemargin0pt\evensidemargin0pt\marginparsep0pt
\topmargin0pt\advance\topmargin by-\headheight\advance\topmargin by-\headsep
\textwidth6.7in\textheight9.1in
\columnsep0.25in

\newcommand{\smlmj}{110}
\newcommand{\smlmn}{46}

\author{Matthias Blume \\
Toyota Technological Institute at Chicago}

\title{{\bf NLFFI}\\
A new SML/NJ Foreign-Function Interface \\
{\it\small (for SML/NJ version \smlmj.\smlmn~and later)} \\
User Manual}

\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 3pt minus 2pt}

\newcommand{\nt}[1]{{\it #1}}
\newcommand{\tl}[1]{{\underline{\bf #1}}}
\newcommand{\ttl}[1]{{\underline{\tt #1}}}
\newcommand{\ar}{$\rightarrow$\ }
\newcommand{\vb}{~$|$~}

\begin{document}

\bibliographystyle{alpha}

\maketitle

\pagebreak

\tableofcontents

\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

Introduce...

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The C Library}

The C library...

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Translation conventions}

The {\tt ml-nlffigen} tool generates one ML structure for each
exported C definition.  In particular, there is one structure per
external variable, function, {\tt typedef}, {\tt struct}, {\tt union},
and {\tt enum}.
Each generated ML structure contains the ML type and values necessary
to manipulate the corresponding C item.

\subsection{External variables}

An external C variable $v$ is represented by an ML structure {\tt
  G\_}$v$.  This structure contains one type and three values, all
with fixed names:

\begin{description}\setlength{\itemsep}{0pt}
\item[{\tt type t}] is the witness type for the {\tt obj}
  value that represents $v$.
\item[{\tt val typ}] is the run-time type information corresponding to
  type {\tt t}.  The ML type of {\tt typ} is {\tt t C.T.typ}.
\item[{\tt val obj}] is a function that returns the ML value
  representing the C object (i.e., the memory location) referred to by
  $v$.  Depending on whether or not $v$ was declared {\tt const}, the
  type of {\tt obj} is either {\tt unit -> (t, C.ro) C.obj} or {\tt
    unit -> (t, C.rw) C.obj}.  The result of {\tt obj()} is
  ``heavy-weight,'' i.e., it implicitly carries run-time type
  information.
\item[{\tt val obj'}] is analogous to {\tt val obj}, the only
  difference being that its result is ``light-weight,'' i.e., without
  run-time type information.  The type of {\tt val obj'} is
  either {\tt unit -> (t, C.ro) C.obj} or {\tt unit -> (t, C.rw) C.obj}.
\end{description}

\paragraph*{Examples}:

\begin{center}
\begin{tabular}{c|c}
C declaration & signature of ML-side representation \\ \hline\hline
{\tt extern int i;}
&
\begin{minipage}{4in}
\begin{verbatim}

structure G_i : sig
    type t   = C.sint
    val typ  : t C.T.typ
    val obj  : unit -> (t, C.rw) C.obj
    val obj' : unit -> (t, C.rw) C.obj'
end

\end{verbatim}
\end{minipage}
\\ \hline
{\tt extern const double d;}
&
\begin{minipage}{4in}
\begin{verbatim}

structure G_d : sig
    type t   = C.double
    val typ  : t C.T.typ
    val obj  : unit -> (t, C.ro) C.obj
    val obj' : unit -> (t, C.ro) C.obj'
end

\end{verbatim}
\end{minipage}
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\appendix
%\input{A-syntax}

\bibliography{blume,appel,ml}

\end{document}
