(*
 * This file was automatically generated by MDGen
 * from the machine description file "sparc/sparc.md".
 *)


signature SPARCCELLS =
sig
   datatype mycellkind =
     UNKNOWN
   | MEM
   | CTRL
   | PSR
   | CC
   | Y
   | FP
   | GP
   | FSR
   withtype cellset = (int list * int list * int list)
   include CELLS_BASIS where type cellkind = mycellkind
   val showPSR : cell -> string
   val showCC : cell -> string
   val showY : cell -> string
   val showFP : cell -> string
   val showGP : cell -> string
   val showFSR : cell -> string
   val addGP : (cell * cellset) -> cellset
   val addFP : (cell * cellset) -> cellset
   val addPSR : (cell * cellset) -> cellset
   val psr : cell
   val fasmTmp : cell
   val y : cell
   val stackptrR : cell
   val asmTmpR : cell
   val fsr : cell
   val linkReg : cell
   val zeroReg : cellkind -> cell option
   val toString : cellkind -> cell -> string
   val addCell : cellkind -> cell * cellset -> cellset
   val rmvCell : cellkind -> cell * cellset -> cellset
   val addReg : cell * cellset -> cellset
   val rmvReg : cell * cellset -> cellset
   val addFreg : cell * cellset -> cellset
   val rmvFreg : cell * cellset -> cellset
   val getCell : cellkind -> cellset -> cell list
   val updateCell : cellkind -> cellset * cell list -> cellset
   val empty : cellset
   val cellsetToString : cellset -> string
   val cellsetToString' : (cell -> cell) -> cellset -> string
   val cellsetToCells : cellset -> cell list
end

structure SparcCells : SPARCCELLS =
struct
   datatype mycellkind =
     UNKNOWN
   | MEM
   | CTRL
   | PSR
   | CC
   | Y
   | FP
   | GP
   | FSR
   withtype cellset = (int list * int list * int list)
   exception SparcCells
   structure SL = SortedList
   fun error msg = MLRiscErrorMsg.error("SparcCells",msg)
   val cellkindToString = (fn PSR => "PSR"
                            | CC => "CC"
                            | Y => "Y"
                            | FP => "FP"
                            | GP => "GP"
                            | FSR => "FSR"
                            | MEM => "MEM"
                            | CTRL => "CTRL"
                            | UNKNOWN => "UNKNOWN"
                          )
   structure MyCellsBasis = CellsBasisFn
      (type cellkind = mycellkind
       exception Cells = SparcCells
       val unknown = UNKNOWN
       val cellkindToString = cellkindToString
       val INT = GP
       val FLOAT = FP
       val firstPseudo = 256
       val kinds = [PSR, CC, Y, FP, GP, FSR, MEM, CTRL]
       val physical = [{from=65, to=65, kind=PSR}, {from=67, to=0, kind=CC}, {from=64, to=64, kind=Y}, {from=32, to=63, kind=FP}, {from=0, to=31, kind=GP}, {from=66, to=66, kind=FSR}]
      )

   open MyCellsBasis
   val offsetPSR = 65
  and offsetCC = 67
  and offsetY = 64
  and offsetFP = 32
  and offsetGP = 0
  and offsetFSR = 66
  and cellnames = ["PSR", "CC", "Y", "FP", "GP", "FSR"]
  and cellsetnames = ["GP", "FP", "PSR"]
   val psr = (0 + offsetPSR)
   val fasmTmp = (30 + offsetFP)
   val y = (0 + offsetY)
   val stackptrR = (14 + offsetGP)
   val asmTmpR = (10 + offsetGP)
   val fsr = (0 + offsetFSR)
   val linkReg = (15 + offsetGP)

   fun showPSR r = let
          val r = (if (r <= 65)
                then (r - 65)
                else r)
       in ((fn 0 => "%psr"
             | n => ("%psr" ^ (Int.toString n))
           ) r)
       end

   and showCC r = let
          val r = (if (r <= 0)
                then (r - 67)
                else r)
       in ((fn _ => "%cc"
           ) r)
       end

   and showY r = let
          val r = (if (r <= 64)
                then (r - 64)
                else r)
       in ((fn _ => "%y"
           ) r)
       end

   and showFP r = let
          val r = (if (r <= 63)
                then (r - 32)
                else r)
       in ((fn f => ("%f" ^ (Int.toString f))
           ) r)
       end

   and showGP r = ((fn r => (if (r < 8)
                          then ("%g" ^ (Int.toString r))
                          else (if (r = 14)
                             then "%sp"
                             else (if (r < 16)
                                then ("%o" ^ (Int.toString (r - 8)))
                                else (if (r < 24)
                                   then ("%l" ^ (Int.toString (r - 16)))
                                   else (if (r = 30)
                                      then "%fp"
                                      else (if (r < 32)
                                         then ("%i" ^ (Int.toString (r - 24)))
                                         else ("%r" ^ (Int.toString r))))))))
                   ) r)
   and showFSR r = let
          val r = (if (r <= 66)
                then (r - 66)
                else r)
       in ((fn 0 => "%fsr"
             | n => ("%fsr" ^ (Int.toString n))
           ) r)
       end

   and toString PSR = showPSR
     | toString CC = showCC
     | toString Y = showY
     | toString FP = showFP
     | toString GP = showGP
     | toString FSR = showFSR
     | toString MEM = (fn r => ("m" ^ (Int.toString r))
                      )
     | toString CTRL = (fn r => ("ctrl" ^ (Int.toString r))
                       )
     | toString UNKNOWN = (fn r => ("unknown" ^ (Int.toString r))
                          )
   val empty = ([], [], [])

   fun addCell GP = addGP
     | addCell FP = addFP
     | addCell CC = addGP
     | addCell PSR = addPSR
     | addCell _ = (error "addCell")
   and rmvCell GP = rmvGP
     | rmvCell FP = rmvFP
     | rmvCell CC = rmvGP
     | rmvCell PSR = rmvPSR
     | rmvCell _ = (error "rmvCell")
   and getCell GP = getCellGP
     | getCell FP = getCellFP
     | getCell PSR = getCellPSR
     | getCell _ = (error "getCell")
   and updateCell GP = updateCellGP
     | updateCell FP = updateCellFP
     | updateCell PSR = updateCellPSR
     | updateCell _ = (error "updateCell")
   and addGP (r, (setGP, setFP, setPSR)) = ((SL.enter (r, setGP)), setFP, setPSR)
   and addFP (r, (setGP, setFP, setPSR)) = (setGP, (SL.enter (r, setFP)), setPSR)
   and addPSR (r, (setGP, setFP, setPSR)) = (setGP, setFP, (SL.enter (r, setPSR)))
   and rmvGP (r, (setGP, setFP, setPSR)) = ((SL.rmv (r, setGP)), setFP, setPSR)
   and rmvFP (r, (setGP, setFP, setPSR)) = (setGP, (SL.rmv (r, setFP)), setPSR)
   and rmvPSR (r, (setGP, setFP, setPSR)) = (setGP, setFP, (SL.rmv (r, setPSR)))
   and getCellGP (setGP, setFP, setPSR) = setGP
   and getCellFP (setGP, setFP, setPSR) = setFP
   and getCellPSR (setGP, setFP, setPSR) = setPSR
   and updateCellGP ((setGP, setFP, setPSR), r) = (r, setFP, setPSR)
   and updateCellFP ((setGP, setFP, setPSR), r) = (setGP, r, setPSR)
   and updateCellPSR ((setGP, setFP, setPSR), r) = (setGP, setFP, r)
   and cellsetToString (setGP, setFP, setPSR) = (printTuple (cellsetnames, [((printSet showGP) setGP), ((printSet showFP) setFP), ((printSet showPSR) setPSR)]))
   and cellsetToString' regmap = (fn (setGP, setFP, setPSR) => (printTuple (cellsetnames, [((printSet showGP) ((map regmap) setGP)), ((printSet showFP) ((map regmap) setFP)), ((printSet showPSR) ((map regmap) setPSR))]))
                                 )
   and cellsetToCells (setGP, setFP, setPSR) = (setGP @ (setFP @ setPSR))
   val addReg = addGP
   val addFreg = addFP
   val rmvReg = rmvFP
   val rmvFreg = rmvFP

   fun zeroReg GP = (SOME (0 + offsetGP))
     | zeroReg _ = NONE
end

