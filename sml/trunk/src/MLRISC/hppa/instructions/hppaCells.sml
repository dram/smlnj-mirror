(*
 * This file was automatically generated by MDGen
 * from the machine description file "hppa/hppa.md".
 *)


signature HPPACELLS =
sig
   datatype mycellkind =
     UNKNOWN
   | MEM
   | CTRL
   | CC
   | CR
   | GP
   | FP
   withtype cellset = (int list * int list)
   include CELLS_BASIS where type cellkind = mycellkind
   val showCC : register -> string
   val showCR : register -> string
   val showGP : register -> string
   val showFP : register -> string
   val newCC : unit -> register
   val newCR : unit -> register
   val newGP : unit -> register
   val newFP : unit -> register
   val addGP : (register * cellset) -> cellset
   val addFP : (register * cellset) -> cellset
   val returnPtr : register
   val asmTmpR : register
   val stackptrR : register
   val fasmTmp : register
   val sar : register
   val zeroReg : cellkind -> register option
   val toString : cellkind -> register -> string
   val addCell : cellkind -> register * cellset -> cellset
   val addReg : register * cellset -> cellset
   val addFreg : register * cellset -> cellset
   val getCell : cellkind -> cellset -> register list
   val updateCell : cellkind -> cellset * register list -> cellset
   val empty : cellset
   val cellsetToString : cellset -> string
   val cellsetToString' : (register -> register) -> cellset -> string
   val cellsetToRegs : cellset -> register list
end

structure HppaCells : HPPACELLS =
struct
   datatype mycellkind =
     UNKNOWN
   | MEM
   | CTRL
   | CC
   | CR
   | GP
   | FP
   withtype cellset = (int list * int list)
   exception HppaCells
   structure SL = SortedList
   fun error msg = MLRiscErrorMsg.error("HppaCells",msg)
   val cellkindToString = (fn CC => "CC"
                            | CR => "CR"
                            | GP => "GP"
                            | FP => "FP"
                            | MEM => "MEM"
                            | CTRL => "CTRL"
                            | UNKNOWN => "UNKNOWN"
                          )
   structure MyCellsBasis = CellsBasisFn
      (type cellkind = mycellkind
       exception Cells = HppaCells
       val unknown = UNKNOWN
       val cellkindToString = cellkindToString
       val INT = GP
       val FLOAT = FP
       val firstPseudo = 256
       val kinds = [CC, CR, GP, FP, MEM, CTRL]
       val physical = [{from=96, to=0, kind=CC}, {from=64, to=95, kind=CR}, {from=0, to=31, kind=GP}, {from=32, to=63, kind=FP}]
      )

   open MyCellsBasis
   val offsetCC = 96
  and offsetCR = 64
  and offsetGP = 0
  and offsetFP = 32
  and newCC = (newCell CC)
  and newCR = (newCell CR)
  and newGP = (newCell GP)
  and newFP = (newCell FP)
  and cellnames = ["CC", "CR", "GP", "FP"]
  and cellsetnames = ["GP", "FP"]
   val returnPtr = (2 + offsetGP)
   val asmTmpR = (29 + offsetGP)
   val stackptrR = (30 + offsetGP)
   val fasmTmp = (31 + offsetFP)
   val sar = (11 + offsetCR)

   fun showCC r = let
          val r = (if (r <= 0)
                then (r - 96)
                else r)
       in ((fn _ => "cc"
           ) r)
       end

   and showCR r = let
          val r = (if (r <= 95)
                then (r - 64)
                else r)
       in ((fn cr => ("%cr" ^ (Int.toString cr))
           ) r)
       end

   and showGP r = ((fn r => ("%r" ^ (Int.toString r))
                   ) r)
   and showFP r = let
          val r = (if (r <= 63)
                then (r - 32)
                else r)
       in ((fn f => ("%f" ^ (Int.toString f))
           ) r)
       end

   and toString CC = showCC
     | toString CR = showCR
     | toString GP = showGP
     | toString FP = showFP
     | toString MEM = (fn r => ("m" ^ (Int.toString r))
                      )
     | toString CTRL = (fn r => ("ctrl" ^ (Int.toString r))
                       )
     | toString UNKNOWN = (fn r => ("unknown" ^ (Int.toString r))
                          )
   val empty = ([], [])

   fun addCell CC = addGP
     | addCell GP = addGP
     | addCell FP = addFP
     | addCell _ = (error "addCell")
   and getCell GP = getCellGP
     | getCell FP = getCellFP
     | getCell _ = (error "getCell")
   and updateCell GP = updateCellGP
     | updateCell FP = updateCellFP
     | updateCell _ = (error "updateCell")
   and addGP (r, (setGP, setFP)) = ((SL.enter (r, setGP)), setFP)
   and addFP (r, (setGP, setFP)) = (setGP, (SL.enter (r, setFP)))
   and getCellGP (setGP, setFP) = setGP
   and getCellFP (setGP, setFP) = setFP
   and updateCellGP ((setGP, setFP), r) = (r, setFP)
   and updateCellFP ((setGP, setFP), r) = (setGP, r)
   and cellsetToString (setGP, setFP) = (printTuple (cellsetnames, [((printSet showGP) setGP), ((printSet showFP) setFP)]))
   and cellsetToString' regmap = (fn (setGP, setFP) => (printTuple (cellsetnames, [((printSet showGP) ((map regmap) setGP)), ((printSet showFP) ((map regmap) setFP))]))
                                 )
   and cellsetToRegs (setGP, setFP) = (setGP @ setFP)
   val addReg = addGP
   val addFreg = addFP

   fun zeroReg GP = (SOME (0 + offsetGP))
     | zeroReg FP = (SOME (0 + offsetFP))
     | zeroReg _ = NONE
end

