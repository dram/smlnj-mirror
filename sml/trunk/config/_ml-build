#!@SHELL@

BIN_DIR=@BINDIR@

SML=$BIN_DIR/sml
LINK=$BIN_DIR/.link-sml

thisscript=$0

xx=$$
smlfile=$xx-export.sml
cmfile=$xx-export.cm
listfile=$xx-BOOTLIST
mlscript=$xx-mlscript.sml

dulist=''

trap 'rm -rf `find . -name $smlfile` $cmfile $listfile $mlscript' 0 1 2 3 15

usage() {
    echo ${thisscript}: $*
    echo Usage: $thisscript root-group main-function heapfile
    exit 1
}

while [ $# != 0 ] ; do
    case $1 in
    -D*|-U*)
	dulist="$dulist $1"
	shift
	;;
    *)
	break
	;;
    esac
done

if [ $# != 3 ] ; then
    usage wrong number of arguments
fi

root=$1
main=$2
heap=$3

rare=XYZ_XXX_0123

cat >$smlfile <<EOF
structure ${rare} = struct val _ = SMLofNJ.exportFn ("${heap}", ${main}) end
EOF

cat >$cmfile <<EOF
Group structure ${rare} is \$/basis.cm ${root} ${smlfile}
EOF

cat >$mlscript <<EOF
ignore (OS.Process.exit ((case CM.mk_standalone NONE
                                   { project = "${root}",
				     wrapper = "${cmfile}",
				     target = "$heap" } of
   NONE => (print "Compilation failed.\n"; OS.Process.failure)
 | SOME [] => (print "Heap was already up-to-date.\n";
               OS.Process.success)
 | SOME l => let val s = TextIO.openOut "${listfile}"
                 fun wr str = TextIO.output (s, str ^ "\n")
		 val n = length l
		 fun maxsz (s, n) = Int.max (size s, n)
		 val m = foldl maxsz 0 l
   in wr (concat ["%", Int.toString n, " ", Int.toString m]);
      app wr l;
      TextIO.closeOut s;
      OS.Process.system "${LINK} @SMLboot=${listfile}"
   end)
   handle _ => OS.Process.failure))
EOF

# Provide $smlnj/cm.cm as a command-line argument just to be absolutely
# sure that structure CM is available. (Under normal circumstances it
# is already available -- even without any command line arguments.)
$SML '$smlnj/cm.cm' $dulist $mlscript

exit $?
