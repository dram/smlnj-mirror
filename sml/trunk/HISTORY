This is the HISTORY file for the Yale SML/NJ CVS repository.

An entry should be made for _every_ commit to the repository.
The entries in this file will be used when creating the README
for new versions, so keep that in mind when writing the
description.

The form of an entry should be:

Name: 
Date:
Tag: <post-commit CVS tag>
Description:
----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/07/22 23:30:00 JST
Tag: blume-20000722-urlupdate
Description:

Changed BOOT and config/srcarchiveurl to point to BL server:

    ftp://ftp.research.bell-labs.com/dist/smlnj/working/110.29/

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/07/18 18:00:00 JST
Tag: blume-20000718-Version_110_29
Description:

1. Updated src/compiler/TopLevel/main/version.sml to version 110.29

2. Updated config/version to 110.29

3. Updated config/srcarchiveurl

3. New boot files!
   ftp://ftp.cs.princeton.edu/pub/people/blume/sml/110.29-autofetch

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/07/11 13:58:00 JST
Tag: blume-20000711-doctypo
Description:

Fixed a few typos in CM manual.

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/06/15 00:38:00
Tag: leunga-20000704-sparc-x86

1. x86 peephole improvement sp += k; sp -= k => nop  [from John]
2. fix to x86 RET bug [found by Dan Grossman] 
3. sparc assembly bug fix for ticc instructions [found by Fermin]

   Affects c-- and moby only

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/07/04 15:26:00
Tag: blume-20000704-trigger
Description:

1. Improvements to CM manual.
2. SMLofNJ.Internals.BTrace.trigger reinstated as an alternative way
   of getting a back-trace.  The function, when called, raises an
   internal exception which explicitly carries the full back-trace history,
   so it is unaffected by any intervening handle-raise pairs ("trivial"
   or not).  The interactive loop will print that history once it arrives
   at top level.
   Short of having all exceptions implicitly carry the full history, the
   recommended way of using this facility is:
     - compile your program with instrumentation "on"
     - run it, when it raises an exception, look at the history
     - if the history is "cut off" because of some handler, go and modify
       your program so that it explicitly calls BTrace.trigger
     - recompile (still instrumented), and rerun; look at the full history

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/07/03 15:36:00 JST
Tag: blume-20000702-manual
Description:

Small corrections and updates to CM manual.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/06/29 16:04:00 JST
Tag: blume-20000629-yacctool
Description:

Changes:

1. Class "mlyacc" now takes separate arguments to pass options to
   generated .sml- and .sig-files independently.
2. Corresponding CM manual updates.
3. BTrace module now also reports call sites.  (However, for loop clusters
   it only shows from where the cluster was entered.)  There are associated
   modifications to core.sml, internals.{sig,sml}, btrace.sml, and btimp.sml.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/06/27 16:51:00 JST
Tag: blume-20000627-noweb
Description:

Changes:

 1. Implemented "subdir" and "witness" options for noweb tool.
    This caused some slight internal changes in CM's tool implementation.
 2. Fixed bug in "tool plugin" mechanism.  This is essentially cleaning
    some remaining issues from earlier path anchor changes.
 3. Updated CM manual accordingly.

 4. Changed implementation of back-tracing so that I now consider it
    ready for prime-time.

    In particular, you don't have to explicitly trigger the back-trace
    anymore.  Instead, if you are running BTrace-instrumented code and
    there is an uncaught exception (regardless of whether or not it was
    raised in instrumented code), the top-level evalloop will print
    the back-trace.

    Features:

      - Instrumented and uninstrumented code work together seemlessly.
        (Of course, uninstrumented code is never mentioned in actual
         back-traces.)

      - Asymptotic time- and space-complexity of instrumented code is
        equal to that of uninstrumented code.  (This means that
        tail-recursion is preserved by the instrumentation phase.)

      - Modules whose code has been instrumented in different sessions
        work together without problem.

      - There is no penalty whatsoever on uninstrumented code.

      - There is no penalty on "raise" expressions, even in
        instrumented code.

    A potential bug (or perhaps it is a feature, too):

      A back-trace reaches no further than the outermost instrumented
      non-trivial "raise".  Here, a "trivial" raise is one that is the
      sole RHS of a "handle" rule.  Thus, back-traces reach trough

           <exp> handle e => raise e

      and even

           <exp> handle Foo => raise Bar

      and, of course, through

           <exp> handle Foo => ...

     if the exception was not Foo.

     Back-traces always reach right through any un-instrumented code
     including any of its "handle" expressions, trivial or not.

   To try this out, do the following:

     - Erase all existing binfiles for your program.
       (You may keep binfiles for those modules where you think you
        definitely don't need back-tracing.)
     - Turn on back-trace instrumentation:
          SMLofNJ.Internals.BTrace.mode (SOME true);
     - Recompile your program.  (I.e., run "CM.make" or "use".)
     - You may now turn instrumentation off again (if you want):
          SMLofNJ.Internals.BTrace.mode (SOME false);
     - Run your program as usual.  If it raises an exception that
       reaches the interactive toplevel, then a back-trace will
       automatically be printed.  After that, the toplevel loop
       will print the exception history as usual.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/06/26 09:56:46 JST
Tag: blume-20000626-setup
Description:

CM: - setup-parameter to "sml" added; this can be used to run arbitrary
      ML code before and after compiling a file (e.g., to set compiler
      flags)

Compiler: - improved btrace API (in core.sml, internals.{sig,sml})
          - associated changes to btrace.sml (BTrace instrumentation pass)
          - cleaner implementation of btimp.sml (BTrace tracing and report
            module)

CM manual: * new path encoding documented
           * description of setup-parameter to "sml" added

The biggest user-visible change to back-tracing is that it is no
longer necessary to compile all traced modules within the same
session.  (This was a real limitation.)

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/06/24 12:40:00 JST
Tag: blume-20000624-startup
Description:

Fixes startup slowdown problem.  (I was calling SrcPath.sync a _tad_
bit too often -- to put it mildly. :)

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/06/23 18:20:00 JST
Tag: blume-20000623-btrace
Description:

This updates adds a backtrace facility to aid programmers in debugging
their programs.  This involves the following changes:

1. Module system/smlnj/init/core.sml (structure _Core) now has hooks for
   keeping track of the current call stack.  When programs are compiled
   in a special mode, the compiler will insert calls to these hooks
   into the user program.
   "Hook" means that it is possible for different implementations of
   back-tracing to register themselves (at different times).

2. compiler/MiscUtil/profile/btrace.sml implements the annotation phase
   as an Absyn.dec->Absyn.dec rewrite.  Normally this phase is turned off.
   It can be turned on using this call:
     SMLofNJ.Internals.BTrace.mode (SOME true);
   Turning it off again:
     SMLofNJ.Internals.BTrace.mode (SOME false);
   Querying the current status:
     SMLofNJ.Internals.BTrace.mode NONE;
   Annotated programs are about twice as big as normal ones, and they
   run a factor of 2 to 4 slower with a dummy back-trace plugin (one
   where all hooks do nothing).  The slowdown with a plugin that is
   actually useful (such as the one supplied by default) is even greater,
   but in the case of the default plugin it is still only an constant
   factor (amortized).

3. system/Basis/Implementation/NJ/internals.{sig,sml} have been augmented
   with a sub-structure BTrace for controlling back-tracing.  In particular,
   the above-mentioned function "mode" controls whether the annotation
   phase is invoked by the compiler.  Another important function is
   "trigger": when called it aborts the current execution and causes
   the top-level loop to print a full back-trace.

4. compiler/MiscUtil/profile/btimp.sml is the current default plugin
   for back-tracing.  It keeps track of the dynamic call stack and in
   addition to that it keeps a partial history at each "level" of that
   stack.  For example, if a tail-calls b, b tail-calls c, and c tail-calls
   d and b (at separate times, dynamically), then the report will show:

   GOTO   d
         /c
   GOTO  \b
   CALL   a

   This shows that there was an initial non-tail call of a, then a
   tail-call to b or c, looping behavior in a cluster of functions that
   consist of b and c, and then a goto from that cluster (i.e., either from
   b or from c) to d.

   Note that (depending on the user program) the amount of information
   that the back-trace module has to keep track of at each level is bounded
   by a constant.  Thus, the whole implementation has the same asymptotical
   complexity as the original program (both in space and in time).

5. compiler/TopLevel/interact/evalloop.sml has been modified to
   handle the special exception SMLofNJ.Internals.BTrace.BTrace
   which is raised by the "trigger" function mentioned above.

Notes on usage:

- Annotated code works well together with unannotated code:
Unannotated calls simply do not show up at all in the backtrace.

- It is not a good idea to let modules that were annotated during
different sessions run at the same time.  This is because the compiler
chooses small integers to identify individual functions, and there
will be clashes if different modules were compiled in separate sessions.
(Nothing will crash, and you will even be told about the clashes, but
back-trace information will in general not be useful.)

- Back-tracing can be confused by callcc and capture.

- The only way of getting a back-trace right now is to explicitly
invoke the "trigger" function from your user program.  Eventually, we
should make every exception carry back-trace information (if
available).  But since this creates more overhead at "raise"-time
(similar to the current exnHistory overhead), I have not yet
implemented this.  (The implementation will be rather easy.)  With
exceptions carrying back-trace information, this facility will be even
more useful because users don't need to modify their programs...

- While it is possible to compile the compiler with back-trace
annotations turned on (I did it to get some confidence in
correctness), you must make absolutely sure that core.sml and
btimp.sml are compiled WITHOUT annotation!  (core.sml cannot actually
be compiled with annotation because there is no core access yet, but
if you compile btimp.sml with annotation, then the system will go into
an infinite recursion and crash.)
Since CM currently does not know about BTrace, the only way to turn
annotations on and off for different modules of the compiler is to
interrupt CMB.make, change the settings, and re-invoke it.  Of course,
this is awkward and clumsy.

Sample sessions:

Standard ML of New Jersey v110.28.1 [FLINT v1.5], June 5, 2000
- SMLofNJ.Internals.BTrace.mode (SOME true);
[autoloading]
[autoloading done]
val it = false : bool
- structure X = struct
-     fun main n = let
-         fun a (x, 0) = d x
-           | a (x, n) = b (x, n - 1)
-         and b (x, n) = c (x, n)
-         and c (x, n) = a (x, n)
-         and d x = e (x, 3)
-         and e (x, 0) = f x
-           | e (x, n) = e (x, n - 1)
-         and f 0 = SMLofNJ.Internals.BTrace.trigger ()
-           | f n = n * g (n - 1)
-         and g n = a (n, 3)
-     in
-         f n
-     end
- end;
structure X : sig val main : int -> int end
- X.main 3;
*** BACK-TRACE ***
GOTO   stdIn:4.2-13.20: X.main[2].f
GOTO-( stdIn:4.2-13.20: X.main[2].e
GOTO   stdIn:4.2-13.20: X.main[2].d
     / stdIn:4.2-13.20: X.main[2].a
     | stdIn:4.2-13.20: X.main[2].b
GOTO-\ stdIn:4.2-13.20: X.main[2].c
CALL   stdIn:4.2-13.20: X.main[2].g
GOTO   stdIn:4.2-13.20: X.main[2].f
GOTO-( stdIn:4.2-13.20: X.main[2].e
GOTO   stdIn:4.2-13.20: X.main[2].d
     / stdIn:4.2-13.20: X.main[2].a
     | stdIn:4.2-13.20: X.main[2].b
GOTO-\ stdIn:4.2-13.20: X.main[2].c
CALL   stdIn:4.2-13.20: X.main[2].g
GOTO   stdIn:4.2-13.20: X.main[2].f
GOTO-( stdIn:4.2-13.20: X.main[2].e
GOTO   stdIn:4.2-13.20: X.main[2].d
     / stdIn:4.2-13.20: X.main[2].a
     | stdIn:4.2-13.20: X.main[2].b
GOTO-\ stdIn:4.2-13.20: X.main[2].c
CALL   stdIn:4.2-13.20: X.main[2].g
GOTO   stdIn:4.2-13.20: X.main[2].f
CALL   stdIn:2.15-17.4: X.main[2]
- 

(Note that because of a FLINt bug the above code currently does not
compile without BTrace turned on.)

Here is another example, using my modified Tiger compiler:

Standard ML of New Jersey v110.28.1 [FLINT v1.5], June 5, 2000
- SMLofNJ.Internals.BTrace.mode (SOME true);
[autoloading]
[autoloading done]
val it = false : bool
- CM.make "sources.cm";
[autoloading]
...
[autoloading done]
[scanning sources.cm]
[parsing (sources.cm):parse.sml]
[creating directory CM/SKEL ...]
[parsing (sources.cm):tiger.lex.sml]
...
[wrote CM/sparc-unix/semant.sml]
[compiling (sources.cm):main.sml]
[wrote CM/sparc-unix/main.sml]
[New bindings added.]
val it = true : bool
- Main.compile ("../testcases/merge.tig", "foo.out");
*** BACK-TRACE ***
CALL   lib/semant.sml:99.2-396.21: SemantFun[2].transExp.trvar
CALL   lib/semant.sml:99.2-396.21: SemantFun[2].transExp.trexp
CALL   lib/semant.sml:289.3-295.22: SemantFun[2].transExp.trexp.check[2]
GOTO   lib/semant.sml:289.3-295.22: SemantFun[2].transExp.trexp.check[2]
CALL   lib/semant.sml:99.2-396.21: SemantFun[2].transExp.trexp
CALL   lib/semant.sml:99.2-396.21: SemantFun[2].transExp.trexp
CALL   lib/semant.sml:488.3-505.6: SemantFun[2].transDec.trdec[2].transBody[2]
     / lib/semant.sml:411.65-543.8: SemantFun[2].transDec
CALL-\ lib/semant.sml:413.2-540.9: SemantFun[2].transDec.trdec[2]
CALL   lib/semant.sml:99.2-396.21: SemantFun[2].transExp.trexp
CALL   lib/semant.sml:8.52-558.4: SemantFun[2].transProg[2]
CALL   main.sml:1.18-118.4: Main.compile[2]
- 

----------------------------------------------------------------------
Name: Matthias Blumen
Date: 2000/06/21 18:00:00 JST
Tag: blume-20000621-manual
Description:

CM manual update: Path environments documented.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/06/19 13:40:00
Tag: blume-20000619-manual
Description:

CM manual and system/README update.  This only covers the fact that
there are no more implicit anchors.  (Path environments and the "bind"
option to "cm" have yet to be documented.)

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/06/19 11:05:00 JST
Tag: blume-20000619-chdir-bugfix
Description:

Fixed a bug in new SrcPath module that sometimes led to a bad chDir call.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/06/18 22:00:10 JST
Tag: blume-20000618-implicit-anchors-really-gone
Description:

I updates the previous HISTORY entry where I forgot to mention that
implicit anchors are no longer with us.

The current update also gets rid of the (now useless) controller
CM.Control.implicit_anchors.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/06/16 17:30:00 JST
Tag: blume-20000616-anchorenv
Description:

This patch implements the long anticipated (just kidding :) "anchor
environment" mechanism.  In the course of doing this, I also
re-implemented CM's internal "SrcPath" module from scratch.  The new
one should be more robust in certain boundary cases.  In any case, it
is a lot cleaner than its predecessor (IMHO).

This time, although there is yet another boot file format change, I
kept the unpickler backward-compatible.  As a result, no new bootfiles
are necessary and bootstrapping is straightforward.  (You cannot read
new bootfiles into an old system, but the other way around is no
problem.)

Visible changes:

** 0. Implicit path anchors (without the leading $-symbol) are no
longer recognized at all. This means that such path names are not
illegal either.  For example, the name basis.cm simply refers to a
local file called "basis.cm" (i.e, the name is an ordinary path
relative to .cm-files directory).  Or, to put it differently, only
names that start with $ are anchored paths.

** 1. The $<singlearc> abbreviation for $/<singlearc> has finally
vanished.

John (Reppy) had critizised this as soon as I originally proposed and
implemented it, but at that time I did not really deeply believe
him. :) Now I came full-circle because I need the $<singlearc> syntax
in another place where it cannot be seen as an abbreviation for
$/<singlearc>.  To avoid the confusion, $<singlearc> now means what it
seems to mean (i.e., it "expands" into the corresponding anchor
value).

However, when paths are used as members in CM description files, it
continues to be true that there must be at least another arc after the
anchor.  This is now enforced separately during semantic analysis
(i.e., from a lexical/syntactical point of view, the notation is ok.)

** 2. The "cm" class now accepts an option "bind".  The option's value
is a sub-option list of precisely two items -- one labeled "anchor"
and the other one labeled "value".  As you might expect, "anchor" is
used to specify an anchor name to be bound, and "value" specifies what
the anchor is being bound to.

The value must be a directory name and can be given in either standard
syntax (including the possibility that it is itself an anchored path)
or native syntax.

Examples:

   foo.cm (bind:(anchor:bar value:$mystuff/bar))
   lib.cm (bind:(anchor:a value:"H:\\x\\y\\z"))  (* only works under windows *)

and so on.

The meaning of this is that the .cm-file will be processed with an
augmented anchor environment where the given anchor(s) is/are bound to
the given values(s).

The rationale for having this feature is this: Suppose you are trying
to use two different (already stable) libraries a.cm and b.cm (that
you perhaps didn't write yourself).  Further, suppose each of these
two libraries internally uses its own auxiliary library $aux/lib.cm.
Normally you would now have a problem because the anchor "lib" can not
be bound to more than one value globally.  Therefore, the project that
uses both a.cm and b.cm must locally redirect the anchor to some other
place:

   a.cm (bind:(anchor:lib value:/usr/lib/smlnj/a-stuff))
   b.cm (bind:(anchor:lib value:/usr/lib/smlnj/b-stuff))

This hard-wires $lib/aux.cm to /usr/lib/smlnj/a-stuff/aux.cm or
/usr/lib/smlnj/b-stuff/aux.cm, respectively.

Hard-wiring path names is a bit inflexible (and CM will verbosely warn
you when you do so at the time of CM.stabilize).  Therefore, you can
also use an anchored path as the value:

  a.cm (bind:(anchor:lib value:$a-lib))
  b.cm (bind:(anchor:lib value:$b-lib))

Now you can globally configure (using the usual CM.Anchor.anchor or
pathconfig machinery) bindings for "a-lib" and "b-lib".  Since "lib"
itself is always locally bound, setting it globally is no longer
meaningful or necessary (but it does not hurt either).  In fact, "lib"
can still be used as a global anchor for separate purposes.  As a
matter of fact, one can locally define "lib" in terms of a global
"lib":

  a.cm (bind:(anchor:lib value:$lib/a))
  b.cm (bind:(anchor:lib value:$lib/b))

** 3: The encoding of path names has changed.  This affects the way
path names are shown in CM's progress report and also the internal
protocol encoding used for parallel make.

The encoding now uses one or more ':'-separated segments.  Each
segments corresponds to a file that has been specified relative to the
file given by its preceding segment.  The first segment is either
relative to the CWD, absolute, or anchored.  Each segment itself is
basically a Unix pathname; all segments but the first are relative.

Example:

   $foo/bar/baz.cm:a/b/c.sml

This path denotes the file bar/a/b/c.sml relative to the directory
denoted by anchor "foo".  Notice that the encoding also includes
baz.cm which is the .cm-file that listed a/b/c.sml.  As usual, such
paths are resolved relative to the .cm-files directory, so baz.cm must
be ignored to get the "real" pathname.

To make this fact more obvious, CM puts the names of such "virtual
arcs" into parentheses when they appear in progress reports. (No
parentheses will appear in the internal protocol encoding.)  Thus,
what you really see is:

  $foo/bar/(baz.cm):a/b/c.sml

I find this notation to be much more informative than before.

Another new feature of the encoding is that special characters
including parentheses, colons, (back)slashes, and white space are
written as \ddd (where ddd is the decimal encoding of the character).

*** The CM manual still needs to be updated.

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/06/15 00:38:00
Tag: leunga-20000615-x86-peephole

x86 Peephole fix by Fermin.  Affects c-- and moby only.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/06/12 11:40:00
Tag: blume-20000612-parmakefix
Description:

More cleanup after changing the file naming scheme: This time I
repaired the parallel make mechanism for CMB.make which I broke earlier.

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/06/09 01:25:00
Tag: leunga-20000609-various

None of these things should affect normal SML/NJ operations

1. Peephole improvements provided by Fermin (c--)
2. New annotation DEFUSE for adding extra dependence (moby)
3. New X86 LOCK instructions (moby)
4. New machine description language for reservation tables (scheduling)
5. Fixes to various optimization/analysis modules (branch chaining, dominator
   trees etc.)
6. I've changed the CM files so that they can work with versions
   110.0.6, 110.25 and 110.28

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/06/09 12:40:00
Tag: blume-20000609-log
Description:

- Removed all(?) remaining RCS Log entries from sources.

- Fixed bug in ml-yacc and ml-lex sources (use explicit anchors for
  anchored paths).

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/06/07 17:00:00 JST
Tag: blume-20000607-no-implicit-anchors
Description:

1. This update changes the default setting for
CM.Control.implicit_anchors from true to false.  This means that
implicit anchors are no longer permitted by default.  I also tried to
make sure that nothing else still relies on implicit anchors.
(This is the next step on the schedule towards a CM that does not even
have the notion of implicit anchors anymore.)

2. More CM manual updates.

3. I managed to track down and fix the pickling bug I mentioned last
time.  Because of the previously existing workaround, this entails no
immediate practical changes.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/06/06 11:15:00 JST
Tag: blume-20000606-lazierpickle
Description:

!!!! NEW BOOT FILES !!!!

* The main purpose of this update is to make library pickles lazier in
order to reduce the initial space penalty for autoloading a library.
As a result, it is now possible to have $smlnj/compiler.cm
pre-registered.  This should take care of the many complaints or
inquiries about missing structure Compiler.  This required changes to
CM's internal data structures and small tweaks to some algorithms.

As a neat additional effect, it is no longer necessary (for the sake
of lean heap image files) to distinguish between a "minimal" CM and a
"full" CM.  Now, there is only one CM (i.e., the "full" version:
$smlnj/cm.cm aka $smlnj/cm/full.cm), and it is always available at the
interactive top level. ($smlnj/cm/minimal.cm is gone.)

To make the life of compiler-hackers easier, "makeml" now also
pre-registers $smlnj/cmb.cm (aka $smlnj/cmb/current.cm).  In other
words, after you bootstrap a new sml for the first time, you will not
have to autoload $smlnj/cmb.cm again afterwards.  (The first time
around you will still have to do it, though.)

* A second change consists of major updates to the CM manual.  There
are now several appendices with summary information and also a full
specification of the CM description file syntax.

* In directory src/system I added the script "allcross".  This script
invokes sml and cross-compiles the compiler for all supported
architectures.  (Useful when providing a new set of boot files.)

* There seems to be a latent bug in my "lazy pickles" mechanism.  I
added a small tweak to pickle-util.sml to work around this problem,
but it is not a proper fix yet.  I will investigate further.  (The
effect of the bug was an inflation of library pickle size.)

* Version number increased to 110.28.1 (to avoid compatibility problems).

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/05/25 17:28 EDT
Tag: leunga-20000525-ra
Description:

  Fixed a bug in freezing phase of the register allocator.

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/05/15 22:53 EDT
Tag: leunga-20000515-alpha-x86-ra
Description:

  1. Alpha

      Slight cleanup.  Removed the instruction SGNXL

  2. X86

      Added the following instructions to the instruction set:
   
        ROLx, RORx,
        BTx, BTSx, BTLx, BTRx, 
        XCHGx, and variants with the LOCK prefix

  3. Register Allocation

      The module ra-rewrite-with-renaming has been improved.

  These have no effect on SML/NJ.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/05/15 16:20:00 JST
Tag: blume-20000515-lightrebuild
Description:

1. I added an alternative to "-rebuild" to "makeml".  The difference is
   that prior to calling CMB.make' the CM-variable "LIGHT" will be
   defined.  In effect, the command will not build any cross-compiler
   backends and therefore finish more quickly.

   The "fixpt" script also takes a "-light" switch to be able to use
   this new facility while compiling for a fixpoint.

2. I replaced all mentions of anchored paths in group owner specifications
   with simple relative paths (usually starting with "..").
   The rationale is that a library's internal workings should not be
   compromised by the lack of some anchor.  (An anchor is necessary
   for someone who wants to refer to the library by an anchored path,
   but it should not be necessary to build the same library in the first
   place.)

3. I changed the way CM's tool mechanism determines the shell command
   string used for things like ml-yacc etc. so that it does not break
   when CM.Control.implicit_anchors is turned off.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/05/12 18:20:00 JST
Tag: blume-20000512-ml-build
Description:

Fixed a bug in config/_ml-build that prevented ml-yacc and ml-lex from
getting installed properly (by config/install.sh).

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/05/12 17:30:00 JST
Tag: blume-20000512-anchors
Description:

!!! NEW BOOT FILES !!!

This change is in preparation of fading out support for "implicitly
anchored path names".  I went through all sources and used the
explicit (and relatively new) $-notation.  See system/README and the
CM manual for more info on this.

I also modified the anchoring scheme for some things such as "smlnj",
"MLRISC", "cm", etc. to take advantage of the fact that explicit
anchors are more expressive: anchor name and first arc do not have to
coincide.  This entails the following user-visible change:

You have to write $smlnj/foo/bar instead of smlnj/foo/bar.  In
particular, when you fire up sml with a command-line argument, say,
e.g.:

   sml '$smlnj/cmb.cm'

At the ML toplevel prompt:

   CM.autoload "$smlnj/cmb.cm";

There is also a new controller in CM.Control that can be used to turn
off all remaining support for implicit anchors by saying:

    CM.autoload "$smlnj/
    #set CM.Control.implicit_anchors false;

This causes CM to reject implicitly anchored paths.  This is (for the
time being) less permissive than the "final" version where there will
be no more such implicit anchors and relative paths will be just that:
relative.

The next step (version after next version?) will be to make the
default for CM.Control.implicit_anchors false.  After the dust has
settled, I can then produce the "final" version of this...

Note: Since bootstrapping is a bit tricky, I provided new boot files.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/05/11 16:30:00 JST
Tag: blume-20000511-sources
Description:

The main change is that I added function CM.sources as a generalized
version of the earlier CM.makedepend.  This entails the following
additional changes:

  - CM.makedepend has been dropped.

  - CM manual has been updated.

  - TOOLS signature and API have been changed.

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/05/10 21:17 EDT
Tag: leunga-20000510-moby-c--ssa
Description:

  Various bug fixes and new features for C--, Moby and MLRISC optimizations.
None of these affect SML/NJ.

1. Register Allocation

    a. A new ra spilling module (ra/ra-spill-with-renaming) is implemented.
       This module tries to remove local (i.e. basic block level) redundancies
       during spilling.  

    b. A new framework for performing region based register allocation.
       Not yet entirely functional.

2. X86

   a. DefUse for POP was missing the stack pointer [found by Lal]
   b. Reload for CALL was incorrect in X86Spill [found by John]
   c. Various fixes in X86Spill so that it can be used correctly for 
      the new spilling module.

3. SSA/IR

   a. New module ir/dj-dataflow.sml implements elimination based
      data flow analysis.

4. MLRiscGen

   a. Fix for gc type annotation

5. MDGen

   Various fixes for machine description -> ml code translation.  For ssa
   only.

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/05/08 22:17 EDT
Tag: leunga-20000508-labexp
Description:

  Fermin has found a few assembly problems with constant expressions 
  generated in LabelExp.  Mostly, the problems involve extra parentheses,
  which choke on dumb assemblers.  This is his fix.

----------------------------------------------------------------------
Name: Dave MacQueen
Date: 2000/04/09 14:00 EDT
Tag: dbm-20000502-Version_110_28
Description:

1. Updated src/compiler/TopLevel/main/version.sml to version 110.28

2. Updated config/version to 110.28

3. Updated config/srcarchiveurl

3. New boot files!
   ftp://ftp.research.bell-labs.com/dist/smlnj/working/110.28/

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/05/01 19:05:00 JST
Tag: blume-20000501-noweb
Description:

A new noweb tool has been added.  The existing system is entirely
unaffected by this, but some CM users have asked for renewed noweb
support.  Everything is documented in the CM manual.

New (plugin) libraries:

   noweb-tool.cm
   nw-ext.cm

----------------------------------------------------------------------
Name: Dave MacQueen
Date: 2000/04/30 12:40PM EDT
Tag: dbm-20000430-bug_fixes
Description:

1. Fix for bug 1498
   smlnj/src/system/Basis/Implementation/Unsafe/object.sig
   smlnj/src/system/Basis/Implementation/Unsafe/object.sml
     added toRealArray function
   smlnj/src/compiler/MiscUtil/print/ppobj.sml
     added check for tag Obj.RealArray to array printing case in ppObj

2. Fix for bug 1510
   smlnj/src/compiler/Semant/types/typesutil.sml
     fixed definition of dummyargs (used by equalTycon) so that 
     dummy args are distinct types

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/04/30 01:00:00 JST
Tag: blume-20000430-versions
Description:

1. CM version numbering added.  This is an implementation of Lal's
   proposal for adding version numbers and version checking to .cm
   files.  Lal said that his proposal was just that -- a proposal.
   For the time being I went ahead and implemented it so that people
   can comment on it.  Everything is completely backward-compatible
   (except for the stable library format, i.e., new bootfiles!).

   As usual, see the CM manual for details.

2. An alternative syntax for anchored paths has been implemented.
   Dave has recently voiced the same concerns that I had when I did
   this, so there should be some support.  My take is that eventually
   I will let support for the current syntax (where anchors are
   "implicit") fade out in favor of the new, explicit syntax.
   In order to be backward-compatible, both old and new syntax are
   currently supported.

   Again, see the CM manual for details.

3. Parallel make is trying to be slightly smarter:  When the master
   process finds a "bottleneck", i.e., when there is only one
   compilation unit that can be compiled and everybody else is
   waiting on it, then it will simply compile it directly instead
   of clumsily telling one of the slaves to do it.

4. Support for "unsharing" added.  This is necessary in order to be
   able to have two different versions of the same library running
   at the same time (e.g., for trying out a new MLRISC while still
   having the old MLRISC linked into the current compiler, etc.)
   See the CM manual.

5. Simple "makedepend" functionality added for generating Makefile
   dependency information.  (This is rather crude at the moment.
   Expect some changes here in the future.)

6. ".fun" added as a recognized suffix for ML files. Also documented
   explicitly in the manual that the fallback behavior (unknown suffix
   -> ML file) is not an official feature!

7. Small changes to the pickler for stable libraries.

8. Several internal changes to CM (for cleanup/improvement).


!!!! NEW BINFILES !!!!

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/04/28 17:30:00 JST
Tag: blume-20000428-pathconfig
Description:

1. I changed config/install.sh to remove duplicate entries from the
   lib/pathconfig file at the end.  Moreover, the final version of
   lib/pathconfig is sorted alphabetically.  The same (sorting) is done
   in src/system/installml.

2. The config/install.sh script now consistently uses relative
   pathnames in lib/pathconfig whenever the anchor is in the lib
   directory.  (So far this was true for the libraries that come
   pre-compiled and bundled as part of the bootfiles but not for
   libraries that are compiled by the script itself.)

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/04/26 13:10:00 JST
Tag: blume-20000426-fun_suffix
Description:

Added ".fun" as a recognized file name suffix (for ML code).

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/04/25 17:00:00 EST
Tag: leunga-20000425-alpha-ra
Description:

1. Alpha

    PSEUDOARITH was missing in AlphaRewrite.  This causes an endless loop
in C--. 

2. RA

   Added a flag "ra-dump-size" to print out the size of the flowgraph
   and the interference graph.

----------------------------------------------------------------------
Name: Dave MacQueen
Date: 2000/04/25/
Tag: dbm-20000425-mlyacc_doc_examples
Description: 
  Updated mlyacc.tex sections 5 and 7 for SML '97 and CM.
  Updated all three examples in src/ml-yacc/examples to run
  under 110.* using CM.make.

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/04/20 23:04:00 EST
Tag: leunga-20000420-ssa-c---stuff
Description:

  This update synchronizes my repository with Yale's.  Most of these
changes, however, do not affect SML/NJ at all (the RA is an exception).

1. Register Allocator

   a. An improvement in the interference graph construction:  
      Given a copy

            s <- t

      no interference edge between s and t is added for this definition of s.
 
   b. I've added two new spill heuristic modules that Fermin and I developed
      (in the new library RA.cm). These are unused in SML/NJ but maybe
      useful for others (Moby?)

2. X86

   a. Various fixes in the backend provided by Fermin [C--] and Lal.

3. Alpha

   a. Added the BSR instruction and code generation that goes with it [C--]
   b. Other fixes too numerous to recount provided by Fermin [C--]

4. Regmaps

   a. The regmaps are not initialized with the identity physical bindings 
      at creation time.  This is unneeded.

5. MLRISC Optimizations

   a. The DJ-Graph module can now compute the iterated dominance frontiers
      intersects with liveness incrementally in linear time! Woohoo! 
      This is now used in my new SSA construction algorithm.

   b. THe branch reorganization module is now smarter about linear chains of
      basic blocks.
  

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/04/12 13:52:00 JST
Tag: blume_main_v110p27_1
Description:

Changed install.sh script to handle archive files without version number
and to use "boot.<arch>-<os>" instead of "sml.boot.<arch>-<os>" for the
name of the boot file archive.

----------------------------------------------------------------------
Name: Dave MacQueen
Date: 2000/04/09 14:00 EDT
Tag: dbm-20000410-Version_110_27
Description:

1. Updated src/compiler/TopLevel/main/version.sml to version 110.27

2. Updated src/config/version to 110.27

3. New boot files!

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/04/09 19:09:00 EST
Tag: leunga-20000409-misc
Description:

1.  Yet another fix for x86 assembly for idivl, imull, mull and friends.

2.  Miscellaneous improvements to MLRISC (unused in sml/nj)  

----------------------------------------------------------------------
Name: Stefan
Date: 2000/04/07 10:00:00 EDT
Tag: monnier-20000406-branch-handling
Description:

Improved handling of branches (mostly those generated from
polymorphic equality), removed switchoff and changed the
default optimization settings (more cpsopt and less flintopt).

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/04/06 01:30:00 EST
Tag: leunga-20000406-peephole-x86-SSA-2
Description:

   Forgot a few files.  

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/04/06 00:36:00 EST
Tag: leunga-20000406-peephole-x86-SSA
Description:

1.  New Peephole code

2.  Minor improvement to X86 instruction selection

3.  Various fixes to SSA and machine description -> code translator

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/04/05 12:30:00 JST
Tag: blume_main_v110p26p2_3
Description:

This update just merges three minor cosmetic updates to CM's sources
to get ready for the 110.27 code freeze on Friday.  No functionality
has changed.

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/04/04 19:39:00 EST
Tag: leunga-20000404-x86-asm
Description:

1.  Fixed a problem in X86 assembly.

    Things like

       jmp %eax
       jmp (%eax)

    should be output as

       jmp *%eax
       jmp *(%eax)

2.  Assembly output

      Added a new flag 

          "asm-indent-copies" (default to false)

      When this flag is on, parallel copies will be indented an extra level.

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/04/04 03:18:00 EST
Tag: leunga-20000404-C--Moby
Description:

    All of these fixes are related to C--, Moby, and my own optimization
    stuff; so they shouldn't affect SML/NJ.

1.  X86

    Various fixes related floating point, and extensions.

2.  Alpha 

    Some extra patterns related to loads with signed/zero extension
    provided by Fermin.

3.  Assembly 

    When generating assembly, resolve the value of client defined constants, 
    instead of generating symbolic values.  This is controlled by the 
    new flag "asm-resolve-constants", which is default to true.

4.  Machine Descriptions

    a. The precedence parser was slightly broken when parsing infixr symbols.
    b. The type generalizing code had the bound variables reversed, resulting
       in a problem during arity raising. 
    c. Various fixes in machine descriptions.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/04/03 16:05:00 JST
Tag: blume_main_v110p26p2_2
Description:

I eliminated coreEnv from compInfo.  Access to the "Core" structure is
now done via the ordinary static environment that is context to each
compilation unit.

To this end, I arranged that instead of "structure Core" as "structure
_Core" is bound in the pervasive environment.  Core access is done via
_Core (which can never be accidentally rebound because _Core is not a
legal surface-syntax symbol).

The current solution is much cleaner because the core environment is
now simply part of the pervasive environment which is part of every
compilation unit's context anyway.  In particular, this eliminates all
special-case handling that was necessary until now in order to deal
with dynamic and symbolic parts of the core environment.

Remaining hackery (to bind the "magic" symbol _Core) is localized in the
compilation manager's bootstrap compiler (actually: in the "init group"
handling).  See the comments in src/system/smlnj/init/init.cmi for
more details.

I also tried to track down all mentions of "Core" (as string argument
to Symbol.strSymbol) in the compiler and replaced them with a
reference to the new CoreSym.coreSym.  Seems cleaner since the actual
name appears in one place only.

Binfile and bootfile format have not changed, but the switchover from
the old "init.cmi" to the new one is a bit tricky, so I supplied new
bootfiles anyway.

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/04/02 21:17:00 EST
Tag: leunga-20000402-mltree
Description:

   1. Renamed the constructor CALL in MLTREE by popular demand.
   2. Added a bunch of files from my repository.  These are currently
      used by other non-SMLNJ backends.

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/03/31 21:15:00 EST
Tag: leunga-20000331-aliasing
Description:

This update contains a rewritten (and hopefully more correct) module 
for extracting aliasing information from CPS.  

   To turn on this feature:  

        Compiler.Control.CG.memDisambiguate := true

   To pretty print the region information with assembly

       Compiler.Control.MLRISC.getFlag "asm-show-region" := true;

   To control how many levels of aliasing information are printed, use:

       Compiler.Control.MLRISC.getInt "points-to-show-level" := n

   The default of n is 3.

----------------------------------------------------------------------
Name: David MacQueen
Date: 2000/03/31 11:15:00 EST
Tag: dbm-20000331-runtime_fix
Description:

This update contains:

1. runtime/c-lib/c-libraries.c
   includes added in revision 1.2 caused compilation errors on hppa-hpux

2. fix for bug 1556
   system/Basis/Implementation/NJ/internal-signals.sml

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/03/31 18:00:00 JST
Tag: blume_main_v110p26p2_1
Description:

This update contains:

1. A small change to CM's handling of stable libraries:
   CM now maintains one "global" modmap that is used for all stable
   libraries.  The use of such a global modmap maximizes sharing and
   minimizes the need for re-traversing parts of environments during
   modmap construction.  (However, this has minor impact since modmap
   construction seems to account for just one percent or less of total
   compile time.)

2. I added a "genmap" phase to the statistics.  This is where I got the
   "one percent" number (see above).

3. CM's new tool parameter mechanism just became _even_ better. :)
   - The parser understands named parameters and recursive options.
   - The "make" and "shell" tools use these new features.
     (This makes it a lot easier to cascade these tools.)
   - There is a small syntax change: named parameters use a

       <name> : ( <option> ... )            or
       <name> : <string>

     syntax.  Previously, named parameters were implemented in an
     ad-hoc fashion by each tool individually (by parsing strings)
     and had the form

       <name>=<string>

   See the CM manual for a full description of these issues.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/03/30 18:00:00 JST
Tag: blume_main_v110p26p2_0
Description:

!!!!! WARNING !!!!!!
!!  New binfiles  !!
!!!!!!!!!!!!!!!!!!!!

This update contains:

1. Moderate changes to CM:

   - Changes to CM's tools mechanism.  In particular, it is now possible
   to have tools that accept additional "command line" parameters
   (specified in the .cm file at each instance where the tool's class is
   used).

   This was done to accommodate the new "make" and "shell" tools which
   facilitate fairly seamless hookup to portions of code managed using
   Makefiles or Shell scripts.

   There are no classes "shared" or "private" anymore.  Instead, the
   sharing annotation is now a parameter to the "sml" class.

   There is a bit of generic machinery for implementing one's own
   tools that accept command-line parameters.  However, I am not yet fully
   satisfied with that part, so expect changes here in the future.

   All existing tools are described in the CM manual.

   - Slightly better error handling.  (CM now suppresses many followup
   error messages that tended to be more annoying than helpful.)

2. Major changes to the compiler's static environment data structures.

   - no CMStaticEnv anymore.
        - no CMEnv, no "BareEnvironment" (actually, _only_ BareEnvironment,
          but it is called Environment), no conversions between different
          kinds of static environments

   - There is still a notion of a "modmap", but such modmaps are generated
     on demand at the time when they are needed.  This sounds slow, but I
     sped up the code that generates modmaps enough for this not to lead to
     a slowdown of the compiler (at least I didn't detect any).

   - To facilitate rapid modmap generation, static environments now
     contain an (optional) "modtree" structure.  Modtree annotations are
     constructed by the unpickler during unpickling.  (This means that
     the elaborator does not have to worry about modtrees at all.)
     Modtrees have the advantage that they are compositional in the same
     way as the environment data structure itself is compositional.
     As a result, modtrees never hang on to parts of an environment that
     has already been rendered "stale" by filtering or rebinding.

   - I went through many, many trials and errors before arriving at the
     current solution.  (The initial idea of "linkpaths" did not work.)
     But the result of all this is that I have touched a lot of files that
     depend on the "modules" and "types" data structures (most of the
     elaborator). There were a lot of changes during my "linkpath" trials
     that could have been reverted to their original state but weren't.
     Please, don't be too harsh on me for messing with this code a bit more
     than what was strictly necessary...  (I _did_ resist the tempation
     of doing any "global reformatting" to avoid an untimely death at
     Dave's hands. :)

   - One positive aspect of the previous point:  At least I made sure that
     all files that I touched now compile without warnings (other than
     "polyEqual").

   - compiler now tends to run "leaner" (i.e., ties up less memory in
     redundant modmaps)

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/03/29 18:00:00
Tag: leunga-20000327-mlriscGen_hppa_alpha_x86
Boot files (optional): ftp://react-ilp.cs.nyu.edu/leunga/110.26.1-sml.boot.x86-unix-20000330.tar.gz
Description:
 
   This update contains *MAJOR* changes to the way code is generated from CPS
in the module mlriscGen, and in various backend modules.

CHANGES
=======

1. MLRiscGen: forward propagation fix.

   There was a bug in forward propagation introduced at about the same time
   as the MLRISC x86 backend, which prohibits coalescing to be 
   performed effectively in loops. 

   Effect: speed up of loops in RISC architectures.
           By itself, this actually slowed down certain benchmarks on the x86.

2. MLRiscGen:  forward propagating addresses from consing.

   I've changed the way consing code is generated.  Basically I separated 
   out the initialization part:

        store tag,   offset(allocptr)
        store elem1, offset+4(allocptr)
        store elem2, offset+8(allocptr)
        ...
        store elemn, offset+4n(allocptr)

   and the address computation part:

        celladdr <- offset+4+alloctpr

   and move the address computation part

   Effect:  register pressure is generally lower as a result.  This 
            makes compilation of certain expressions much faster, such as
            long lists with non-trivial elements.

             [(0,0), (0,0), .... (0,0)]

3. MLRiscGen: base pointer elimination.

    As part of the linkage mechanism, we generate the sequence:

     L:  ...  <- start of the code fragment
 
     L1:
         base pointer <- linkreg - L1 + L

     The base pointer was then used for computing relocatable addresses
   in the code fragment.  Frequently (such as in lots of continuations) 
   this is not needed.  We now eliminate this sequence whenever possible.

     For compile time efficiency, I'm using a very stupid local heuristic.  
   But in general, this should be done as a control flow analysis.

   Effect:  Smaller code size.  Speed up of most programs.

4. Hppa back end

     Long jumps in span dependence resolution used to depend on the existence
  of the base pointer.  

     A jump to a long label L was expanded into the following sequence:
     
      LDIL %hi(L-8192), %r29
      LDO  %lo(L-8192)(%r29), %r29
      ADD  %r29, baseptr, %r29
      BV,n %r0(%r29)

     In the presence of change (3) above, this will not work.  I've changed
   it so that the following sequence of instructions are generated, which
   doesn't mention the base pointer at all:

         BL,n  L', %r29           /* branch and link, L' + 4 -> %r29 */
    L':  ADDIL L-(L'+4), %r29     /* Compute address of L */ 
         BV,n  %r0(%r29)          /* Jump */ 

5. Alpha back end

      New alpha instructions LDB/LDW have been added, as per Fermin's
   suggestions.   This is unrelated to all other changes.

6. X86 back end 

     I've changed andl to testl in the floating point test sequence
     whenever appropriate.  The Intel optimization guide states that
     testl is preferable to andl.

7. RA (x86 only)

     I've improved the spill propagation algorithm, using an approximation
   of maximal weighted independent sets.   This seems to be necessary to
   alleviate the negative effect in light of the slow down in (1). 

     I'll write down the algorithm one of these days.

8. MLRiscGen: frequencies

     I've added an annotation that states that all call gc blocks have zero
   execution frequencies.  This improves register allocation on the x86.
    
BENCHMARKS
==========

   I've only perform the comparison on 110.25.

   The platforms are:
  
    HPPA  A four processor HP machine (E9000) with 5G of memory.
    X86   A 300Hhz Pentium II with 128M of memory, and 
    SPARC An Ultra sparc 2 with 512M of memory.

   I used the following parameters for the SML benchmarks:

             @SMLalloc
     HPPA    256k
     SPARC   512k
     X86     256k

COMPILATION TIME
----------------
   Here are the numbers comparing the compilation times of the compilers.
   I've only compared 110.25 compiling the new sources versus
   a fixpoint version of the new compiler compiling the same.

                 110.25                                  New
           Total  Time in RA  Spill+Reload   Total  Time In RA Spill+Reload
     HPPA   627s    116s        2684+3584     599s    95s       1003+1879
     SPARC  892s    173s        2891+3870     708s    116s      1004+1880
     X86    999s    315s       94006+130691   987s    296s    108877+141957

               110.25         New
            Code Size      Code Size
     HPPA   8596736         8561421
     SPARC  8974299         8785143
     X86    9029180         8716783

   So in summary, things are at least as good as before.   Dramatic 
   reduction in compilation is obtained on the Sparc; I can't explain it, 
   but it is reproducible.  Perhaps someone should try to reproduce this 
   on their own machines.

SML BENCHMARKS
--------------

    On the average, all benchmarks perform at least as well as before. 

      HPPA         Compilation Time     Spill+Reload      Run Time
                 110.25  New            110.25    New   110.25  New    

      barnesHut  3.158  3.015  4.75%    1+1       0+0   2.980  2.922   2.00%
          boyer  6.152  5.708  7.77%    0+0       0+0   0.218  0.213   2.34%
   count-graphs  1.168  1.120  4.32%    0+0       0+0  22.705 23.073  -1.60%
            fft  0.877  0.792 10.74%    1+3       1+3   0.602  0.587   2.56%
    knuthBendix  3.180  2.857 11.32%    0+0       0+0   0.675  0.662   2.02%
         lexgen  6.190  5.290 17.01%    0+0       0+0   0.913  0.788  15.86%
           life  0.803  0.703 14.22%   25+25      0+0   0.153  0.140   9.52%
          logic  2.048  2.007  2.08%    6+6       1+1   4.133  4.008   3.12%
     mandelbrot  0.077  0.080 -4.17%    0+0       0+0   0.765  0.712   7.49%
         mlyacc 22.932 20.937  9.53%  154+181    32+57  0.468  0.430   8.91%
        nucleic  5.183  5.060  2.44%    2+2       0+0   0.125  0.120   4.17%
  ratio-regions  3.357  3.142  6.84%    0+0       0+0  116.225 113.173 2.70%
            ray  1.283  1.290 -0.52%    0+0       0+0   2.887  2.855   1.11%
         simple  6.307  6.032  4.56%   28+30      5+7   3.705  3.658   1.28%
            tsp  0.888  0.862  3.09%    0+0       0+0   7.040  6.893   2.13%
           vliw 24.378 23.455  3.94%  106+127    25+45  2.758  2.707   1.91%
  --------------------------------------------------------------------------
   Average                     6.12%                                   4.09%

      SPARC        Compilation Time     Spill+Reload      Run Time
                 110.25  New            110.25    New   110.25  New    

      barnesHut  3.778  3.592  5.20%    2+2       0+0   3.648  3.453    5.65%
          boyer  6.632  6.110  8.54%    0+0       0+0   0.258  0.242    6.90%
   count-graphs  1.435  1.325  8.30%    0+0       0+0  33.672 34.737   -3.07%
            fft  0.980  0.940  4.26%    3+9       2+6   0.838  0.827    1.41%
    knuthBendix  3.590  3.138 14.39%    0+0       0+0   0.962  0.967   -0.52%
         lexgen  6.593  6.072  8.59%    1+1       0+0   1.077  1.078   -0.15%
           life  0.972  0.868 11.90%   26+26      0+0   0.143  0.140    2.38%
          logic  2.525  2.387  5.80%    7+7       1+1   5.625  5.158    9.05%
     mandelbrot  0.090  0.093 -3.57%    0+0       0+0   0.855  0.728   17.39%
         mlyacc 26.732 23.827 12.19%  162+189    32+57  0.550  0.560   -1.79%
        nucleic  6.233  6.197  0.59%    3+3       0+0   0.163  0.173   -5.77%
  ratio-regions  3.780  3.507  7.79%    0+0       0+0 133.993 131.035   2.26%
            ray  1.595  1.550  2.90%    1+1       0+0   3.440  3.418    0.63%
         simple  6.972  6.487  7.48%   29+32      5+7   3.523  3.525   -0.05%
            tsp  1.115  1.063  4.86%    0+0       0+0   7.393  7.265    1.77%
           vliw 27.765 24.818 11.87%  110+135    25+45  2.265  2.135    6.09%
  ----------------------------------------------------------------------------
   Average                     6.94%                                    2.64%

      X86          Compilation Time     Spill+Reload      Run Time
                 110.25  New            110.25    New   110.25  New    

      barnesHut  5.530  5.420  2.03%  593+893   597+915   3.532  3.440   2.66%
          boyer  8.768  7.747 13.19%  493+199   301+289   0.327  0.297  10.11%
   count-graphs  2.040  2.010  1.49%  298+394   315+457  26.578 28.660  -7.26%
            fft  1.327  1.302  1.92%  112+209   115+210   1.055  0.962   9.71%
    knuthBendix  5.218  5.475 -4.69%  451+598   510+650   0.928  0.932  -0.36%
         lexgen  9.970  9.623  3.60% 1014+841  1157+885   0.947  0.928   1.97%
           life  1.183  1.183  0.00%  162+182   145+148   0.127  0.103  22.58%
          logic  3.285  3.512 -6.45%  514+684   591+836   5.682  5.577   1.88%
     mandelbrot  0.147  0.143  2.33%   38+41     33+54    0.703  0.690   1.93%
         mlyacc 35.457 32.763  8.22% 3496+4564 3611+4860  0.552  0.550   0.30%
        nucleic  7.100  6.888  3.07%  239+168   201+158   0.175  0.173   0.96%
  ratio-regions  6.388  6.843 -6.65% 1182+257   981+300  120.142 120.345 -0.17%
            ray  2.332  2.338 -0.29%  346+398   402+494   3.593  3.540   1.51%
         simple  9.912  9.903  0.08% 1475+941  1579+1168  3.057  3.178  -3.83%
            tsp  1.623  1.532  5.98%  266+200   250+211   8.045  7.878   2.12%
           vliw 33.947 35.470 -4.29% 2629+2774 2877+3171  2.072  1.890   9.61%
  ----------------------------------------------------------------------------
   Average                     1.22%                                     3.36%

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/03/23 16:25:00
Tag: leunga-20000323-fix_x86_alpha
Description:

1. X86 fixes/changes  

   a.  The old code generated for SETcc was completely wrong.  
       The Intel optimization guide is VERY misleading.

2. ALPHA fixes/changes

   a.  Added the instructions LDBU, LDWU, STB, STW as per Fermin's suggestion.
   b.  Added a new mode byteWordLoadStores to the functor parameter to Alpha()
   c.  Added reassociation code for address computation.

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/03/22 01:23:00
Tag: leunga-20000322-fix_x86_hppa_ra
Description:

1. X86 fixes/changes  

   a.  x86Rewrite bug with MUL3 (found by Lal)
   b.  Added the instructions FSTS, FSTL

2. PA-RISC fixes/changes

   a.  B label should not be a delay slot candidate!  Why did this work?
   b.  ADDT(32, REG(32, r), LI n) now generates one instruction instead of two,
       as it should be.
   c.  The assembly syntax for fstds and fstdd was wrong.
   d.  Added the composite instruction COMICLR/LDO, which is the immediate
       operand variant of COMCLR/LDO.

3. Generic MLRISC

   a.  shuffle.sml rewritten to be slightly more efficient
   b.  DIV bug in mltree-simplify fixed (found by Fermin)

4. Register Allocator

   a.  I now release the interference graph earlier during spilling.
       May improve memory usage.  

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/03/14 14:15:32
Tag: blume_main_v110p26p1_2
Description:

1. Tools.registerStdShellCmdTool (from smlnj/cm/tool.cm) takes an
additional argument called "template" which is an optional string that
specifies the layout of the tool command line.  See the CM manual for
explanation.

2. A special-purpose tool can be "registered" by simply dropping the
corresponding <...>-tool.cm (and/or <...>-ext.cm) into the same
directory where the .cm file lives that uses this tool.  (The
behavior/misfeature until now was to look for the tool description
files in the current working directory.)  As before, tool description
files could also be anchored -- in which case they can live anywhere
they like.  Following the recent e-mail discussion, this change should
make it easier to have special-purpose tools that are shipped together
with the sources of the program that uses them.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/03/10 07:48:34
Tag: blume_main_v110p26p1_1
Description:

I added a re-written version of Dave's fixpt script to src/system.
Changes relative to the original version:
  - sh-ified (not everybody has ksh)
  - automatically figures out which architecture it runs on
  - uses ./makeml a bit more cleverly
  - never invokes ./installml (and, thus, does not clobber your
    good and working installation of sml in case something goes wrong)
  - accepts max iteration count using option "-iter <n>"
  - accepts a "base" name using option "-base <base>"

It does not build any extraneous heap images but directly rebuilds
bin- and boot-hierarchies using makeml's "-rebuild" switch. Finally,
it can incorporate existing bin- and boot- hierarchies.  For example,
suppose the base is set to "sml" (which is the default).  Then it
successively builds

        sml.bin.<arch>-unix and sml.boot.<arch>-unix
then    sml1.bin.<arch>-unix and sml1.boot.<arch>-unix
then    sml2.bin.<arch>-unix and sml2.boot.<arch>-unix
...
then    sml<n>.bin.<arch>-unix and sml<n>.boot.<arch>-unix

and so on.  If any of these already exist, it will just use what's
there.  In particular, many people will have the initial set of bin
and boot files around, so this saves time for at least one full
rebuild.  Having sets of the form <base><k>.{bin,boot}.<arch>-unix for
<k>=1,2,... is normally not a good idea when invoking fixpt.  However,
they might be the result of an earlier partial run of fixpt (which
perhaps got accidentally killed).  In this case, fixpt will quickly
move through what exists before continuing where it left off earlier,
and, thus, saves a lot of time.

----------------------------------------------------------------------
Name: Allen Leung
Date: 00/03/10 02:20:00
Tag: leunga-20000310-fix_x86_asm_ra
Description:

More assembly output problems involving the indexed addressing mode
on the x86 have been found and corrected. Thanks to Fermin Reig for the
fix.

The interface and implementation of the register allocator have been changed
slightly to accommodate the possibility to skip the register allocation 
phases completely and go directly to memory allocation.  This is needed
for C-- use.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 00/03/09 10:23:53
Tag: blume_main_v110p26p1_0
Description:

* Complete re-organization of library names.  Many libraries have been
consolidated so that they share the same path anchor.  For example,
all MLRISC-related libraries are anchored at MLRISC, most libraries that
are SML/NJ-specific are under "smlnj".  Notice that names like
host-cmb.cm or host-compiler.cm no longer exist.  See system/README
for a complete description of the new naming scheme.  Quick reference:

   host-cmb.cm        -> smlnj/cmb.cm
   host-compiler.cm   -> smlnj/compiler.cm
   full-cm.cm         -> smlnj/cm.cm
   <arch>-<os>.cm     -> smlnj/cmb/<arch>-<os>.cm
   <arch>-compiler.cm -> smlnj/compiler/<arch>.cm

* Bug fixes in CM.
    - exceptions in user code are being passed through (i.e., reach top level)
    - more bugs in paranoia mode fixed
    - bug related to checking group owners fixed

* New install.sh script that automagically fetches archive files:
  The new file config/srcarchiveurl must contain the URL of the
  (remote) directory that contains bin files (or other source archives).
  If install.sh does not find the archive locally, it tries to get
  it from that remote directory.
  This should simplify installation further:  For machines that have
  access to the internet, just fetch <version>-config.tgz, unpack it,
  edit config/targets, and go (run config/install.sh).  The script will
  fetch everything else that it might need all by itself.

  For CVS users, this mechanism is not relevant for source archives, but
  it is convenient for getting new sets of binfiles.

  Archives should be tar files compressed with either gzip, compress, or
  bzip2.  The script recognizes .tgz, .tar, tar.gz, tz, .tar.Z, and .tar.bz2.
  
----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/03/07 04:01:04
Tag: blume_main_v110_26_2
Description:
- size info in BOOTLIST
     * no fixed upper limits for number of bootfiles or length of
       bootfile names in runtime
     * falling back to old behavior if no BOOTLIST size info found
- allocation size heuristics in .run-sml
     * tries to read cache size from /proc/cpuinfo (this is important for
        small-cache Celeron systems!)
- install.sh robustified
- CM manual updates
- paranoid mode
     * no more CMB.deliver() (i.e., all done by CMB.make())
     * can re-use existing sml.boot.* files
     * init.cmi now treated as library
     * library stamps for consistency checks
- sml.boot.<arch>-<os>/PIDMAP file
     * This file is read by the CM startup code.  This is used to minimize
       the amount of dynamic state that needs to be stowed away for the
       purpose of sharing between interactive system and user code.
- CM.Anchor.anchor instead of CM.Anchor.{set,cancel}
     * Upon request by Elsa.  Anchors now controlled by get-set-pair
       like most other CM state variables.
- Compiler.CMSA eliminated
     * No longer supported by CM anyway.
- fixed bugs in pickler that kept biting Stefan
     * past refs to past refs (was caused by the possibility that
       ad-hoc sharing is more discriminating than hash-cons sharing)
     * integer overflow on LargeInt.minInt
- ml-{lex,yacc} build scripts now use new mechanism
  for building standalone programs
- fixed several gcc -Wall warnings that were caused by missing header
  files, missing initializations, etc., in runtime (not all warnings
  eliminated, though)
