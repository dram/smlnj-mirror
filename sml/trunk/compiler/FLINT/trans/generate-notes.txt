(* generate-notes.txt *)

Notes on oldmc "code generation" (FLINT/trans/generate.sml)

Fundamental variable relationship:

voccurs:  var * node * ruleno -> bool

Defn: OCC(v,n,r):
  pattern var v occurs (is bound) at node n (andor tree position: andor, or path, or node id)
  in rule r.

nodeId <-> path  functions, an isomorphism (1 to 1 and onto)
nodeId <-> andor

For each _occurrence_ of a pattern variable, the critical information seems to be

(1) its "name", or identity (e.g. lvar)
(2) its position in the pattern space (nodeId == path)
(3) which rule/pattern in the sequence it occurs in

This could be "statically" captured during the 2nd phase of andor tree building
(Anodor2.translateAndor; oldmc) by collecting a map

    pvarenv: variable (V.var or LV.lvar) -> (nodeId, ruleno)

During the "code generation" phase, this map could combine with the mvarenv: nodeId -> mvar
developed along a complete branch (to an RHS terminal node) to give a mapping from
relevant pvars to mvars.  [with newmc, ruleno would presumably be replaced by "layer"]

FACTS:

(1) along any complete path in the decision tree, any nodeId occurs at most once.
(so the mvarenv mapping will be unambiguous for that complete branch).

(2) nodeIds can occur multiple times in the whole decision tree, so the relevant
mvarenv needs to be built and passed down along a specific branch.

(3) a pvar can occur only once in a given rule (pattern), but may occur in multiple
rules (patterns).  So the parenv environment above needs to map a pvar to a list
of nodeId-ruleno pairs:

    pvarenv: variable --> (nodeId * ruleno) list

(this must satisfy the constraint that if (id1, rule1) and (id2, rule2) are in pvarenv(v),
then rule1 <> rule2) -- there is at most one ruleno r such that (id, r) in pvarenv(v).)


This is a kind of inverse of the node.info.bindings mapping

    bindings : nodeId -> varBindings   (id |-> node(id).info.bindings)

We disambiguate this mapping by filering by a particular rule:

    lookupByRule : variable * ruleno --> nodeId option

    lookupByRule (v,r) => NONE if v is not bound in pat(r)
    lookupByRule (v,r) => SOME id  parenv(v) contains (id,r)

================================================================================
Mvars (match variables)
-----------------------

Mvars, "match" or "administrative" variables (of type lvar in oldmc) are variables that
are bound to various "nodes" or sub components of the matching value, corresponding to
andor nodes (and their unique nodeIds):

   nodeId --> mvar

A node "needs" an mvar for one or both of two rules.

  (1) the node (matching value) needs to be destructed (because of a concrete pattern
      element (constant, constructor) at that node.

  (2) a pattern variable is bound at the node, and this pattern variable needs to be
      "represented" by an mvar in the matching result (a tuple of values that correspond
      to pattern variables).

Note [terminology]: a value is (or needs to be) _destructed_ if it is matched against a
  concrete pattern element (constant, tuple, vector, datacon).  When matching a constant,
  the destruct consists of testing equality with the constant. When matching a non constnat
  pattern element, destruction consists of:

  (a) (con pat) : testing the head constructor to see if it matches con, and _destructing_
  to the argument of con, which will then have to be matched with pat.

  (b) (pat1, .. patn) : (tuple). Typing ensures that the value will be compatible (a tuple
  of length n whose elements are of the same types as pat1, ..., patn, respectively). Destructing
  involves breaking the value down into its tuple elements. The elements produced by destructing
  will be bound to their own individual mvars (administrative variables).

  (c) #[pat1, ..., patn] : (vector). For discrimination we need to get the length of the
  vector value and check that its value is n (length of the vector pattern). If so, we destruct
  into the elements of the vector, which are bound to their own mvars.

Examples:

(1)   (0, false) => 0      (* rhs0, no pattern variables *)
      (x, true) => x - 1   (* rhs1, 1 pattern variable: x *)

Here the value node at path <0> (patterns 0, x), of type int, has to be destructed (test if value = 0)
and it has to be bound to an mvar that will "represent" the pattern variable x in the match result.

andor
-----

  AND 0 <> {} {0,1}
    0: OR 1 <0> int {(x,1)} {0,1}    (kind, nodeId, path, type, bindings, live)
         0: LF 2 int {} {0,1}
    1: OR 3 <1> bool {} {0,1}
         false: LF 4 <1> bool {} {0}
	 true:  LF 5 <1> bool {} {1}

dectree  (assuming OR node 3 is "better" than OR node 1)
-------

  CHOICE 3 <1> {0,1}
    false: CHOICE 1 <0> {0}
             0: {0} RHS 0
	     *: FAIL
    true:  CHOICE 1 <0> {1}   -- is node 1 relevant in true case for node 3?)
             0: RHS 1
	     *: RHS 1

  CHOICE 3 <1>
    false: CHOICE 1 <0> {0}
             0: {0} RHS 0
	     *: FAIL
    true:  RHS 1     -- 1 in defaults(1) = {1} => node 1 not relevant, hence no CHOICE

mvars:
  <1> needs an mvar because it is being destructed at node 3
  <1,false>: <0> needs an mvar because <0> needs to be destructed (CHOICE 1 check)
  <1,true>: <0> needs an mvar to represent the pattern variable x

So the mvar for <0> is used for both destruct and binding (but in different choice branches).

(2a)   () => 0 
(2b)   ((), ()) => 0

Here there are no choice destructions and no variable bindings, so in this case do we
need any mvars?  For (2b) we might have an mvar for <> to be destructed into two
children that are both ().  () is not subject to destruction, and there is no pattern
variable at this node, so these descendent nodes do not require mvars, so the top pair node
also does not require an mvar with respect to which the component mvars might be defined.
So (2b) is an example of a compound, destructable pattern that does not need any mvars
in its match code.

QUESTION: Is there ever a case where a destruct does not need to be bound to an mvar?
ANSWER: This would mean that there is no destruct on the value and also no pattern var bound to
the value (bound at the node).  For a node to be created, there must be either a concrete
construct or a variable at that position (path). In either case there would need to be
an mvar representing the value (for destruction or binding).

DEFN: An mvar is _escaping_ if it represents a pattern variable and is therefore
included in the result tuple of a pattern match.  A non-escaping mvar is _internal_
and is only used to represent intermediate results during destruction of values. It
is therefore "ephemeral" in that it is used locally to represent an "intermediate"
result in the process of value destruction (and perhaps does not need to be stored
in an mvarenv?).

Whether an mvar is escaping can be determined by checking whether its associated
node (nodeId) has any pvar bindings (perhaps qualified by @ rules that are still live).

   mvar ( * live ruleset)
   -> nodeId ( * live ruleset)
   -> ? Exists pvar * ruleno binding @ nodeId
   -> ? true or (ruleno in live ruleset)

The "result tuple" produced by a match (in the case of multiple pattern variables
for a given rule) has its components (mvars) in a well-defined "canonical" order.
What determines this order?  The set of pattern variables and their ordering (or
ordering of their corresponding mvars) is determined per rule (per layer?).


So, given a ramified rule (which could be represented by a ramifiedLHS value), for
each of the ramified patterns (which should all bind the same set of pattern variables),
we need to determine that set of pattern variables (in some defined order) and then
determine the associated mvars for the andor nodes where those pattern variables are
bound.  Thus, for each of the ramified patterns:

  pattern * ruleno   (ruleno will be the same for all patterns in the ramified set)
    -> pattern variable list (remembering initial ruleno)
    -> node list (where the pattern variables are bound _in this ruleno_)
    -> mvar list (mvars associated with the nodes)
    -> lexp record construction code (tuple of the mvars, evaluating to the tuple of
       values bound to the pattern variables). This tuple is passed to the "abstracted"
       RHS function. In case of a single pvar, the record construction is unnecessary
       and the value (mvar) is passed directly to the RHS function.
    -> RHS = application of "abstracted" rhs function to this record/mvar.  


================================================================================
Note on nodeIds vs paths:
-------------------------

It will probably be useful if the order of nodeIds is consistent with the descendent relation
on andor tree nodes.  I.e. path(n1) < path(n2) => id(n1) < id(n2).  (paths partially ordered
by prefix releation).

This relation should be easy to establish be assigning successive nodeIds in preorder traversal
as the andor tree is being constructed by the second pass (Andor2.translateAndor).

Of course, the nodeId ordering is less precise, so id(n1) < id(n2) =\=> path(n1) < path(n2). 


================================================================================
Note on type(s) needed in MC code generation:
---------------------------------------------

In the new style, the "raise Match" and "raise Bind" are generated at Fail nodes in the decision
tree. A normal (source) raise expression has, in its abstract syntax form, a type (Types.ty), which
is the type expected by the context of the raise, i.e. the type that would be returned at this
program point in the absence of the raise.  In the compilation of a match failure, where the raise
is "artificially" generated, the expected type is the "return type" type of the match, i.e. the
common type of the rhss of the rules.

In the original old MC, the match compiler did not generate new raise expressions (at detected match
failures).  Instead, for both bind and function/case/handler matches, additional "default" rules were
added such that the match would ultimately succeed, but sometimes with a raise rhs (from one of the added
default rules).  For general matches, this was done by the function completeMatch. For val binding matches,
the extra default rule was added in the Translate..mkVBs function. The mkVBs function is able to construct
a "rhsTy" that it includes in the Bind exception raise expression [translate.sml:l766-768]:

		    val rhsTy = BasicTypes.tupleTy(map (fn (V.VALvar{typ,...}) => !typ) newvars)
		    val bindRule = RULE(newpat, EU.TUPLEexp(newVarExps))
		    val defaultRule = RULE(WILDpat,
					   RAISEexp(CONexp(CoreAccess.getExn env ["Bind"],[]),rhsTy))
