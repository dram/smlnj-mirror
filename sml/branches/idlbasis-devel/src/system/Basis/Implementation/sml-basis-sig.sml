
(*
 * This file was automatically generated by ml-idl
 * (Fri Mar 16 15:45:50 2001)
 *)

(* comments added by dbm *)
(* all these should be OS independent, and are used in new OS independent
 * versions of modules that were previously Unix or Win32 specific *)
(* file paths are relative to src/system/Basis/Implementation/ *)

signature SML_BASIS = sig

(* /******************** Useful IDL types ********************/ *)
type idl_string = String.string

(* /******************** Common SML types ********************/ *)
type ML_word8vec_t = Word8Vector.vector
type ML_word8arr_t = Word8Array.array
type ML_charvec_t = CharVector.vector
type ML_chararr_t = CharArray.array
type ML_unit_t = unit
type ML_string_t = string
type ML_string_opt_t = string option
type ML_polldesc_list_t = poll_desc list
type ML_pollinfo_list_t = poll_info list

(* /******************** Exported run-time system types ********************/ *)
type IODesc_t = pointer
type Directory_t = pointer
type Time_t = {sec:Int32.int,usec:Int32.int}

(* /******************** Types for argument passing ********************/ *)
(* dbm: added missing tm_mon *)
type Date_t = {tm_sec:Int32.int,tm_min:Int32.int,tm_hour:Int32.int,tm_mday:Int32.int,tm_mon:Int32.int,tm_year:Int32.int,tm_wday:Int32.int,tm_yday:Int32.int,tm_isdst:Int32.int}

(* /******************** IEEEReal support ********************/ *)
(* Where used: ieee-real.sml *)
val TO_NEAREST : Int32.int
val TO_NEGINF : Int32.int
val TO_POSINF : Int32.int
val TO_ZERO : Int32.int
val getRoundingMode : unit -> Int32.int
val setRoundingMode : Int32.int -> unit

(* /******************** OSBinPrimIO and OSTextPrimIO support *************/ *)
(* Where used: OS/os-bin-prim-io.sml, OS/os-text-prim-io.sml
   These are OS generic versions replacing Unix/posix-{bin,text}-prim-io.sml
   and Win32/win32-{bin,text}-prim-io.sml *)
val openFile : (ML_string_t * Int32.int) -> IODesc_t
val closeFile : IODesc_t -> unit
val readTextVec : (IODesc_t * Int32.int) -> ML_charvec_t
val writeTextVec : (IODesc_t * ML_charvec_t * Int32.int * Int32.int) -> Int32.int
val readBinVec : (IODesc_t * Int32.int) -> ML_word8vec_t
val writeBinVec : (IODesc_t * ML_word8vec_t * Int32.int * Int32.int) -> Int32.int
    (* was writeBin *)
val readTextArr : (IODesc_t * Int32.int) -> ML_chararr_t
val writeTextArr : (IODesc_t * ML_chararr_t * Int32.int * Int32.int) -> Int32.int
val readBinArr : (IODesc_t * Int32.int) -> ML_word8arr_t
val writeBinArr : (IODesc_t * ML_word8arr_t * Int32.int * Int32.int) -> Int32.int
val IOD_KIND_FILE : Int32.int
val IOD_KIND_DIR : Int32.int
val IOD_KIND_SYMLINK : Int32.int
val IOD_KIND_TTY : Int32.int
val IOD_KIND_PIPE : Int32.int
val IOD_KIND_SOCKET : Int32.int
val IOD_KIND_DEVICE : Int32.int
val ioDescKind : IODesc_t -> Int32.int
val seek : (IODesc_t * Int32.int) -> Int32.int
val seekCur : (IODesc_t) -> Int32.int  (* maybe seek, seekCur should be combined *)
val nonBlockingSupported : bool
val blockingOn : IODesc_t -> ML_Unit_t
val blockingOff: IODesc_t -> ML_Unit_t
val updateStatus : IODesc_t * ML_bool_t * ML_bool_t -> ML_unit_t
val createFile : ML_string_t * ML_bool_t -> IODesc_t
(* missing: readTextArr, writeTextArr, readBinArr, writeBinArr, seek, seekCur,
 *   nonBlockingSupported, blockingOn, blockingOff, updateStatus, createFile *)

(* /******************** TextIO support ********************/ *)
(* Where used: OS/os-test-prim-io.sml *)
   
val getStdIn : unit -> IODesc_t
val getStdOut : unit -> IODesc_t
val getStdErr : unit -> IODesc_t

(* /******************** OSImp, OS.Process support ********************/ *)
(* Where used: Unix/os.sml?
               Win32/os.sml?
               Unix/os-process.sml?
               Win32/win32-process.sml?
   wait for generic OS support? *)
val errorName : Int32.int -> idl_string
val errorMessage : Int32.int -> idl_string
val getEnv : idl_string -> ML_string_opt_t
val sleep : Time_t -> unit  (* where used? *)

(* /******************** OS.FileSys support ********************/ *)
(* Where used: OS/os-filesys.sml
   This is a new OS generic FileSys structure, to replace Unix/os-filesys.sml
   and Win32/os-filesys.sml *)
val openDir : idl_string -> Directory_t
val readDir : Directory_t -> ML_string_opt_t
val rewindDir : Directory_t -> ML_unit_t
val closeDir : Directory_t -> ML_unit_t
val chDir : idl_string -> ML_unit_t
val getDir : unit -> ML_string_t
val mkDir : idl_string -> ML_unit_t   (* needs mode flags parameter? *)
val rmDir : idl_string -> ML_unit_t
val isDir : idl_string -> Bool.bool
val isLink : idl_string -> Bool.bool
val readLink : idl_string -> ML_string_t
val fullPath : idl_string -> ML_string_t
val realPath : idl_string -> ML_string_t
val setTime : (idl_string * Time_t option) -> ML_unit_t
val remove : idl_string -> ML_unit_t
val rename : (idl_string * idl_string) -> ML_unit_t
val A_READ : Int32.int
val A_WRITE : Int32.int
val A_EXEC : Int32.int
val access : (idl_string * Int32.int) -> Bool.bool
val tmpName : unit -> ML_string_t
val fileId : idl_string -> ML_word8vec_t
val fileSize : idl_string -> Int32.int
val modTime: idl_string -> Time_t
(* missing: fileSize, modTime *)

(* /******************** OS.IO support ********************/ *)
(* Where used: Unix/os-io.sml? 
               Win32/os-io.sml?
   wait for generic OS support *)
val poll : (ML_polldesc_list_t * Time_t option) -> ML_pollinfo_list_t

(* /******************** Time support ********************/ *)
(* Where used: ? *)
val now : unit -> Time_t

(* /******************** Date support ********************/ *)
(* Where used: date.sml *)
val gmTime : Time_t -> Date_t
val localTime : Time_t -> Date_t
(* missing: ascTime, mkTime, strfTime *)

(* /******************** Timer support ********************/ *)
(* Where used: internal-timer.sml
   If this is supposed to directly replace 
      CInterface.c_function "SMLNJ-Time" "gettime",
   then it has to provide more results, but probably its return values
   are combined seconds/microseconds *)
val getCPUTime : unit -> (Time_t * Time_t * Time_t)

end

(* 

SMLBasis.seek:
Unix: PIO.lseek(fd,p,PIO.SEEK_SET)
Win32: let val seek = pfw o W32IO.setFilePointer'
       in seek (W32FS.IODToHndl iod, ptw p, W32IO.FILE_BEGIN) end

SMLBasis.seekCur:
Unix: PIO.lseek(fd, pfi 0, PIO.SEEK_CUR)
Win32: let val seek = pfw o W32IO.setFilePointer'
       in seek (W32FS.IODToHndl iod, 0wx0, W32IO.FILE_CURRENT) end

SMLBasis.fileSize:
Unix: PF.ST.size(PF.fstat fd)
Windows: W32FS.getLowFileSize (W32FS.IODToHndl iod)

SMLBasis.blockingOn:
Unix: PIO.setfl(fd, PIO.O.flags[])
Win32: not supported

SMLBasis.blockingOff:
Unix: PIO.setfl(fd, PIO.O.nonblock)
Win32: not supported

SMLBasis.openFile(name,?):
Unix: PF.openf(name,PIO.O_RDONLY,PF.O.flags[])
Win32:
  let fun checkHndl name h = 
	if W32G.isValidHandle h then h
	else raise OS.SysErr ("win32-bin-prim-io:checkHndl: "^name^": failed",NONE)
   in checkHndl "openRd" (W32IO.createFile{name=name,
                                           access=W32IO.GENERIC_READ,
					   share=shareAll,
					   mode=W32IO.OPEN_EXISTING,
					   attrs=0wx0})
  end

SMLBasis.updateStatus(iod, appendMode: bool,blocking: bool): unit:
Unix: let val appendFS = PIO.O.flags(if appendMode then [PIO.O.append] else nil)
          val flgs = if blocking then appendFS
		      else PIO.O.flags[PIO.O.nonblock, appendFS]
       in PIO.setfl(fd, flgs)
      end
Win32: does nothing?

SMLBasis.createFile (append: bool):
Unix:
  let val standardMode = PF.S.flags[	(* mode 0666 *)
	    PF.S.irusr, PF.S.iwusr,
	    PF.S.irgrp, PF.S.iwgrp,
	    PF.S.iroth, PF.S.iwoth
	  ]
      fun createFile (name, mode, flags) =
	   PF.createf(name, mode, flags, standardMode)
   in if append then createFile(name, PIO.O_WRONLY, PF.O.append)
      else createFile(name, PIO.O_WRONLY, PF.O.trunc)
  end
Win32:
  let val mode = if append then W32IO.OPEN_EXISTING else W32IO.CREATE_ALWAYS
      fun checkHndl name h = 
	if W32G.isValidHandle h then h
	else raise OS.SysErr ("win32-bin-prim-io:checkHndl: "^name^": failed",NONE)
   in checkHndl "openWr"
       (W32IO.createFile{name=name,
			 access=W32IO.GENERIC_WRITE,
			 share=shareAll,
			 mode=W32IO.CREATE_ALWAYS,
			 attrs=W32FS.FILE_ATTRIBUTE_NORMAL
			 })
  end

*)