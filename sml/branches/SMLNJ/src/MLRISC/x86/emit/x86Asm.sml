(*
 * This file was automatically generated by MDGen
 * from the machine description file "x86/x86.md".
 *)


functor X86AsmEmitter(structure Instr : X86INSTR
                      structure Stream : INSTRUCTION_STREAM
                      structure Shuffle : X86SHUFFLE
                         where I = Instr

(*#line 140.1 "x86/x86.md"*)
                      structure MemRegs : MEMORY_REGISTERS where I=Instr
                     ) : INSTRUCTION_EMITTER =
struct
   structure I  = Instr
   structure C  = I.C
   structure S  = Stream
   structure P  = S.P
   structure LE = LabelExp
   structure Constant = I.Constant
   
   fun error msg = MLRiscErrorMsg.error("X86Asm",msg)
   
   fun makeStream formatAnnotations =
   let val stream = !AsmStream.asmOutStream
       fun emit' s = TextIO.output(stream,s)
       val newline = ref true
       val tabs = ref 0
       fun tabbing 0 = ()
         | tabbing n = (emit' "\t"; tabbing(n-1))
       fun emit s = (tabbing(!tabs); tabs := 0; newline := false; emit' s)
       fun nl() = (tabs := 0; if !newline then () else (newline := true; emit' "\n"))
       fun comma() = emit ","
       fun tab() = tabs := !tabs + 1
       fun ms n = let val s = Int.toString n
                  in  if n<0 then "-"^String.substring(s,1,size s-1)
                      else s
                  end
       fun emit_label lab = emit(Label.nameOf lab)
       fun emit_labexp le = emit(LabelExp.toString le)
       fun emit_const c = emit(Constant.toString c)
       fun emit_int i = emit(ms i)
       fun paren f = (emit "("; f(); emit ")")
       fun defineLabel lab = emit(Label.nameOf lab^":\n")
       fun entryLabel lab = defineLabel lab
       fun comment msg = emit("\t/* " ^ msg ^ " */")
       fun annotation a = (comment(Annotations.toString a); nl())
       fun blockName b = (comment(S.B.toString b); nl())
       fun emit_region mem = comment(I.Region.toString mem)
       fun pseudoOp pOp = emit(P.toString pOp)
       fun init size = (comment("Code Size = " ^ ms size); nl())
       fun doNothing _ = ()
       val emitRegInfo = AsmFormatUtil.reginfo(emit,formatAnnotations)
       fun emitter regmap =
       let

   fun emit_CC r = 
       ((emit (C.showCC (regmap r))); 
       (emitRegInfo r))
   and emit_FP r = 
       ((emit (C.showFP (regmap r))); 
       (emitRegInfo r))
   and emit_GP r = 
       ((emit (C.showGP (regmap r))); 
       (emitRegInfo r))

   fun asm_unaryOp (I.DEC) = "dec"
     | asm_unaryOp (I.INC) = "inc"
     | asm_unaryOp (I.NEG) = "neg"
     | asm_unaryOp (I.NOT) = "not"
   and emit_unaryOp x = (emit (asm_unaryOp x))
   and asm_fbinOp (I.FADDP) = "faddp"
     | asm_fbinOp (I.FADD) = "fadd"
     | asm_fbinOp (I.FMULP) = "fmulp"
     | asm_fbinOp (I.FMUL) = "fmul"
     | asm_fbinOp (I.FSUBP) = "fsubp"
     | asm_fbinOp (I.FSUB) = "fsub"
     | asm_fbinOp (I.FSUBRP) = "fsubrp"
     | asm_fbinOp (I.FSUBR) = "fsubr"
     | asm_fbinOp (I.FDIVP) = "fdivp"
     | asm_fbinOp (I.FDIV) = "fdiv"
     | asm_fbinOp (I.FDIVRP) = "fdivrp"
     | asm_fbinOp (I.FDIVR) = "fdivr"
   and emit_fbinOp x = (emit (asm_fbinOp x))
   and asm_funOp (I.FABS) = "fabs"
     | asm_funOp (I.FCHS) = "fchs"
   and emit_funOp x = (emit (asm_funOp x))
   and asm_move (I.MOVL) = "movl"
     | asm_move (I.MOVZX) = "movzx"
     | asm_move (I.MOVB) = "movb"
   and emit_move x = (emit (asm_move x))
   and asm_multDivOp (I.UMUL) = "umul"
     | asm_multDivOp (I.IDIV) = "idiv"
     | asm_multDivOp (I.UDIV) = "udiv"
   and emit_multDivOp x = (emit (asm_multDivOp x))
   and asm_binaryOp (I.ADD) = "add"
     | asm_binaryOp (I.SUB) = "sub"
     | asm_binaryOp (I.AND) = "and"
     | asm_binaryOp (I.OR) = "or"
     | asm_binaryOp (I.XOR) = "xor"
     | asm_binaryOp (I.SHL) = "shl"
     | asm_binaryOp (I.SAR) = "sar"
     | asm_binaryOp (I.SHR) = "shr"
   and emit_binaryOp x = (emit (asm_binaryOp x))
   and asm_cond (I.EQ) = "eq"
     | asm_cond (I.NE) = "ne"
     | asm_cond (I.LT) = "lt"
     | asm_cond (I.LE) = "le"
     | asm_cond (I.GT) = "gt"
     | asm_cond (I.GE) = "ge"
     | asm_cond (I.B) = "b"
     | asm_cond (I.BE) = "be"
     | asm_cond (I.A) = "a"
     | asm_cond (I.AE) = "ae"
     | asm_cond (I.C) = "c"
     | asm_cond (I.NC) = "nc"
     | asm_cond (I.P) = "p"
     | asm_cond (I.NP) = "np"
     | asm_cond (I.O) = "o"
     | asm_cond (I.NO) = "no"
   and emit_cond x = (emit (asm_cond x))
   val memReg = (MemRegs.memReg regmap)

   fun emitInt32 i = let

(*#line 144.1 "x86/x86.md"*)
          val s = (Int32.toString i)

(*#line 145.1 "x86/x86.md"*)
          val s = (if (i >= 0)
                then s
                else ("-" ^ (String.substring (s, 1, ((size s) - 1)))))
       in (emit s)
       end


   fun emit_src2 NONE = ()
     | emit_src2 (SOME i) = 
       ((emit "$"); 
       (emitInt32 i); 
       (emit ", "))

   fun emitScale 0 = (emit "1")
     | emitScale 1 = (emit "2")
     | emitScale 2 = (emit "4")
     | emitScale 3 = (emit "8")
     | emitScale _ = (error "emitScale")
   and eImmed (I.Immed i) = (emitInt32 i)
     | eImmed (I.Const c) = (emit_const c)
     | eImmed (I.ImmedLabel lexp) = (emit_labexp lexp)
     | eImmed _ = (error "eImmed")
   and emit_operand opn = 
       (
        case opn of
        I.Immed i => 
        ((emit "$"); 
        (emitInt32 i))
      | I.Const c => (emit_const c)
      | I.ImmedLabel lexp => 
        ((emit "$"); 
        (emit_labexp lexp))
      | I.LabelEA le => (emit_labexp le)
      | I.Relative _ => (error "emit_operand")
      | I.Direct r => (emit_GP r)
      | I.FDirect f => let

(*#line 171.1 "x86/x86.md"*)
           val f' = (regmap f)
        in (if (f' < (32 + 8))
              then (emit_FP f')
              else (emit_operand (memReg opn)))
        end

      | I.Displace{base, disp=I.Immed 0, mem, ...} => 
        ((emit "("); 
        (emit_GP base); 
        (emit ")"); 
        (emit_region mem))
      | I.Displace{base, disp, mem, ...} => 
        ((eImmed disp); 
        (emit "("); 
        (emit_GP base); 
        (emit ")"); 
        (emit_region mem))
      | I.Indexed{base=NONE, index, scale, disp, mem, ...} => 
        ((emit "("); 
        (emit_GP index); 
        (comma ()); 
        (emitScale scale); 
        (emit ")"); 
        (emit_region mem))
      | I.Indexed{base=SOME base, index, scale, disp, mem, ...} => 
        ((eOptionalDisp disp); 
        (emit "("); 
        (emit_GP base); 
        (comma ()); 
        (emit_GP index); 
        (comma ()); 
        (emitScale scale); 
        (emit ")"); 
        (emit_region mem))
       )
   and eOptionalDisp (I.Immed 0) = ()
     | eOptionalDisp (I.Const c) = (emit (Constant.toString c))
     | eOptionalDisp (I.Immed i) = (emitInt32 i)
     | eOptionalDisp _ = (error "eOptionalDisp")

   fun stupidGas (I.ImmedLabel lexp) = (emit_labexp lexp)
     | stupidGas (I.LabelEA _) = (error "stupidGas")
     | stupidGas opnd = (emit_operand opnd)
   val emit_dst = emit_operand
   val emit_src = emit_operand
   val emit_opnd = emit_operand
   val emit_src1 = emit_operand
   val emit_rsrc = emit_operand
   val emit_lsrc = emit_operand
   val emit_addr = emit_operand

   fun emitInstr instr = 
       ((tab ()); 
       
       (
        case instr of
        I.NOP => (emit "nop")
      | I.JMP(operand, label) => 
        ((emit "jmp\t"); 
        (stupidGas operand))
      | I.JCC{cond, opnd} => 
        ((emit "j"); 
        (emit_cond cond); 
        (emit ", "); 
        (stupidGas opnd))
      | I.CALL(operand, cellset1, cellset2, region) => 
        ((emit "call\t"); 
        (stupidGas operand); 
        (emit_region region))
      | I.RET operand => 
        ((emit "ret"); 
        
        (
         case operand of
         NONE => ()
       | SOME e => 
         ((emit "\t"); 
         (emit_operand e))
        ))
      | I.MOVE{mvOp, src, dst} => 
        ((emit_move mvOp); 
        (emit "\t"); 
        (emit_src src); 
        (emit ", "); 
        (emit_dst dst))
      | I.LEA{r32, addr} => 
        ((emit "leal\t"); 
        (emit_addr addr); 
        (emit ", "); 
        (emit_GP r32))
      | I.CMP{lsrc, rsrc} => 
        ((emit "cmpl\t"); 
        (emit_rsrc rsrc); 
        (emit ", "); 
        (emit_lsrc lsrc))
      | I.BINARY{binOp, src, dst} => 
        ((emit_binaryOp binOp); 
        (emit "l\t"); 
        (emit_src src); 
        (emit ", "); 
        (emit_dst dst))
      | I.MULTDIV{multDivOp, src} => 
        ((emit_multDivOp multDivOp); 
        (emit "l\t"); 
        (emit_src src))
      | I.MUL3{dst, src1, src2} => 
        ((emit "imul\t"); 
        (emit_src1 src1); 
        (emit ", "); 
        (emit_src2 src2); 
        (emit_int dst))
      | I.UNARY{unOp, opnd} => 
        ((emit_unaryOp unOp); 
        (emit "l\t"); 
        (emit_opnd opnd))
      | I.PUSH operand => 
        ((emit "pushl\t"); 
        (emit_operand operand))
      | I.POP operand => 
        ((emit "popl\t"); 
        (emit_operand operand))
      | I.CDQ => (emit "cdq")
      | I.INTO => (emit "into")
      | I.COPY{dst, src, tmp} => (emitInstrs (Shuffle.shuffle {regmap=regmap, tmp=tmp, dst=dst, src=src}))
      | I.FCOPY{dst, src, tmp} => (emitInstrs (Shuffle.shufflefp {regmap=regmap, tmp=tmp, dst=dst, src=src}))
      | I.FBINARY{binOp, src, dst} => 
        ((emit_fbinOp binOp); 
        (emit "\t"); 
        (emit_src src); 
        (emit ", "); 
        (emit_dst dst))
      | I.FUNARY funOp => (emit_funOp funOp)
      | I.FUCOMPP => (emit "fucompp")
      | I.FXCH => (emit "fxch")
      | I.FSTP operand => 
        ((emit "fstp\t"); 
        (emit_operand operand))
      | I.FLD operand => 
        ((emit "fld\t"); 
        (emit_operand operand))
      | I.FILD operand => 
        ((emit "fild\t"); 
        (emit_operand operand))
      | I.FNSTSW => (emit "fnstsw")
      | I.SAHF => (emit "sahf")
      | I.ANNOTATION{i, a} => 
        ((emitInstr i); 
        (comment (Annotations.toString a)))
      | I.GROUP annotation => (comment (Annotations.toString annotation))
       ); 
       (nl ()))
          and emitInstrs [] = ()
            | emitInstrs (i::is) =
           (emitInstr i; app (fn i => (tab(); emitInstr i)) is)
      in  emitInstr end
   
   in  S.STREAM{beginCluster=init,
                pseudoOp=pseudoOp,
                emit=emitter,
                endCluster=doNothing,
                defineLabel=defineLabel,
                entryLabel=entryLabel,
                comment=comment,
                exitBlock=doNothing,
                blockName=blockName,
                annotation=annotation,
                phi=doNothing,
                alias=doNothing
               }
   end
end

