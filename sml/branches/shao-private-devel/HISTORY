This is the HISTORY file for the Yale SML/NJ CVS repository.

An entry should be made for _every_ commit to the repository.
The entries in this file will be used when creating the README
for new versions, so keep that in mind when writing the
description.

The form of an entry should be:

Name: 
Date: yyyy/mm/dd
Tag: <post-commit CVS tag>
Description:

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2002/02/26 12:00:00 EST
Tag: blume-20020226-ffi
Description:

1. Fixed a minor bug in CM's "noweb" tool:
   If numbering is turned off, then truly don't number (i.e., do not
   supply the -L option to noweb).  The previous behavior was to supply
   -L'' -- which caused noweb to use the "default" line numbering scheme.
   Thanks to Chris Richards for pointing this out (and supplying the fix).

2. Once again, I reworked some aspects of the FFI:

   A. The incomplete/complete type business:

   - Signatures POINTER_TO_INCOMPLETE_TYPE and accompanying functors are
     gone!
   - ML types representing an incomplete type are now *equal* to
     ML types representing their corresponding complete types (just like
     in C).  This is still safe because ml-nlffigen will not generate
     RTTI for incomplete types, nor will it generate functions that
     require access to such RTTI.   But when ML code generated from both
     incomplete and complete versions of the C type meet, the ML types
     are trivially interoperable.

     NOTE:  These changes restore the full generality of the translation
     (which was previously lost when I eliminated functorization)!

   B. Enum types:

   - Structure C now has a type constructor "enum" that is similar to
     how the "su" constructor works.  However, "enum" is not a phantom
     type because each "T enum" has values (and is isomorphic to
     MLRep.Signed.int).
   - There are generic access operations for enum objects (using
     MLRep.Signed.int).
   - ml-nlffigen will generate a structure E_foo for each "enum foo".
     * The structure contains the definition of type "mlrep" (the ML-side
     representation type of the enum).  Normally, mlrep is the same
     as "MLRep.Signed.int", but if ml-nlffigen was invoked with "-ec",
     then mlrep will be defined as a datatype -- thus facilitating
     pattern matching on mlrep values.
     ("-ec" will be suppressed if there are duplicate values in an
      enumeration.)
     * Constructors ("-ec") or values (no "-ec") e_xxx of type mlrep
     will be generated for each C enum constant xxx.
     * Conversion functions m2i and i2m convert between mlrep and
     MLRep.Signed.int.  (Without "-ec", these functions are identities.)
     * Coversion functions c and ml convert between mlrep and "tag enum".
     * Access functions (get/set) fetch and store mlrep values.
   - By default (unless ml-nlffigen was invoked with "-nocollect"), unnamed
     enumerations are merged into one single enumeration represented by
     structure E_'.

----------------------------------------------------------------------
Name: Allen Leung
Date: 2002/02/25 04:45:00 EST
Tag: leunga-20020225-cps-spill

This is a new implementation of the CPS spill phase.
The new phase is in the new file compiler/CodeGen/cpscompile/spill-new.sml
In case of problems, replace it with the old file spill.sml

The current compiler runs into some serious performance problems when 
constructing a large record.  This can happen when we try to compile a
structure with many items.  Even a very simple structure like the following
makes the compiler slow down.

    structure Foo = struct
       val x_1 = 0w1 : Word32.int
       val x_2 = 0w2 : Word32.int
       val x_3 = 0w3 : Word32.int
       ...
       val x_N = 0wN : Word32.int
    end

The following table shows the compile time, from N=1000 to N=4000, 
with the old compiler:

N
1000   CPS 100 spill                           0.04u  0.00s  0.00g  
       MLRISC ra                               0.06u  0.00s  0.05g  
          (spills = 0 reloads = 0)
       TOTAL                                   0.63u  0.07s  0.21g  

1100   CPS 100 spill                           8.25u  0.32s  0.64g  
       MLRISC ra                               5.68u  0.59s  3.93g  
          (spills = 0 reloads = 0)
       TOTAL                                   14.71u  0.99s  4.81g  

1500   CPS 100 spill                           58.55u  2.34s  1.74g  
       MLRISC ra                               5.54u  0.65s  3.91g  
          (spills = 543 reloads = 1082)
       TOTAL                                   65.40u  3.13s  6.00g  

2000   CPS 100 spill                           126.69u  4.84s  3.08g  
       MLRISC ra                               0.80u  0.10s  0.55g  
          (spills = 42 reloads = 84)
       TOTAL                                   129.42u  5.10s  4.13g 

3000   CPS 100 spill                           675.59u  19.03s  11.64g  
       MLRISC ra                               2.69u  0.27s  1.38g  
          (spills = 62 reloads = 124)
       TOTAL                                   682.48u  19.61s  13.99g  

4000   CPS 100 spill                           2362.82u  56.28s  43.60g  
       MLRISC ra                               4.96u  0.27s  2.72g  
          (spills = 85 reloads = 170)
       TOTAL                                   2375.26u  57.21s  48.00g  

As you can see the old cps spill module suffers from some serious 
performance problem but since I cannot decipher the old code fully, 
innstead of patching the problems up, I'm reimplementing it 
with a different algorithm.  The new code is more modular, 
smaller when compiled, and substantially faster 
(O(n log n) time and O(n) space).  Timing of the new spill module: 

4000  CPS 100 spill                           0.02u  0.00s  0.00g  
      MLRISC ra                               0.25u  0.02s  0.15g  
         (spills=1 reloads=3) 
      TOTAL                                   7.74u  0.34s  1.62g 

Implementation details:

As far as I can tell, the purpose of the CPS spill module is to make sure the 
number of live variables at any program point (the bandwidth) 
does not exceed a certain limit, which is determined by the 
size of the spill area.  

When the bandwidth is too large, we decrease the register pressure by 
packing live variables into spill records.  How we achieve this is
completely different than what we did in the old code.

First, there is something about the MLRiscGen code generator 
that we should be aware of:

o MLRiscGen performs code motion!
 
   In particular, it will move floating point computations and
   address computations involving only the heap pointer to 
   their use sites (if there is only a single use).  
   What this means is that if we have a CPS record construction
   statement
 
       RECORD(k,vl,w,e)
 
   we should never count the new record address w as live if w 
   has only one use (which is often the case).
 
   We should do something similar to floating point, but the transformation
   there is much more complex, so I won't deal with that.

Secondly, there are now two new cps primops at our disposal:

 1. rawrecord of record_kind option 
    This pure operator allocates some uninitialized storage from the heap.
    There are two forms:
 
     rawrecord NONE [INT n]  allocates a tagless record of length n
     rawrecord (SOME rk) [INT n] allocates a tagged record of length n
                                 and initializes the tag.
 
 2. rawupdate of cty
      rawupdate cty (v,i,x) 
      Assigns to x to the ith component of record v.
      The storelist is not updated.
 
We use these new primops for both spilling and increment record construction.
 
 1. Spilling.
    
    This is implemented with a linear scan algorithm (but generalized
    to trees).  The algorithm will create a single spill record at the
    beginning of the cps function and use rawupdate to spill to it,
    and SELECT or SELp to reload from it.  So both spills and reloads
    are fine-grain operations.  In contrast, in the old algorithm 
    "spills" have to be bundled together in records.  
 
    Ideally, we should sink the spill record construction to where
    it is needed.  We can even split the spill record into multiple ones
    at the places where they are needed.  But CPS is not a good
    representation for global code motion, so I'll keep it simple and
    am not attempting this.
 
 2. Incremental record construction (aka record splitting).

    Long records with many component values which are simulatenously live
    (recall that single use record addresses are not considered to 
     be live) are constructed with rawrecord and rawupdate.
    We allocate space on the heap with rawrecord first, then gradually
    fill it in with rawupdate.  This is the technique suggested to me
    by Matthias.
 
    Some restrictions on when this is applicable:
    1. It is not a VECTOR record.  The code generator currently does not handle
       this case. VECTOR record uses double indirection like arrays.
    2. All the record component values are defined in the same "basic block" 
       as the record constructor.  This is to prevent speculative 
       record construction. 

----------------------------------------------------------------------
Name: Allen Leung
Date: 2002/02/22 01:02:00 EST
Tag: leunga-20020222-mlrisc-tools

Minor bug fixes in the parser and rewriter

----------------------------------------------------------------------
Name: Allen Leung
Date: 2002/02/21 20:20:00 EST
Tag: leunga-20020221-peephole

Regenerated the peephole files.  Some contained typos in the specification
and some didn't compile because of pretty printing bugs in the old version
of 'nowhere'.

----------------------------------------------------------------------
Name: Allen Leung
Date: 2002/02/19 20:20:00 EST
Tag: leunga-20020219-mlrisc-tools
Description:

   Minor bug fixes to the mlrisc-tools library:

   1.  Fixed up parsing colon suffixed keywords
   2.  Added the ability to shut the error messages up
   3.  Reimplemented the pretty printer and fixed up/improved
       the pretty printing of handle and -> types.
   4.  Fixed up generation of literal symbols in the nowhere tool.
   5.  Added some SML keywords to to sml.sty

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2002/02/19 16:20:00 EST
Tag: blume-20020219-cmffi
Description:

A wild mix of changes, some minor, some major:

* All C FFI-related libraries are now anchored under $c:
    $/c.cm      --> $c/c.cm
    $/c-int.cm  --> $c/internals/c-int.cm
    $/memory.cm --> $c/memory/memory.cm

* "make" tool (in CM) now treats its argument pathname slightly
  differently:
    1. If the native expansion is an absolute name, then before invoking
       the "make" command on it, CM will apply OS.Path.mkRelative
       (with relativeTo = OS.FileSys.getDir()) to it.
    2. The argument will be passed through to subsequent phases of CM
       processing without "going native".  In particular, if the argument
       was an anchored path, then "make" will not lose track of that anchor.

* Compiler backends now "know" their respective C calling conventions
  instead of having to be told about it by ml-nlffigen.  This relieves
  ml-nlffigen from one of its burdens.

* The X86Backend has been split into X86CCallBackend and X86StdCallBackend.

* Export C_DEBUG and C_Debug from $c/c.cm.

* C type encoding in ml-nlffi-lib has been improved to model the conceptual
  subtyping relationship between incomplete pointers and their complete
  counterparts.  For this, ('t, 'c) ptr has been changed to 'o ptr --
  with the convention of instantiating 'o with ('t, 'c) obj whenever
  the pointer target type is complete.  In the incomplete case, 'o
  will be instantiated with some "'c iobj" -- a type obtained by
  using one of the functors PointerToIncompleteType or PointerToCompleteType.

  Operations that work on both incomplete and complete pointer types are
  typed as taking an 'o ptr while operations that require the target to
  be known are typed as taking some ('t, 'c) obj ptr.

  voidptr is now a bit "more concrete", namely "type voidptr = void ptr'"
  where void is an eqtype without any values.  This makes it possible
  to work on voidptr values using functions meant to operate on light
  incomplete pointers.

* As a result of the above, signature POINTER_TO_INCOMPLETE_TYPE has
  been vastly simplified.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2002/02/19 10:48:00 EST
Tag: blume-20020219-pqfix
Description:

Applied Chris Okasaki's bug fix for priority queues.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2002/02/15 17:05:00
Tag: Release_110_39
Description:

Last-minute retagging is becoming a tradition... :-(

This is the working release 110.39.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2002/02/15 16:00:00 EST
Tag: Release_110_39-orig
Description:

Working release 110.39.  New bootfiles.

(Update: There was a small bug in the installer so it wouldn't work
with all shells.  So I retagged. -Matthias)

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2002/02/15 14:17:00 EST
Tag: blume-20020215-showbindings
Description:

Added EnvRef.listBoundSymbols and CM.State.showBindings.  Especially
the latter can be useful for exploring what bindings are available at
the interactive prompt.  (The first function returns only the list
of symbols that are really bound, the second prints those but also the
ones that CM's autoloading mechanism knows about.)

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2002/02/15 12:08:00 EST
Tag: blume-20020215-iptrs
Description:

Two improvements to ml-nlffigen:

  1. Write files only if they do not exist or if their current contents
     do not coincide with what's being written.  (That is, avoid messing
     with the time stamps unless absolutely necessary.)

  2. Implement a "repository" mechanism for generated files related
     to "incomplete pointer types".   See the README file for details.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2002/02/14 11:50:00 EST
Tag: blume-20020214-quote
Description:

Added a type 't t_' to tag.sml (in ml-nlffi-lib.cm).  This is required
because of the new and improved tag generation scheme.  (Thanks to Allen
Leung for pointing it out.)

----------------------------------------------------------------------
Name: Lal George
Date: 2002/02/14 09:55:27 EST 2002
Tag: george-20020214-isabelle-bug
Description: 

Fixed the MLRISC bug sent by Markus Wenzel regarding the compilation
of Isabelle on the x86.

From Allen:
-----------
 I've found the problem:  

     in ra-core.sml, I use the counter "blocked" to keep track of the
     true number of elements in the freeze queue.  When the counter goes
     to zero, I skip examining the queue.  But I've messed up the
     bookkeeping in combine():

         else ();
         case !ucol of
           PSEUDO => (if !cntv > 0 then 
                 (if !cntu > 0 then blocked := !blocked - 1 else (); 
                                    ^^^^^^^^^^^^^^^^^^^^^^^
                  moveu := mergeMoveList(!movev, !moveu)
                 )
              else ();  
             
     combine() is called to coalesce two nodes u and v.
     I think I was thinking that if the move counts of u and v are both
     greater than zero then after they are coalesced then one node is
     removed from the freeze queue.  Apparently I was thinking that
     both u and v are of low degree, but that's clearly not necessarily true.
 

02/12/2002:
    Here's the patch.  HOL now compiles.

    I don't know how this impact on performance (compile
    time or runtime).  This bug caused the RA (especially on the x86) 
    to go thru the potential spill phase when there are still nodes on the
    freeze queue.




----------------------------------------------------------------------
Name: Matthias Blume
Date: 2002/02/13 22:40:00 EST
Tag: blume-20020213-fptr-rtti
Description:

Fixed a bug in ml-nlffigen that was introduced with one of the previous
updates.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2002/02/13 16:41:00 EST
Tag: blume-20020213-cmlpq
Description:

Added new priority queue export symbols (which have just been added to
smlnj-lib.cm) to CML's version of smlnj-lib.cm.  (Otherwise CML would
not compile and the installer would choke.)

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2002/02/13 16:15:00 EST
Tag: blume-20020213-various
Description:

1. More tweaks to ml-nlffigen:

   - better internal datastructures (resulting in slight speedup)
   - "-match" option requires exact match
   - "localized" gensym counters (untagged structs/unions nested within
     other structs/unions or within typedefs get a fresh counter; their
     tag will be prefixed by a concatenation of their parents' tags)
   - bug fixes (related to calculation of transitive closure of types
     to be included in the output)

2. Minor Basis updates:

   - added implementations for List.collate and Option.app

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2002/02/11 15:55:00 EST
Tag: blume-20020211-gensym
Description:

Added a "-gensym" option to command line of ml-nlffigen.  This can be
used to specify a "stem" -- a string that is inserted in all "gensym'd"
names (ML structure names that correspond to unnamed C structs, unions,
and enums), so that separate runs of ml-nlffigen do not clash.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2002/02/11 12:05:00 EST
Tag: blume-20020211-gensml
Description:

A quick fix for a problem with GenSML (in the pgraph-util library):
Make generation of toplevel "local" optional.  (Strictly speaking,
signature definitions within "local" are not legal SML.)

Other than that: updates to INSTALL and cm/TODO.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2002/02/08 15:00:00 EST
Tag: blume-20020208-uniquepid
Description:

0. Version number has been bumped to 110.38.1.  NEW BOOTFILES!!!

1. The installer (config/install.sh) has gotten smarter:

     - Configuration options are a bit easier to specify now
       (in config/targets).
     - Bug in recognizing .tar.bz2 files fixed.
     - Installer automatically resolves dependencies between
       configuration options (e.g., if you ask for eXene, you will
       also get cml -- regardless whether you asked for it or not).
     - Installer can run in "quieter mode" by setting the environment
       variable INSTALL_QUIETLY to "true".  "Quieter" does not mean
       "completely silent", though.
     - Build HashCons library as part of smlnj-lib.

2. A new scheme for assigning persistent identifiers to compilation
   units (and, by extension, to types etc.) has been put into place.
   This fixes a long-standing bug where types and even dynamic values
   can get internally confused, thereby compromising type safety
   (abstraction) and dynamic correctness.  See

     http://cm.bell-labs.com/cm/cs/who/blume/pid-confusion.tgz

   for an example of how things could go wrong until now.

   The downside of the new scheme is that pids are not quite as
   persistent as they used to be: CM will generate a fresh pid
   for every compilation unit that it thinks it sees for the first
   time.  That means that if you compile starting from a clean, fresh
   source tree at two different times, you end up with different
   binaries.

   Cutoff recompilation, however, has not been compromised because
   CM keeps pid information in special caches between runs.

----------------------------------------------------------------------
Name: Lal George
Date: 2002/02/07 15:34:13 EST 2002
Tag: <none>
Description:

Compilers that generate assembly code may produce  global labels 
whose value is resolved at link time. The various peephole optimization
modules did not take this in account.

TODO. The Labels.addrOf function should really return an option
type so that clients are forced to deal with this issue, rather
than an exception being raised.

----------------------------------------------------------------------
Name: Lal George
Date: 2002/02/06 13:55:02 EST
Tag: george-20020206-ra-breakup
Description:

1. A bug fix from Allen.

    A typo causes extra fstp %st(0)'s to be generated at compensation
    edges, which might cause stack underflow traps at runtime.  This
    occurs in fft where there are extraneous fstps right before the 'into'
    trap instruction (in this case they are harmless since none of the
    integers overflow.)

2. Pulled out various utility modules that were embedded in the modules
   of the register allocator. I need these modules for other purposes, but
   they are not complete enough to put into a library (just yet).
----------------------------------------------------------------------
Name: Matthias Blume
Date: 2002/01/31 16:05:00 EST
Tag: blume-20020131-sparc-ccalls
Description:

1. C-calls on Sparc needlessly allocated a huge chunk (96 bytes)
   of extra stack space by mistake.  Fixed.

2. Bug in logic of handling of command-line options in ml-nlffigen fixed.

----------------------------------------------------------------------
Name: Allen Leung
Date: 2002/01/30
Tag: leunga-20020130-nowhere-bug-fix
Description:

   MLRISC bug fixes:
   1. Fixed a bindings computation bug in the 'nowhere' program generator tool.
   2. MachineInt.fromString was negating its value.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2002/01/29
Tag: blume-20020129-INSTALL
Description:

- Added somewhat detailed installation instructions (file INSTALL).
- Fixed curl-detection bug in config/install.sh.
- It is now possible to select the URL getter using the URLGETTER
  environment variable:

      not set / "unknown"      --> automatic detection (script tries wget,
                                   curl, and lynx)
      "wget" / "curl" / "lynx" --> use the specified program (script "knows"
                                   how to properly invoke them)
      other                    --> use $URLGETTER directly, it must take
                                   precisely two command-line arguments
                                   (source URL and destination file name)

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2002/01/28
Tag: blume-20020128-sparc-ccalls
Description:

- Fixed problem with calculation of "used" registers in sparc-c-calls.
- Make use of the allocParam argument in sparc-c-calls.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2002/01/28
Tag: blume-20020128-allocParam
Description:

John Reppy:  Changes c-calls API to accept client-callback for
allocating extra stack space.
me: Corresponding changes to mlriscGen (using a dummy argument that
    does not change the current behavior).

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2002/01/28 12:00:00
Tag: Release_110_38
Description:

This time for real!!!

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2002/01/28 10:56:00 EST
Tag: blume-20020128-retraction
Description:

0. Retracted earlier 110.38.  (The Release_110_38 tag has been replaced
   with blume-Release_110_38-retracted.)

1. Fixed a problem with incorrect rounding modes in real64.sml.
   (Thanks to Andrew Mccreight <andrew.mccreight@yale.edu>.)

2. A bug in ml-nlffigen related to the handling of unnamed structs, unions,
   and enums fixed.  The naming of corresponding ML identifiers should 
   now be consistent again.

----------------------------------------------------------------------
Name: Allen Leung
Date: 2002/01/27 
Tag: leunga-20020127-nowhere
Description:

   Added a target called nowhere in the configuration scripts.
   Enabling this will build the MLRISC 'nowhere' tool (for translating 
   programs with where-clauses into legal SML code) during installation.  

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2002/01/25 21:27:00 EST
Tag: blume-Release_110_38-retracted
Description:

Call it a (working) release!  Version is 110.38. Bootfiles are ready.

README will be added later.

!!! NOTE:  Re-tagged as blume-Release_110_38-retracted. Original tag
(Release_110_38) removed.  Reason: Last-minute bug fixes.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2002/01/25
Tag: blume-20020125-ffi
Description:

A large number of tweaks and improvements to ml-nlffi-lib and
ml-nlffigen:

   - ML represenation types have been streamlined
   - getter and setter functions work with concrete values, not abstract
     ones where possible
   - ml-nlffigen command line more flexible (see README file there)
   - some bugs have been fixed (hopefully)

----------------------------------------------------------------------
Name: Lal George
Date: 2002/01/24
Tag: george-20020124-risc-ra-interface
Description:

   There is a dramatic simplification in the interface to the
   register allocator for RISC architectures as a result of making 
   parallel copy instructions explicit. 
   
----------------------------------------------------------------------
Name: Matthias Blume
Date: 2002/01/22
Tag: blume-20020122-x86-ccalls
Description:

Bug fix for c-calls on x86 (having to do with how char- and
short-arguments are being handled).

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2002/01/21
Tag: blume-20020121-ff
Description:

Another day of fiddling with the FFI...

1. Bug fix/workaround:  CKIT does not complain about negative array
   dimensions, so ml-nlffigen has to guard itself against this possibility.
   (Otherwise a negative dimension would send it into an infinite loop.)

2. Some of the abstract types (light objects, light pointers, most "base"
   types) in structure C are now eqtypes.

3. Added constructors and test functions for NULL function pointers.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2002/01/18
Tag: blume-20020118-ready-for-new-release
Description:

Made config/srcarchiveurl point to a new place.  (Will provide boot
files shortly.)

Maybe we christen this to be 110.38?

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2002/01/18
Tag: blume-20020118-more-ffifiddle
Description:

Today's FFI fiddling:

  - Provided a structure CGetSet with "convenient" versions of C.Get.* and
    C.Set.* that use concrete (MLRep.*) arguments and results instead
    of abstract ones.

  - Provided word-style bit operations etc. for "int" representation
    types in MLRep.S<Foo>Bitops where <Foo> ranges over Char, Int, Short,
    and Long.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2002/01/18
Tag: blume-20020118-use-x86-fp
Description:

Now that x86-fast-fp seems to be working, I turned it back on again
by default.  (Seems to work fine now, even with the FFI.)

Other than that, I added some documentation about the FFI to
src/ml-nlffigen/README and updated the FFI test examples in
src/ml-nlffi-lib/Tests/*.

----------------------------------------------------------------------
Name: Allen Leung
Date: 2002/01/17
Tag: leunga-20020117-x86-fast-fp-call
Description:

   1. Fixed a problem with handling return fp values when x86's fast fp
      mode is turned on.  

   2. Minor pretty printing fix for cellset.  Print %st(0) as %st(0) instead
      of %f32.

   3. Added a constructor INT32lit to the ast of MLRISC tools.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2002/01/16
Tag: blume-20020116-ffifiddle
Description:

More fiddling with the FFI interface:

 - Make constness 'c instead of rw wherever possible.  This eliminates
   the need for certain explicit coercions.  (However, due to ML's
   value polymorphism, there will still be many cases where explicit
   coercions are necessary.  Phantom types are not the whole answer
   to modeling a subtyping relationship in ML.)

 - ro/rw coersions for pointers added.  (Avoids the detour through */&.)

 - "printf" test example added to src/ml-nlffi-lib/Tests.  (Demonstrates
   clumsy workaround for varargs problem.)

----------------------------------------------------------------------
Name: Lal George
Date: 2002/01/15
Tag: <none>
Description:

1. Since COPY instructions are no longer native to the architecture, 
   a generic functor can be used to implement the expandCopies function.

2. Allowed EXPORT and IMPORT pseudo-op declarations to appear inside a
   TEXT segment.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2002/01/15
Tag: blume-20020115-ffiupdates
Description:

1. Fix for bug resulting in single-precision float values being returned
   incorrectly from FFI calls.

2. Small modifications to C FFI API:

    - memory-allocation routines return straight objects (no options)
      and raise an exception in out-of-memory situations
    - unsafe extensions to cast between function pointers and pointers
      from/to ints
    - added structure C_Debug as an alternative to structure C where
      pointer-dereferencing (|*| and |*!) always check for null-pointers
    - added open_lib' to DynLinkage;  open_lib' works like open_lib
      but also takes a (possibly empty) list of existing library handles
      that the current library depends on

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2002/01/10
Tag: blume-20020110-newffigen
Description:

1. Updates to portable graph code.

2. Major update to ml-nlffigen and ml-nlffi-lib.  Things are much
   more scalable now so that even huge interfaces such as the one
   for GTK compile in finite time and space. :-)
   See src/ml-nlffigen/README for details on what's new.

----------------------------------------------------------------------
Name: Lal George
Date: 2001/01/09 14:31:35 EST 2002
Tag: george-20011206-rm-native-copy
Description:

	Removed the native COPY and FCOPY instructions
	from all the architectures and replaced it with the
	explicit COPY instruction from the previous commit.

	It is now possible to simplify many of the optimizations
	modules that manipulate copies. This has not been
	done in this change.

----------------------------------------------------------------------
Name: Lal George
Date: 2001/12/06 16:50:13 EST 2001
Tag: george-20011206-mlrisc-instruction
Description:

Changed the representation of instructions from being fully abstract 
to being partially concrete. That is to say: 

  from
	type instruction

  to
	type instr				(* machine instruction *)

	datatype instruction = 	
	    LIVE of {regs: C.cellset, spilled: C.cellset}
          | KILL of {regs: C.cellset, spilled: C.cellset}
          | COPYXXX of {k: CB.cellkind, dst: CB.cell list, src: CB.cell list}
          | ANNOTATION of {i: instruction, a: Annotations.annotation}
          | INSTR of instr

This makes the handling of certain special instructions that appear on
all architectures easier and uniform.

LIVE and KILL say that a list of registers are live or killed at the 
program point where they appear. No spill code is generated when an
element of the 'regs' field is spilled, but the register is moved to 
the 'spilled' (which is present, more for debugging than anything else).

LIVE replaces the (now deprecated) DEFFREG instruction on the alpha.
We used to generate:

	DEFFREG f1
	f1 := f2 + f3
        trapb

but now generate:

	f1 := f2 + f3
	trapb
	LIVE {regs=[f1,f2,f3], spilled=[]}

Furthermore, the DEFFREG (hack) required that all floating point instruction
use all registers mentioned in the instruction. Therefore f1 := f2 + f3, 
defines f1 and uses [f1,f2,f3]! This hack is no longer required resulting 
in a cleaner alpha implementation. (Hopefully, intel will not get rid of 
this architecture).

COPYXXX is intended to replace the parallel COPY and FCOPY  available on 
all the architectures. This will result in further simplification of the
register allocator that must be aware of them for coalescing purposes, and 
will also simplify certain aspects of the machine description that provides
callbacks related to parallel copies. 

ANNOTATION should be obvious, and now INSTR represents the honest to God
machine instruction set!

The <arch>/instructions/<arch>Instr.sml files define certain utility 
functions for making porting easier -- essentially converting upper case
to lower case. All machine instructions (of type instr) are in upper case,
and the lower case form generates an MLRISC instruction. For example on 
the alpha we have:

  datatype instr =
     LDA of {r:cell, b:cell, d:operand}
   | ...

  val lda : {r:cell, b:cell, d:operand} -> instruction
    ...

where lda is just (INSTR o LDA), etc.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/11/22 21:40:00 EST
Tag: Release_110_37
Description:

Release 110.37.  This time for real.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/11/21 16:35:00 EST
Tag: blume-20011121-foot-in-mouth
Description:

Removed the "Release_110_37" tag because of a serious bug.
This will be re-tagged once the bug is fixed.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/11/21 16:14:00 EST
Tag: blume-20011121-forgottenfile
Description:

Forgot to add a file.  (Just a .tex-file -- part of
the CM manual source.)

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/11/21 16:10:00 EST
Tag: blume-20011121-invalid_110_37
Description:

Note: I removed the original tag "Release_110_37" from this commit
      because we found a serious bug in all non-x86 backends.
      - Matthias

1. Modifications to the SML/NJ code generator and to the runtime system
   so that code object name strings are directly inserted into code
   objects at code generation time.  The only business the runtime system
   has with this is now to read the name strings on occasions.
   (The encoding of the name string has also changed somewhat.)

2. CM now implements a simple "set calculus" for specifying export lists.
   In particular, it is now possible to refer to the export lists of
   other libraries/groups/sources and form unions as well as differences.
   See the latest CM manual for details.

3. An separate notion of "proxy" libraries has again be eliminated from
   CM's model.  (Proxy libraries are now simply a special case of using
   the export list calculus.)

4. Some of the existing libraries now take advantage of the new set
   calculus.
   (Notice that not all libraries have been converted because some
   of the existing .cm-files are supposed to be backward compatible
   with 110.0.x.)

5. Some cleanup in stand-alone programs.  (Don't use "exnMessage" -- use
   "General.exnMessage"!  The former relies on a certain hook to be
   initialized, and that often does not happen in the stand-alone case.)

----------------------------------------------------------------------
Name: Lal George
Date: 2001/11/21  13:56:18 EST
Tag: george-2001121-pseudo-ops
Description:

  Implemented a complete redesign of MLRISC pseudo-ops. Now there
  ought to never be any question of incompatabilities with 
  pseudo-op syntax expected by host assemblers.

  For now, only modules supporting GAS syntax are implemented
  but more should follow, such as MASM, and vendor assembler
  syntax, e.g. IBM as, Sun as, etc.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/11/14 11:52:00 EST
Tag: blume-20011114-srcname
Description:

1. Routed the name of the current source file to mlriscgen where it
   should be directly emitted into the code object.  (This last part
   is yet to be done.)

2. Some cleanup of the pgraph code to make it match the proposal that
   I put out the other day.  (The proposal notwithstanding, things are
   still in flux here.)

----------------------------------------------------------------------
Name: Lal George
Date: 2001/11/14 09:44:04 EST 
Tag: 
Description:

  Fix for a backpatching bug reported by Allen.

  Because the boundary between short and long span-dependent 
  instructions is +/- 128, there are an astounding number of
  span-dependent instructions whose size is over estimated. 

  Allen came up with the idea of letting the size of span 
  dependent instructions be non-monotonic, for a maxIter
  number of times, after which the size must be monotonically
  increasing.
  
  This table shows the number of span-dependent instructions
  whose size was over-estimated as a function of maxIter, for the
  file Parse/parse/ml.grm.sml:
 
     maxIter		# of instructions:
 	10			687
 	20			438
 	30			198
        40			  0
 
  In compiling the compiler, there is no significant difference in
  compilation speed between maxIter=10 and maxIter=40. Actually, 
  my measurements showed that maxIter=40 was a tad faster than
  maxIter=10! Also 96% of the  files in the compiler reach a fix
  point within 13 iterations, so fixing maxIter at 40, while high, 
  is okay.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/10/31 15:25:00 EST
Tag: blume-20011031-pgraph
Description:

CKIT:
* Changed the "Function" constructor of type Ast.ctype to carry optional
  argument identifiers.
* Changed the return type of TypeUtil.getFunction accordingly.
* Type equality ignores the argument names.
* TypeUtil.composite tries to preserve argument names but gives up quickly
  if there is a mismatch.

installation script:
* attempts to use "curl" if available (unless "wget" is available as well)

CM:
* has an experimental implementation of "portable graphs" which I will
  soon propose as an implementation-independent library format
* there are also new libraries $/pgraph.cm and $/pgraph-util.cm

NLFFI-LIB:
* some cleanup (all cosmetic)

NLFFIGEN:
* temporarily disabled the mechanism that suppresses ML output for
  C definitions whose identifiers start with an underscore character
* generate val bindings for enum constants
* user can request that only one style (light or heavy) is being used;
  default is to use both (command-line arguments: -heavy and -light)
* fixed bug in handling of function types involving incomplete pointers
* generate ML entry points that take record arguments (i.e., using
  named arguments) for C functions that have a prototype with named
  arguments
  (see changes to CKIT)

----------------------------------------------------------------------
Name: Allen Leung
Date: 2001/10/27 20:34:00 EDT
Tag: leunga-20011027-x86-fast-fp-call
Description:

   Fixed the bug described in blume-20010920-slowfp.

   The fix involves 
      1. generating FCOPYs in FSTP in ia32-svid
      2. marking a CALL with the appropriate annotation
  
----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/10/16 11:32:00 EDT
Tag: blume-20011016-netbsd
Description:

Underscore patch from Chris Richards (fixing problem with compiling
runtime system under recent NetBSD).

----------------------------------------------------------------------
Name: Allen Leung
Date: 2001/10/12 17:18:32 EDT 2001
Tag: leung-20011012-x86-printflowgraph
Description:

X86RA now uses a valid (instead of dummy) PrintFlowgraph module.

----------------------------------------------------------------------
Name: Lal George
Date: 2001/10/11 23:51:34 EDT
Tag: george-20011011-too-many-instrs
Description:

The representation of a program point never expected to see more 
than 65536 instructions in a basic block!

----------------------------------------------------------------------
Name: Lal George
Date: 2001/10/09 09:41:37 EDT 
Tag: george-20011008-mlrisc-labels
Description:

Changed the machine description files to support printing of 
local and global labels in assembly code, based on host assembler
conventions.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/09/25 15:25:00 EDT
Tag: blume-20010925-exninfo
Description:

I provided a non-hook implementation of exnName (at the toplevel) and
made the "dummy" implementation of exnMessage (at the toplevel) more
useful: if nothing gets "hooked in", then at least you are going to
see the exception name and a message indicating why you don't see more.

[For the time being, programs that need exnMessage and want to use
ml-build should either use General.exnMessage (strongly recommended) or
refer to structure General at some other point so that CM sees a
static dependency.]

[Similar remarks go for "print" and "use":  If you want to use their
functionality in stand-alone programs generated by ml-build, then use
TextIO.output and Backend.Interact.useFile (from $smlnj/compiler.cm).]

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/09/20 17:28:00 EDT
Tag: blume-20010920-slowfp
Description:

Allen says that x86-fast-fp is not safe yet, so I turned it off again...

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/09/20 17:20:00 EDT
Tag: blume-20010920-canonicalpaths
Description:

0. Updated the BOOT file (something that I forgot to do earlier).

1. Small internal change to CM so that it avoids "/../" in filenames
   as much as possible (but only where it is safe).

2. Changed config/_run-sml (resulting in a changed bin/.run-sml) so
   that arguments that contain delimiters are passed through correctly.
   This change also means that all "special" arguments of the form
   @SMLxxx... must come first.

3. Changed install script to put relative anchor names for tool commands
   into pathconfig.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/09/18 15:35:00 EDT
Tag: blume-20010918-readme11036
Description:

Added README files.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/09/18 11:45:00 EDT
Tag: Release_110_36 (retag)
Description:

Fixed mistake in config/preloads. Retagged as 110.36.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/09/18 09:40:00 EDT
Tag: Release_110_36_orig (tag changed)
Description:

New version (110.36).  New bootfiles.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/09/14 16:15:00 EDT
Tag: blume-20010914-x86fastfp
Description:

John committed some changes that Allen made, in particular a (hopefully)
correctly working version of the x86-fp module.

I changed the default setting of the Control.MLRISC.getFlag "x86-fast-fp"
flag to "true".  Everything seems to compile to a fixpoint ok, and
"mandelbrot" speeds up by about 15%.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/09/13 11:20:00 EDT
Tag: blume-20010913-minimal
Description:

1. Stefan Monnier's patch to fix a miscompilation problem that
   was brought to light by John Reppy's work on Moby.

2. Implemented a minimal "structure Compiler" that contains just
   "version" and "architecture".  The minimal version will be
   available when the full version is not.  This is for backward-
   compatibility with code that wants to test Compiler.version.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/08/28 14:03:00 EDT
Tag: blume-20010828-ml-lex
Description:

Fix for bug 1581, received from Neophytos Michael.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/08/27 11:20:00 EDT
Tag: blume-20010827-readme11035
Description:

Fleshed out the README file for 110.35.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/08/24 17:10:00 EDT
Tag: Release_110_35
Description:

New version number (110.35).  New bootfiles.

----------------------------------------------------------------------
Name: Lal George
Date: 2001/08/24 13:47:18 EDT 2001
Tag: george-20010824-MLRISC-graphs
Description:

 removed clusters from MLRISC completely and replaced with graphs.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/08/23 17:50:00 EDT
Tag: blume-20010823-toplevel
Description:

- some reorganization of the code that implements various kinds of
  environments in the compiler (static, dynamic, symbolic, combined)
- re-implemented the EnvRef module so that evalStream works properly
  (if the stream contains references to "use", "CM.make", etc.)
- cleaned up evalloop.sml and interact.sml (but they need more cleaning)

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/08/20 15:50 EDT
Tag: blume20010820-slipup
Description:

I forgot to commit a few files.  Here they are...

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/08/20 15:35:00 EDT
Tag: blume-20010820-debugprof
Description:

!!!! NEW BOOTFILES !!!!

This is another round of reorganizing the compiler sources.  This
time the main goal was to factor out all the "instrumentation"
passes (for profiling and backtracing) into their own library.
The difficulty was to do it in such a way that it does not depend
on elaborate.cm but only on elabdata.cm.

Therefore there have been further changes to both elaborate.cm and
elabdata.cm -- more "generic" things have been moved from the former
to the latter.  As a result, I was forced to split the assignment
of numbers indicating "primtyc"s into two portions: SML-generic and
SML/NJ-specific.  Since it would have been awkward to maintain,
I bit the bullet and actually _changed_ the mapping between these
numbers and primtycs.  The bottom line of this is that you need
a new set of bin- and bootfiles.

I have built new bootfiles for all architectures, so doing a fresh
checkout and config/install.sh should be all you need.

The newly created library's name is

    $smlnj/viscomp/debugprof.cm

and its sources live under

    src/compiler/DebugProf

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/08/15 17:15:00 EDT
Tag: blume-20010815-compreorg
Description:

This is a first cut at reorganizing the CM libraries that make up the
core of the compiler.  The idea is to separate out pieces that could
be used independently by tools, e.g., the parser, the typechecker, etc.

The current status is a step in this direction, but it is not quite
satisfactory yet.  Expect more changes in the future.

Here is the current (new) organization...

    What used to be $smlnj/viscomp/core.cm is now divided into
    six CM libraries:

         $smlnj/viscomp/basics.cm
                       /parser.cm
                       /elabdata.cm
                       /elaborate.cm
                       /execute.cm
                       /core.cm

    The CM files for these libraries live under src/system/smlnj/viscomp.
    All these libraries are proxy libraries that contain precisely
    one CM library component.  Here are the locations of the components
    (all within the src/compiler tree):

         Basics/basics.cm
         Parse/parser.cm
         ElabData/elabdata.cm
         Elaborator/elaborate.cm
         Execution/execute.cm
         core.cm

     [This organization is the same that has been used already
     for a while for the architecture-specific parts of the visible
     compiler and for the old version of core.cm.]

     As you will notice, many source files have been moved from their
     respective original locations to a new home in one of the above
     subtrees.

     The division of labor between the new libraries is the following:

         basics.cm:
            - Simple, basic definitions that pertain to many (or all) of
              the other libraries.
         parser.cm:
            - The SML parser, producing output of type Ast.dec.
            - The type family for Ast is also defined and exported here.
         elabdata.cm:
            - The datatypes that describe input and output of the elaborator.
              This includes types, absyn, and static environments.
         elaborator.cm:
            - The SML/NJ type checker and elaborator.
              This maps an Ast.dec (with a given static environment) to
              an Absyn.dec (with a new static environment).
            - This libraries implements certain modules that used to be
              structures as functors (to remove dependencies on FLINT).
         execute.cm:
            - Everything having to do with executing binary code objects.
            - Dynamic environments.
         core.cm:
            - SML/NJ-specific instantiations of the elaborator and MLRISC.
            - Top-level modules.
            - FLINT (this should eventually become its own library)

Notes:

I am not 100% happy with the way I separated the elaborator (and its
data structures) from FLINT.  Two instances of the same problem:

    1. Data structures contain certain fields that carry FLINT-specific
       information.  I hacked around this using exn and the property list
       module from smlnj-lib.  But the fact that there are middle-end
       specific fields around at all is a bit annoying.

    2. The elaborator calculates certain FLINT-related information.  I tried
       to make this as abstract as I could using functorization, but, again,
       the fact that the elaborator has to perform calculations on behalf
       of the middle-end at all is not nice.

    3. Having to used exn and property lists is unfortunate because it
       weakens type checking.  The other alternative (parameterizing
       nearly *everything*) is not appealing, though.

I removed the "rebinding =" warning hack because due to the new organization
it was awkward to maintain it.  As a result, the compiler now issues some of
these warnings when compiling init.cmi during bootstrap compilation. On
the plus side, you also get a warning when you do, for example:
   val op = = Int32.+
which was not the case up to now.

I placed "assign" and "deref" into the _Core structure so that the
code that deals with the "lazy" keyword can find them there.  This
removes the need for having access to the primitive environment
during elaboration.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/08/13
Tag: blume-20010813-closures
Description:

This fix was sent to us by Zhong Shao.  It is supposed to improve the
performance of certain loops by avoiding needless closure allocation.

----------------------------------------------------------------------
Name: Lal George
Date: 2001/07/31 10:03:23 EDT 2001
Tag: george-20010731-x86-fmalloc
Description: Fixed bug in x86 calls

    There was a bug where call instructions would mysteriously
    vanish. The call instruction had to be one that returned 
    a floating point value.

----------------------------------------------------------------------
Name: Lal George
Date: 2001/07/19 16:36:29 EDT 2001
Tag: george-20010719-simple-cells
Description: 

I have dramatically simplified the interface for CELLS in MLRISC.

In summary, the cells interface is broken up into three parts:

  1. CellsBasis : CELLS_BASIS

	CellsBasis is a top level structure and common for all
        architectures.  it contains the definitions of basic datatypes
        and utility  functions over these types.

  2. functor Cells() : CELLS

	Cells generates an interface for CELLS that incorporates the
	specific resources on the target architecture, such as the 
	presence of special register classes, their number and size, 
	and various useful substructures.

  3. <ARCH>CELLS 
	
	e.g. SparcCells: SPARCCELLS

        <ARCH>CELLS usually contains additional bindings for special
	registers  on the architecture, such as:
	
		val r0 : cell		(* register zero *)
		val y : cell		(* Y register *)
		val psr : cell		(* processor status register *) 
		...
	
        The structure returned by applying the Cells functor is opened
        in this interface. 

The main implication of all this is that the datatypes for cells is 
split between CellsBasis and CELLS -- a fairly simple change for user
code. 

In the old scheme the CELLS interface had a definitional binding of
the form:

	signature CELLS = sig

 	   structure CellsBasis = CellsBasis
	
	   ...

        end

With all the sharing constraints that goes on in MLRISC, this old
design  quickly leads to errors such as:

	"structure definition spec inside of sharing ... "


and appears to require an unacceptable amount of sharing and where
constraint hackery.  

I think this error message (the interaction of definitional specs and
sharing) requires more explanation on our web page. 

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/07/19 15:00:00 EDT
Tag: blume-20010719-libreorg
Description:

This update puts together a fairly extensive but straightforward change
to the way the libraries that implement the interactive system are
organized:

   The biggest change is the elimination of structure Compiler.  As a
   replacement for this structure, there is now a CM library
   (known as $smlnj/compiler.cm or $smlnj/compiler/current.cm)
   that exports all the substructures of the original structure Compiler
   directly.  So instead of saying Compiler.Foo.bar one now simply
   says Foo.bar.  (The CM libraries actually export a collection of
   structures that is richer than the collection of substructures of
   structure Compiler.)

   To make the transition smooth, there is a separate library called
   $smlnj/compiler/compiler.cm which puts together and exports the
   original structure Compiler (or at least something very close to it).

   There are five members of the original structure Compiler
   that are not exported directly but which instead became members
   of a new structure Backend (described by signature BACKEND).  These are:
   structure Profile (: PROFILE), structure Compile (: COMPILE), structure
   Interact (: INTERACT), structure Machine (: MACHINE), and val
   architecture (: string).

   Structure Compiler.Version has become structure CompilerVersion.

   Cross-compilers for alpha32, hppa, ppc, sparc, and x86 are provided
   by $smlnj/compiler/<arch>.cm where <arch> is alpha32, hppa, ppc, sparc,
   or x86, respectively.
   Each of these exports the same frontend structures that
   $smlnj/compiler.cm exports.  But they do not have a structure Backend
   and instead export some structure <Arch>Backend where <Arch> is Alpha32,
   Hppa, PPC, Sparc, or X86, respectively.

   Library $smlnj/compiler/all.cm exports the union of the exports of
   $smlnj/compiler/<arch>.cm

   There are no structures <Arch>Compiler anymore, use
   $smlnj/compiler/<arch>.cm instead.

   Library host-compiler-0.cm is gone.  Instead, the internal library
   that instantiates CM is now called cm0.cm.  Selection of the host
   compiler (backend) is no longer done here but. (Responsibility for it
   now lies with $smlnj/compiler/current.cm.  This seems to be more
   logical.)

   Many individual files have been moved or renamed.  Some files have
   been split into multiple files, and some "dead" files have been deleted.

Aside from these changes to library organization, there are also changes
to the way the code itself is organized:

   Structure Binfile has been re-implemented in such a way that it no
   longer needs any knowledge of the compiler.  It exclusively deals
   with the details of binfile layout.  It no longer invokes the
   compiler (for the purpose of creating new prospective binfile
   content), and it no longer has any knowledge of how to interpret
   pickles.

   Structure Compile (: COMPILE) has been stripped down to the bare
   essentials of compilation.  It no longer deals with linking/execution.
   The interface has been cleaned up considerably.

   Utility routines for dealing with linking and execution have been
   moved into their own substructures.

   (The ultimate goal of these changes is to provide a light-weight
   binfile loader/linker (at least for, e.g., stable libraries) that
   does not require CM or the compiler to be present.)

CM documentation has been updated to reflect the changes to library
organization.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/07/10 17:30:00 EDT
Tag: Release_110_34
Description:

Minor tweak to 110.34 (re-tagged):

  - README.html file added to CVS repository
  - runtime compiles properly under FreeBSD 3.X and 4.X

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/07/10 17:30:00 EDT
Tag: Release_110_34
Description:

New version number (110.34). New bootfiles.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/07/09 16:00:00 EDT
Tag: blume-20010709-more-varargs
Description:

I changed the handling of varargs in ml-nlffigen again:
The ellipsis ... will now simply be ignored (with an accompanying warning).

The immediate effect is that you can actually call a varargs function
from ML -- but you can't actually supply any arguments beyond the ones
specified explicitly.  (For example, you can call printf with its format
string, but you cannot pass additional arguments.)

This behavior is only marginally more useful than the one before, but
it has the advantage that a function or, more importantly, a function
type never gets dropped on the floor, thus avoiding follow-up problems with
other types that refer to the offending one.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/07/09 11:25:00 EDT
Tag: blume-20010709-varargs
Description:

1. ckit-lib.cm now exports structure Error
2. ml-nlffigen reports occurences of "..." (i.e., varargs function types)
   with a warning accompanied by a source location.  Moreover, it
   merely skips the offending function or type and proceeds with the
   rest of its work.u  As a result, one can safely feed C code containing
   "..." to ml-nlffigen.
3. There are some internal improvements to CM, providing slightly
   more general string substitutions in the tools subsystem.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/06/27 15:10:00 EDT
Tag: blume-20010627-concur
Description:

Fixed a small bug in CM's handling of parallel compilation.
(You could observe the bug by Control-C-interrupting an ordinary
CMB.make or CM.stabilize and then attaching some compile servers.
The result was that all of a sudden the previously interrupted
compilation would continue on its own.  This was because of
an over-optimization: CM did not bother to clean out certain queues
when no servers were attached "anyway", resulting in the contents
of these queues to grab control when new servers did get attached.)

There is also another minor update to the CM manual.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/06/26 16:15:00 EDT
Tag: blume-20010626-cmdoc
Description:

Minor typo fixed in CM manual (syntax diagram for libraries).

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/06/25 22:55:00 EDT
Tag: blume-20010625-x86pc
Description:

Fixed a nasty bug in the X86 assembly code that caused signal
handlers to fail (crash) randomly.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/06/25 12:05:00 EDT
Tag: blume-20010625-nlffigen
Description:

This update fixes a number of minor bugs in ml-nlffigen as reported by
Nick Carter <nbc@andrew.cmu.edu>.

  1. Silly but ok typedefs of the form "typedef void myvoid;" are now accepted.
  2. Default names for generated files are now derived from the name of
     the C file *without its directory*.  In particular, this causes generated
     files to be placed locally even if the C file is in some system directory.
  3. Default names for generated signatures and structures are also derived
     from the C file name without its directory.  This avoids silly things
     like "structure GL/GL".
     (Other silly names are still possible because ml-nlffigen does not do
      a thorough check of whether generated names are legal ML identifiers.
      When in doubt, use command line arguments to force particular names.)

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/06/21 12:25:00 EDT
Tag: blume-20010621-eXene
Description:

eXene now compiles and (sort of) works again.

The library name (for version > 110.33) is $/eXene.cm.

I also added an new example in src/eXene/examples/nbody.  See the
README file there for details.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/06/20 16:40:00 EDT
Tag: blume-20010620-cml
Description:

CML now compiles and works again.

Libraries (for version > 110.33):

  $cml/cml.cm            Main CML library.
  $cml/basis.cm          CML's version of $/basis.cm.
  $cml/cml-internal.cm   Internal helper library.
  $cml/core-cml.cm       Internal helper library.
  $cml-lib/trace-cml.cm  Tracing facility.
  $cml-lib/smlnj-lib.cm  CML's version of $/smlnj-lib.cm

The installer (config/install.sh) has been taught how to properly
install this stuff.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/06/19 17:55:00 EDT
Tag: blume-20010619-instantiate
Description:

This un-breaks the fix for bug 1432.
(The bug was originally fixed in 110.9 but I broke it again some
time after that.)

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/06/19 17:25:00 EDT
Tag: blume-20010619-signals
Description:

This should (hopefully) fix the long-standing signal handling bug.
(The runtime system was constructing a continuation record with an
incorrect descriptor which would cause the GC to drop data on the floor...)

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/06/15 15:05:00 EDT
Tag: blume-20010615-moresparc
Description:

Here is a short late-hour update related to Sparc c-calls:

 -- made handling of double-word arguments a bit smarter

 -- instruction selection phase tries to collapse certain clumsily
    constructed ML-Trees; typical example:

        ADD(ty,ADD(_,e,LI d1),LI d2)  ->  ADD(ty,e,LI(d1+d2))

    This currently has no further impact on SML/NJ since mlriscGen does
    not seem to generate such patterns in the first place, and c-calls
    (which did generate them in the beginning) has meanwhile been fixed
    so as to avoid them as well.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/06/15 15:05:00 EDT
Tag: blume-20010615-sparc
Description:

The purpose of this update is to provide an implementation of NLFFI
on Sparc machines.

Here are the changes in detail:

   * src/MLRISC/sparc/c-calls/sparc-c-calls.sml is a new file containing
   the Sparc implementation of the c-calls API.
   * The Sparc backend of SML/NJ has been modified to uniformely use %fp
   for accessing the ML frame.  Thus, we have a real frame pointer and
   can freely modify %sp without need for an omit-frame-ptr phase.
   The vfp logic in src/compiler/CodeGen/* has been changed to accomodate
   this case.
   * ml-nlffigen has been taught to produce code for different architectures
   and calling conventions.
   * In a way similar to what was done in the x86 case, the Sparc
   backend uses its own specific extension to mltree.  (For example,
   it needs to be able to generate UNIMP instructions which are part
   of the calling convention.)
   * ml-nlffi-lib was reorganized to make it more modular (in particular,
   to make it easier to plug in new machine- and os-dependent parts).

There are some other fairly unrelated bug fixes and cleanups as well:

   * I further hacked the .cm files for MLRISC tools (like MDLGen) so
   that they properly share their libraries with existing SML/NJ libraries.
   * I fixed a minor cosmetic bug in CM, supressing certain spurious
   follow-up error messages.
   * Updates to CM/CMB documentation.

TODO items:

   * MLRISC should use a different register as its asmTemp on the Sparc.
     (The current %o2 is a really bad choice because it is part of the
     calling conventions, so things might interfere in unexpected ways.)

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/06/07
Tag: blume-20010607-calls
Description:

A number of internal changes related to C calls and calling conventions:

1. ML-Tree CALL statements now carry a "pops" field.  It indicates the
   number of bytes popped implicitly (by the callee).  In most cases
   this field is 0 but on x86/win32 it is some non-zero value.  This
   is information provided for the benefit of the "omit-frameptr" pass.
2. The CALL instruction on the x86 carries a similar "pops" field.
   The instruction selection phase copies its value from the ML-Tree
   CALL statement.
3. On all other architectures, the instruction selection phase checks
   whether "pops=0" and complains if not.
4. The c-calls implementation for x86 now accepts two calling conventions:
   "ccall" and "stdcall".  When "ccall" is selected, the caller cleans
   up after the call and pops is set to 0.  For "stdcall", the caller
   does nothing, leaving the cleanup to the callee; pops is set to
   the number of bytes that were pushed onto the stack.
5. The cproto decoder (compiler/Semant/types/cproto.sml) now can
   distinguish between "ccall" and "stdcall".
6. The UNIMP instruction has been added to the supported Sparc instruction
   set. (This is needed for implementing the official C calling convention
   on this architecture.)
7. I fixed some of the .cm files under src/MLRISC/Tools to make them
   work with the latest CM.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/06/05 15:10:00 EDT
Tag: blume-20010605-cm-index
Description:

0. The "lambdasplit" parameter for class "sml" in CM has been documented.

1. CM can now generate "index files".  These are human-readable files
   that list on a per-.cm-file basis each toplevel symbol defined or
   imported.  The location of the index file for
   <p>/<d>.cm is <p>/CM/INDEX/<d>.cm.
   To enable index-file generation, set CM.Control.generate_index to true
   or export an environment-symbol: export CM_GENERATE_INDEX=true.

   The CM manual has been updated accordingly.

2. I made some slight modifications to the c-calls API in MLRISC.

     a) There is now a callback to support saving/restoring of
        dedicated but caller-save registers around the actual call
        instruction.
     b) One can optionally specify a comment-annotation for the
        call instruction.

3. SML/NJ (mlriscGen.sml) uses this new API for the rawccall primop.
   (For example, the comment annotation shows the C prototype of
    the function being called.)

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/06/01 13:30:00 EDT
Tag: blume-20010601-nlffi-cleanup
Description:

This is mostly a cleanup of MLFFI stuff:

   - some signature files have been put into a more exposed place
   - the ugly 'f type parameter is gone (simplifies types tremendously!)
   - ml-nlffigen changed accordingly
   - tutorial updated

Other changes:

   - author's affiliation in CM manual(s) updated
   - some more recognized keywords added to Allen's sml.sty

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/05/25 15:30:00 EDT
Tag: blume-20010525-iptr
Description:

  - put the official 110.33-README (as it appears on the ftp server) under
    CVS
  - fixed a small bug related to incomplete pointer types in
    ml-nlffigen
  - small cosmetic change to the ml-nlffi-lib's "arr" type constructor
    (it does not need the 'f type parameter)

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/05/23 14:30:00 EDT
Tag: Release_110_33
Description:

New version number (110.33).  New bootfiles.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/05/22 18:06:00 EDT
Tag: blume-20010522-targets
Description:

Made install.sh use file config/targets.customized if it exists, falling
back to config/targets if it doesn't.  This way one can have a customized
version of the targets file without touching the "real thing", thus
eliminating the constant fear of accidentally checking something bogus
back into the CVS repository...  (File config/targets.customized must
not be added to the repository!)

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/05/22 16:30:00 EDT
Tag: blume-20010522-minitut
Description:

1. Bug fix in ml-nlffigen; now (hopefully) correctly handling
   struct returns.
2. Added src/ml-nlffi-lib/Doc/mini-tutorial.txt.  This is some very
   incomplete, preliminary documentation for NLFFI.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/05/14 11:30:00 EDT
Tag: blume-20010514-script
Description:

Some bugs in install script fixed.

In addition to that I also made a slight change to the NLFFI API:
Functors generated by ml-nlffigen now take the dynamic library as a
straight functor argument, not as a suspended one.  (The original
functor code used to force the suspension right away anyway, so there
was nothing gained by this complication of the interface.)

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/05/11 14:35:00 EDT
Tag: blume-20010511-ml-nlffi
Description:

I finally took the plunge and added my new FFI code to the main
repository.  For x86-linux it is now ready for prime-time.

There are two new subdirectories of "src":

  - ml-nlffi-lib:
       The utility library for programs using the FFI interface.
       Here is the implementation of $/c.cm and its associated low-level
       partners $/c-int.cm and $/memory.cm.
  - ml-nlffigen:
       A stand-alone program for generating ML glue code from C source
       code.

Building ml-nlffigen requires $/ckit-lib.cm.

The config/install.sh script has been updates to do the Right Thing
(hopefully).

Notice that the source tree for the C-Kit will not be put under "src"
but directly under the installation root directory.  (This is the
structure that currently exists on the CVS server when you check out
module "sml".)  Fortunately, config/install.sh knows about this oddity.

Bugs: No documentation yet.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/05/09 16:35:00 EDT
Tag: blume-20010509-cpscontract
Description:

Fixed a bug in the accounting code in cpsopt/contract.sml.  (The
wrapper/unwrapper elimination did not decrement usage counts and some
dead variables got overlooked by the dead-up logic.)

----------------------------------------------------------------------
Name: Lal George
Date: 2001/05/08  17:26:09 EDT
Tag: george-20010508-omit-frameptr
Description:

Changes to implement the omit-frame-pointer optimization to support 
raw C calls. For now, there is only support on the Intel x86, but
other architectures will follow as more experience is gained with this. 


----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/05/07 14:40:00 EDT
Tag: blume-20010507-proxies
Description:

I made into "proxy libraries" all libraries that qualify for such a
change.  (A qualifying library is a library that has another library or
groups as its sole member and repeats that member's export list
verbatim.  A proxy library avoids this repetition by omitting its export
list, effectively inheriting the list that its (only) member exports.
See the CM manual for more explanation.)
The main effect is that explicit export lists for these libraries
do not have to be kepts in sync, making maintenance a bit easier.

I also added copyright notices to many .cm-files.

Last but not least, I made a new set of bootfiles.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/05/04 17:00:00 EDT
Tag: blume-20010504-cm-lsplit
Description:

0. John merged pending changes to $/smlnj-lib.cm

1. Allen's previous change accidentally backed out of one of Lal's
   earlier changes.  I undid this mistake (re-introducing Lal's change).

2. I used the new topOrder' function from graph-scc.sml (from $/smlnj-lib.cm)
   within the compiler where applicable.  There is some code simplification
   because of that.

3. The "split" phase (in FLINT) is now part of the default list of phases.
   Compiler.Control.LambdaSplitting.* can be used to globally control the
   lambda-splitting (cross-module-inlining) engine.  In addition to that,
   it can now also be controlled on a per-source basis: CM has been taught
   a new tool parameter applicable to ML source files.

   - To turn lambda-splitting off completely:
        local open Compiler.Control.LambdaSplitting in
            val _ = set Off
        end
   - To make "no lambda-splitting" the global default (but allow per-source
     overriding); this is the initial setting:
        local open Compiler.Control.LambdaSplitting in
            val _ = set (Default NONE)
        end
   - To make "lambda-splitting with aggressiveness a" the global default
     (and allow per-source overriding):
        local open Compiler.Control.LambdaSplitting in
            val _ = set (Default (SOME a))
        end

   - To turn lambda-splitting off for a given ML souce file (say: a.sml)
     write (in the respective .cm-file):
        a.sml (lambdasplitting:off)
   - To turn lambda-splitting for a.sml on with minimal aggressiveness:
        a.sml (lambdasplitting:on)
   - To turn lambda-splitting for a.sml on with aggressiveness <a> (where
     <a> is a decimal non-negative integer):
        a.sml (lambdasplitting:<a>)
   - To turn lambda-splitting for a.sml on with maximal aggressiveness:
        a.sml (lambdasplitting:infinity)
   - To use the global default for a.sml:
        a.sml (lambdasplitting:default)
     or simply
        a.sml

----------------------------------------------------------------------
Name: Allen Leung
Date: 2001/05/04 01:57:00 EDT
Tag: leunga-20010504-sync
Description:

  MLRISC features.

  1. Fix to CMPXCHG instructions.
  2. Changed RA interface to allow annotations in callbacks.
  3. Added a new method to the stream interface to allow annotations updates.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/05/01 11:45:00 EDT
Tag: blume-20010501-pcedittmp
Description:

Changed install.sh to use the current working directory instead of
/usr/tmp for a temporary file (pcedittmp).  The previous choice
of /usr/tmp caused trouble with MacOS X because of file premission
problems.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/04/20 11:10:00 EDT
Tag: blume-20010420-inMLflag
Description:

 - added vp_limitPtrMask to vproc-state.h
   (for use by the raw-C-calls mechanism to implement proper interrupt
    handling)
 - made the ML compiler aware of various data-structure offsets so it
   can generate code for accessing the vp_inML flag and vp_limitPtrMask
 - tweaked mlriscGen.sml to have it emit interrupt-handling code for
   raw C-calls

----------------------------------------------------------------------
Name: Lal George
Date: 2001/04/20 09:15:28 EDT
Tag: george-20010420-macosX
Description:

 - Changes to port to Mac OS X; Darwin.

 - In the process I found that sqrt was broken on the PPC, because the
   fsqrt instruction is not implemented.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/04/18 12:45:00 EDT
Tag: blume-20010418-ccalls
Description:

 - fixed two off-by-4 errors in the x86-specific c-calls implementation
   (this bug prevented structure arguments containing pointers from being
    passed correctly)
 - changed the raw-C-call code in mlriscGen.sml in such a way that
   structure arguments are represented as a pointer to the beginning
   of the structure (instead of having a series of synthesized arguments,
   one for each structure member)

 - made makeml script's verbosity level configurable via environment
   variable (MAKEML_VERBOSITY)

 - eliminated placeholder implementations for f32l, w16s, i16s, and f32s
   in rawmem-x86.sml; we are now using the real thing

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/03/22 16:25:00 EST
Tag: blume-20010322-bootfiles
Description:

Created a new set of bootfiles (for your automatic installation convenience).

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/03/22 15:10:00 EST
Tag: blume-20010322-rawmem-parcm
Description:

1. All "raw memory access" primitives for the new FFI are implemented now
   (at least on the x86).
2. Some further cleanup of CM's parallel make mechanism.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/03/19 17:53:00 EST
Tag: blume-20010319-parallel
Description:

Parallel make (using compile servers) now works again.

To this end, CM.stabilize and CMB.make have been modified to work in
two passes when compile servers are attached:
   1. Compile everything, do not perform stabilization; this pass
      uses compile servers
   2. Stabilize everything; this pass does not use compile servers
If there are no compile servers, the two passes are combined into one
(as before).  Splitting the passes increases the inherent parallelism
in the dependency graph because the entire graph including all
libraries is available at the same time.  This, in turn, improves
server utilization.  The downside is that the master process will
have to do some extra work after compilation is done (because for
technical reasons it must re-read all the binfiles during stabilization).

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/03/16 12:22:00 EST
Tag: blume-20010316-bootfiles
Description:

Created a new set of bootfiles (for your automatic installation convenience).

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/03/16 11:00:00 EST
Tag: blume-20010316-MLTREE-fixup
Description:

This is a minor fixup for an (untagged) earlier commit by Allen.
(A file was missing).

----------------------------------------------------------------------
Name: Allen Leung
Date: Mon Mar  5 18:54:57 EST 2001
Tag: leunga-20010305-cut-support

1. New support for alternative control-flow in MLTREE. 
   Currently we support 

      FLOW_TO(CALL ...., [k1,...,kn])
    
   This is needed for 'cuts to' in C-- and try/handle-like constructs
   in Moby

   New assembler flag "asm-show-cutsto" to turn on control-flow debugging.

2. Register Allocator

   Changes in interface [from Fermin, John]

3. Alpha 8-bit SLL support [Fermin]

4. All architectures

   A new module (ClusterExpandCopies) for expanding parallel copies.

----------------------------------------------------------------------
Name: Allen Leung
Date: 2001/02/27 23:07:00 EST
Tag: leunga-20010227-minor-stuff

1. Alpha bug fix for CMOVNE
2. Handle mltree COND(..,FCMP ...,...)
3. Bug fix in simplifier

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/01/30 17:50:00 EST
Tag: blume-20010130-sync
Description:

This is just a minor update to sync my devel branch with the main brach.
The only visible change is the addition of some README files.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/01/12 23:30:00 JST
Tag: blume-20010112-bootfiles
Description:

Made a new set of bootfiles that goes with the current state of the
repository.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/01/12 21:20:00 JST
Tag: blume-20010112-sync
Description:

I am just flushing out some minor changes that had accumulated in
my private branch in order to sync with the main tree.  (This is 
mainly because I had CVS trouble when trying to merge _into_ my
private branch.)

Most people should be completely unaffected by this.

----------------------------------------------------------------------
Name: Allen Leung
Date: Thu Jan 11 21:03:00 EST 2001
Tag: leunga-20010111-labexp=mltree
Description:

1.  Removed the type LabelExp and replace it by MLTree.
2.  Rewritten mltree-simplify with the pattern matcher tool.
3.  There were some bugs in alpha code generator which would break
    64-bit code generation.
4.  Redo the tools to generate code with the
5.  The CM files in MLRISC (and in src/system/smlnj/MLRISC) 
    are now generated by perl scripts.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/01/10 21:55:00 JST
Tag: blume-20010110-rcc
Description:

The RCC stuff now seems to work (but only on the x86).
This required hacking of the c-calls interface (and -implementation) in
MLRISC.

Normal compiler users should be unaffected.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/01/09 01:20:00 JST
Tag: blume-20010109-rcc
Description:

This is a fairly big patch, flushing out a large number of pending
changes that I made to my development copy over the last couple of days.

Of practical relevance at this moment is a workaround for a pickling
bug that Allen ran into the other day.  The cause of the bug itself is
still unknown and it might be hard to fix it properly, but the
workaround has some merits of its own (namely somewhat reducing pickling
overhead for certain libraries).  Therefore, I think this solution should
be satisfactory at this time.

The rest of the changes (i.e., the vast majority) has to do with my
ongoing efforts of providing direct support for C function calls from
ML.  At the moment there is a new primop "RAW_CCALL", typing magic
in types/cproto.sml (invoked from FLINT/trans/translate.sml), a new
case in the FLINT CPS datatype (RCC), changes to cps/convert.sml to
translate uses of RAW_CCALL into RCC, and changes to mlriscGen.sml to
handle RCC.

The last part (the changes to mlriscGen.sml) are still known to be
wrong on the x86 and not implemented on all other architectures.  But
the infrastructure is in place. I had to change a few functor
signatures in the backend to be able to route the CCalls interface
from MLRISC there, and I had to specialize the mltree type (on the
x86) to include the necessary extensions. (The extensions themselves
were already there and redy to go in MLRISC/x86).

Everything should be very happy as soon as someone helps me with
mlriscGen.sml...

In any case, nothing of this should matter to anyone as long as the
new primop is not being used (which is going to be the case unless you
find it where I hid it :). The rest of the compiler is completely
unaffected.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2001/01/05 00:30:00 JST
Tag: blume-20010105-primops
Description:

Added some experimental support for work that I am doing right now.
These changes mostly concern added primops, but there is also a new
experimental C library in the runtime system (but currently not enabled
anywhere except on Linux/X86).

In the course of adding primops (and playing with them), I discovered that
Zhong's INL_PRIM hack (no type info for certain primops) was, in fact, badly
broken.  (Zhong was very right he labeled this stuff as "major gross hack".)
To recover, I made type information in INL_PRIM mandatory and changed
prim.sml as well as built-in.sml accordingly.  The InLine structure now
has complete, correct type information (i.e., no bottom types).

Since all these changes mean that we need new binfiles, I also bumped the
version number to 110.32.1.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/12/30 22:10:00 JST
Tag: blume-20001230-various
Description:

Added proxy libraries for MLRISC and let MLRISC libraries refer
to each other using path anchors.  (See CM manual for explanation.)

Updated CM documentation.

Fixed some bugs in CM.

Implemented "proxy" libraries (= syntactic sugar for CM).

Added "-quiet" option to makeml and changed runtime system accordingly.

Added cleanup handler for exportML to reset timers and compiler stats.

----------------------------------------------------------------------
Name: Lal George
Date: 2000/12/22 22:22:58 EST 2000
Tag: Release_110_32
Description:

	Infinite precision used throughout MLRISC.
	see MLRISC/mltree/machine-int.sig

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/12/22 23:16:00 JST
Tag: blume-20001222-warn
Description:

Corrected wording and formatting of some CM warning message which I
broke in my previous patch.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/12/22 21:20:00 JST
Tag: blume-20001222-anchorenv
Description:

Fixed CM's handling of anchor environments in connection with CMB.make.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/12/22 13:15:00 JST
Tag: blume-20001222-cleanup
Description:

Removed src/cm/ffi which does not (and did not) belong here.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/12/21 23:55:00 JST
Tag: blume-20001221-exn
Description:

Probably most important: CM no longer silently swallows all exceptions
in the compiler.
Plus: some other minor CM changes.  For example, CM now reports some
sizes for generated binfiles (code, data, envpickle, lambdapickle).

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/12/15 00:01:05 JST
Tag: blume-20001215-dirtool
Description:

- "dir" tool added.
- improvements and cleanup to Tools structure
- documentation updates

----------------------------------------------------------------------
Name: Allen Leung
Date: Thu Dec 14 03:45:24 EST 2000  
Description:
Tag:  leunga-20001214-int-inf
Description:

   In IntInf, added these standard functions, which are missing from our
implementation:

    andb : int * int -> int
    xorb : int * int -> int
    orb  : int * int -> int
    notb : int -> int
     <<   : int * word -> int
    ~>>  : int * word -> int

   Not tested, I hope they are correct.  

----------------------------------------------------------------------
Name: Allen Leung
Date: Fri Dec  8 19:23:26 EST 2000
Description:
Tag:  leunga-20001208-nowhere
Description:

  Slight improvements to the 'nowhere' tool to handle OR-patterns, 
to generate better error messages etc.  Plus a brief manual. 

----------------------------------------------------------------------
Name: Lal George
Date: 2000/12/08 09:54:02 EST 2000
Tag: Release_110_31
Description:

- Version 110.31
----------------------------------------------------------------------
Name: Allen Leung
Date: Thu Dec  7 22:01:04 EST 2000
Tag:  leunga-20001207-cell-monster-hack
Description:

Major MLRISC internal changes.  Affect all clients.
Summary:

1.  Type CELLS.cell = int is now replaced by a datatype.
    As a result, the old regmap is now gone.  Almost all interfaces
    in MLRISC change as a consequence.

2.  A new brand version of machine description tool (v3.0) that generates
    modules expecting the new interface.  The old version is removed.

3.  The RA interface has been further abstracted into two new functors.
    RISC_RA and X86RA.  These functors have much simpler interfaces.
    [See also directory MLRISC/demo.]  

4.  Some other new source->source code generation tools are available: 

    a. MLRISC/Tools/RewriteGen -- generate rewriters from rules.
    b. MLRISC/Tools/WhereGen -- expands conditional pattern matching rules.
       I use this tool to generate the peephole optimizers---with the new
       cell type changes, peephole rules are becoming difficult to write
       without conditional pattern matching.  

5.  More Intmap -> IntHashTable change.  Previous changes by Matthias didn't
    cover the entire MLRISC source tree so many things broke.  

6.  CM files have been moved to the subdirectory MLRISC/cm.
    They are moved because there are a lot of them and they clutter up the
    root dir.

7.  More detailed documentation to come...

    NOTE: To rebuild from 110.30 (ftp distribution), you'll have to do
    a makeml -rebuild first.  This is because of other other
    changes that Matthias has made (see below).


----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/11/30 23:12:00 JST
Tag: blume-20001130-filereorg
Description:

Some manual updates and some file reorganizations in CM.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/11/24 17:45:00 JST
Tag: blume-20001124-link
Description:

Drastically improved link traversal code for the case that the dynamic
value was already loaded at bootstrap time.  As a result, CM and CMB
now both load blazingly fast -- even on a very slow machine.  Also,
memory consumption has been further reduced by this.

Warning: The format of the PIDMAP file has changed.  THerefore, to
bootstrap you have to do this:

1. Run CMB.make
2. Make a symbolic link for the boot directory:
     ln -s sml.boot.ARCH-OS xxx
3. "Rebuild" the boot directory:
     ./makeml -boot xxx -rebuild sml ; rm xxx
4. Boot normally:
      ./makeml

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/11/21 21:20:00 JST
Tag: blume-20001121-tools
Description:

Continued hacking on autoloading problem -- with success this time.
Also changed tool-plugin mechanism.  See new CM manual.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/11/19 14:30:00 JST
Tag:  blume-20001119-autoload
Description:

Some hacking to make autoloading faster.  Success for CMB, no success
so far for CM.  There is a reduced structure CM' that autoloads faster.
(This is a temporary, non-documented hack to be eliminated again when
the general problem is solved.)

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/11/17 14:10:00 JST
Tag: blume-20001117-pickle-lib
Description:

1. Eliminated comp-lib.cm
2. Made pickle-lib.cm
3. Eliminated all uses of intset.sml (from comp-lib.cm)
4. Replaced all uses of intmap.{sig,sml} (from comp-lib.cm) with
   equivalent constructs from smlnj-lib.cm (INtHashTable).
5. Point 4. also goes for those uses of intmap.* in MLRISC.
   Duplicated intmap modules thrown out.
6. Hunted down all duplicated SCC code and replaced it with
   equivalent stuff (GraphSCCFn from smlnj-lib.cm).
7. Rewrote Feedback module.
8. Moved sortedlist.sml into viscomp-lib.cm.  Eventually it
   should be thrown out and equivalent modules from smlnj-lib.cm
   should be used (IntRedBlackSet, IntListSet, ...).

Confirmed that compiler compiles to fixpoint.

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/11/10 18:00:00
Tag: leunga-20001110-new-x86-fp

A new x86 floating point code generator has been added.  
By default this is turned off.  To turn this on, do:

    CM.autoload "$smlnj/compiler.cm";
    Compiler.Control.MLRISC.getFlag "x86-fast-fp" := true;

Changes:

1.  Changed FTAN to FPTAN so that the assembly output is correct.
2.  Changed the extension callback for FTANGENT to generate:

          fptan
          fstp  %st(0)
    instead of 
          fptan
          fstpl ftempmem

3.  Numerous assembly fixes for x86.
       
5.  Cleaned up the machine code output module x86/x86MC.sml and added 
    support for a whole bunch of instructions and addressing modes:

      fadd/fsub/fsubr/fmul/fdiv/fdivr  %st, %st(n)
      faddp/fsubp/fsubrp/fmulp/fdivp/fdivrp  %st, %st(n)
      fadd/fsub/fsubr/fmul/fdiv/fdivr  %st(n), %st
      fiadd/fisub/fisubr/fimul/fidiv/fidivr mem
      fxch %st(n)
      fld %st(n)
      fst %st(n)
      fst mem
      fstp %st(n)
      fucom %st(n)
      fucomp %st(n)

    All these are now generated when the fast fp mode is turned on.
 
6.  Removed the dedicated registers %st(0), ..., %st(7) from X86CpsRegs

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/11/09 11:20:00 JST
Tag: blume-20001109-scc
Description:

Eliminated some code duplication:

1. Added "where" clause to GraphSCCFn in SML/NJ Library.
   (Otherwise the functor is useless.)
2. Used GraphSCCFn where SCCUtilFun was used previously.
3. Got rid of SCCUtilFun (in comp-lib.cm).

----------------------------------------------------------------------
Name: Lal George
Date: 2000/11/06 09:02:21 EST 2000
Tag: Release_110_30
Description:

- Version 110.30
----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/11/04 14:45:00
Tag: blume-20001104-mlbuild
Description:

- Made ml-build faster on startup.
- Documentation fixes.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/11/02 17:00:00 JST
Tag: blume-20001102-condcomp
Description:

- Small tweaks to pickler -- new BOOTFILES!
- Version bumped to 110.29.2.
- Added conditional compilation facility to init.cmi (see comment there).
----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/10/23 19:31:00
Tag: leunga-20001023-demo-ra

1. Minor RA changes that improves spilling on x86 (affects Moby and C-- only)
2. Test programs for the graph library updated
3. Some new MLRISC demo programs added

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/08/31 22:15:00 JST
Tag: blume-20001017-errmsg
Description:

More error message grief: Where there used to be no messages, there
now were some that had bogus error regions.  Fixed.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/08/31 17:30:00 JST
Tag: blume-20001017-v110p29p1
Description:

I made a version 110.29.1 with new bootfiles.

Changes:  Modified pickler/unpickler for faster and leaner unpickling.
          CM documentation changes and a small bugfix in CM's error reporting.

----------------------------------------------------------------------
Name: Lal George
Date: 2000/09/27 14:42:35 EDT
Tag: george-20000927-nodestatus
Description:

Changed the type of the nodestatus, so that:

	SPILLED(~1)		is now SPILLED
	SPILLED(m) where m>=0   is now MEMREG(m)
	SPILLED(s) where s<~1   is now SPILL_LOC(~s)
 
----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/09/07 14:45:00 JST
Tag: blume-20000907-cmerrmsg
Description:

Small tweak to CM to avoid getting ML syntax error messages twice.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/08/31 18:00:00 JST
Tag: blume-20000831-cvsbootfiles
Description:

New URL for boot files (because the 110.29 files on the BL server do
now work correctly with my updated install scripts for yacc and lex).

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/08/08 12:33:00 JST
Tag: blume-20000808-manual
Description:

Tiny update to CM manual.

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/08/7 19:31:00
Tag: leunga-20000807-a-whole-bunch-of-stuff

  Moby, C--, SSA, x86, machine descriptions etc.  Should only affect C--
and Mobdy.

1.  x86

   a.  Fixes to peephole module by John and Dan.
   b.  Assembly fix to SETcc by Allen.
   c.  Fix to c-call by John.
   d.  Fix to spilling by John.  (This one deals with the missing FSTPT case)
   e.  Instruction selection optimization to SETcc as suggested by John.

       For example,

        MV(32, x, COND(32, CMP(32, LT, a, b), LI 1, LI 0))

       should generate:

        MOVL a, x
        SUBL b, x
        SHRL 31, x 

2.  IR stuff

     A bunch of new DJ-graph related algorithms added.  These
     speed up SSA construction.

3.  SSA + Scheduling

     Added code for SSA and scheduling to the repository

----------------------------------------------------------------------
Name: Lal George
Date: 2000/07/27 11:53:14 EDT

Tag: lal-20000727-linux-ppc
Description:

 Made changes to support Linux PPC. 
 p.s. I have confirmation that the 110.29 boot files work fine.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/07/27 17:40:00 JST
Tag: blume-20000727-scripts
Description:

!!!! WARNING !!!!
You must recompile the runtime system!
!!!! WARNING !!!!

This is basically another round of script-enhancements:

1. sml, ml-build, and ml-makedepend accept options -D and -U to define
   and undefine CM preprocessor symbols.

2. ml-build avoids generating a new heap image if it finds that the
   existing one is still ok.  (The condition is that no ML file had to
   be recompiled and all ML files are found to be older that the heap
   file.)

   To make this work smoothly, I also hacked the runtime system as
   well as SMLofNJ.SysInfo to get access to the heap image suffix
   (.sparc-solaris, ...) that is currently being used.

   Moreover, the signature of CM.mk_standalone has changed.  See the
   CM manual.

3. ml-makedepend accepts additional options -n, -a, and -o.  (See the
   CM manual for details.)

4. More CM manual updates:
    - all of the above has been documented.
    - there is now a section describing the (CM-related) command line
      arguments that are accepted by the "sml" command

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/07/25 16:20:00 JST
Tag: blume-20000725-makedepend
Description:

Added a script called ml-makedepend.  This can be used in makefiles
for Unix' make in a way very similar to the "makedepend" command for
C.

The script internally uses function CM.sources.

Synopsis:

    ml-makedepend [-f makefile] cmfile targetname

The default for the makefile is "makefile" (or "Makefile" should
"makefile" not exist).

ml-makedepend adds a cmfile/targetname-specific section to this
makefile (after removing the previous version of this section).  The
section contains a single dependency specification with targetname on
the LHS (targetname is an arbitrary name), and a list of files derived
from the cmfile on the RHS.  Some of the files on the RHS are
ARCH/OPSYS-specific.  Therefore, ml-makedepend inserts references to
"make" variables $(ARCH) and $(OPSYS) in place of the corresponding
path names.  The makefile writer is responsible for making sure that
these variables have correct at the time "make" is invoked.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/07/22 23:30:00 JST
Tag: blume-20000722-urlupdate
Description:

Changed BOOT and config/srcarchiveurl to point to BL server:

    ftp://ftp.research.bell-labs.com/dist/smlnj/working/110.29/

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/07/18 18:00:00 JST
Tag: blume-20000718-Version_110_29
Description:

1. Updated src/compiler/TopLevel/main/version.sml to version 110.29

2. Updated config/version to 110.29

3. Updated config/srcarchiveurl

3. New boot files!
   ftp://ftp.cs.princeton.edu/pub/people/blume/sml/110.29-autofetch

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/07/11 13:58:00 JST
Tag: blume-20000711-doctypo
Description:

Fixed a few typos in CM manual.

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/06/15 00:38:00
Tag: leunga-20000704-sparc-x86

1. x86 peephole improvement sp += k; sp -= k => nop  [from John]
2. fix to x86 RET bug [found by Dan Grossman] 
3. sparc assembly bug fix for ticc instructions [found by Fermin]

   Affects c-- and moby only

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/07/04 15:26:00
Tag: blume-20000704-trigger
Description:

1. Improvements to CM manual.
2. SMLofNJ.Internals.BTrace.trigger reinstated as an alternative way
   of getting a back-trace.  The function, when called, raises an
   internal exception which explicitly carries the full back-trace history,
   so it is unaffected by any intervening handle-raise pairs ("trivial"
   or not).  The interactive loop will print that history once it arrives
   at top level.
   Short of having all exceptions implicitly carry the full history, the
   recommended way of using this facility is:
     - compile your program with instrumentation "on"
     - run it, when it raises an exception, look at the history
     - if the history is "cut off" because of some handler, go and modify
       your program so that it explicitly calls BTrace.trigger
     - recompile (still instrumented), and rerun; look at the full history

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/07/03 15:36:00 JST
Tag: blume-20000702-manual
Description:

Small corrections and updates to CM manual.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/06/29 16:04:00 JST
Tag: blume-20000629-yacctool
Description:

Changes:

1. Class "mlyacc" now takes separate arguments to pass options to
   generated .sml- and .sig-files independently.
2. Corresponding CM manual updates.
3. BTrace module now also reports call sites.  (However, for loop clusters
   it only shows from where the cluster was entered.)  There are associated
   modifications to core.sml, internals.{sig,sml}, btrace.sml, and btimp.sml.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/06/27 16:51:00 JST
Tag: blume-20000627-noweb
Description:

Changes:

 1. Implemented "subdir" and "witness" options for noweb tool.
    This caused some slight internal changes in CM's tool implementation.
 2. Fixed bug in "tool plugin" mechanism.  This is essentially cleaning
    some remaining issues from earlier path anchor changes.
 3. Updated CM manual accordingly.

 4. Changed implementation of back-tracing so that I now consider it
    ready for prime-time.

    In particular, you don't have to explicitly trigger the back-trace
    anymore.  Instead, if you are running BTrace-instrumented code and
    there is an uncaught exception (regardless of whether or not it was
    raised in instrumented code), the top-level evalloop will print
    the back-trace.

    Features:

      - Instrumented and uninstrumented code work together seemlessly.
        (Of course, uninstrumented code is never mentioned in actual
         back-traces.)

      - Asymptotic time- and space-complexity of instrumented code is
        equal to that of uninstrumented code.  (This means that
        tail-recursion is preserved by the instrumentation phase.)

      - Modules whose code has been instrumented in different sessions
        work together without problem.

      - There is no penalty whatsoever on uninstrumented code.

      - There is no penalty on "raise" expressions, even in
        instrumented code.

    A potential bug (or perhaps it is a feature, too):

      A back-trace reaches no further than the outermost instrumented
      non-trivial "raise".  Here, a "trivial" raise is one that is the
      sole RHS of a "handle" rule.  Thus, back-traces reach trough

           <exp> handle e => raise e

      and even

           <exp> handle Foo => raise Bar

      and, of course, through

           <exp> handle Foo => ...

     if the exception was not Foo.

     Back-traces always reach right through any un-instrumented code
     including any of its "handle" expressions, trivial or not.

   To try this out, do the following:

     - Erase all existing binfiles for your program.
       (You may keep binfiles for those modules where you think you
        definitely don't need back-tracing.)
     - Turn on back-trace instrumentation:
          SMLofNJ.Internals.BTrace.mode (SOME true);
     - Recompile your program.  (I.e., run "CM.make" or "use".)
     - You may now turn instrumentation off again (if you want):
          SMLofNJ.Internals.BTrace.mode (SOME false);
     - Run your program as usual.  If it raises an exception that
       reaches the interactive toplevel, then a back-trace will
       automatically be printed.  After that, the toplevel loop
       will print the exception history as usual.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/06/26 09:56:46 JST
Tag: blume-20000626-setup
Description:

CM: - setup-parameter to "sml" added; this can be used to run arbitrary
      ML code before and after compiling a file (e.g., to set compiler
      flags)

Compiler: - improved btrace API (in core.sml, internals.{sig,sml})
          - associated changes to btrace.sml (BTrace instrumentation pass)
          - cleaner implementation of btimp.sml (BTrace tracing and report
            module)

CM manual: * new path encoding documented
           * description of setup-parameter to "sml" added

The biggest user-visible change to back-tracing is that it is no
longer necessary to compile all traced modules within the same
session.  (This was a real limitation.)

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/06/24 12:40:00 JST
Tag: blume-20000624-startup
Description:

Fixes startup slowdown problem.  (I was calling SrcPath.sync a _tad_
bit too often -- to put it mildly. :)

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/06/23 18:20:00 JST
Tag: blume-20000623-btrace
Description:

This updates adds a backtrace facility to aid programmers in debugging
their programs.  This involves the following changes:

1. Module system/smlnj/init/core.sml (structure _Core) now has hooks for
   keeping track of the current call stack.  When programs are compiled
   in a special mode, the compiler will insert calls to these hooks
   into the user program.
   "Hook" means that it is possible for different implementations of
   back-tracing to register themselves (at different times).

2. compiler/MiscUtil/profile/btrace.sml implements the annotation phase
   as an Absyn.dec->Absyn.dec rewrite.  Normally this phase is turned off.
   It can be turned on using this call:
     SMLofNJ.Internals.BTrace.mode (SOME true);
   Turning it off again:
     SMLofNJ.Internals.BTrace.mode (SOME false);
   Querying the current status:
     SMLofNJ.Internals.BTrace.mode NONE;
   Annotated programs are about twice as big as normal ones, and they
   run a factor of 2 to 4 slower with a dummy back-trace plugin (one
   where all hooks do nothing).  The slowdown with a plugin that is
   actually useful (such as the one supplied by default) is even greater,
   but in the case of the default plugin it is still only an constant
   factor (amortized).

3. system/Basis/Implementation/NJ/internals.{sig,sml} have been augmented
   with a sub-structure BTrace for controlling back-tracing.  In particular,
   the above-mentioned function "mode" controls whether the annotation
   phase is invoked by the compiler.  Another important function is
   "trigger": when called it aborts the current execution and causes
   the top-level loop to print a full back-trace.

4. compiler/MiscUtil/profile/btimp.sml is the current default plugin
   for back-tracing.  It keeps track of the dynamic call stack and in
   addition to that it keeps a partial history at each "level" of that
   stack.  For example, if a tail-calls b, b tail-calls c, and c tail-calls
   d and b (at separate times, dynamically), then the report will show:

   GOTO   d
         /c
   GOTO  \b
   CALL   a

   This shows that there was an initial non-tail call of a, then a
   tail-call to b or c, looping behavior in a cluster of functions that
   consist of b and c, and then a goto from that cluster (i.e., either from
   b or from c) to d.

   Note that (depending on the user program) the amount of information
   that the back-trace module has to keep track of at each level is bounded
   by a constant.  Thus, the whole implementation has the same asymptotical
   complexity as the original program (both in space and in time).

5. compiler/TopLevel/interact/evalloop.sml has been modified to
   handle the special exception SMLofNJ.Internals.BTrace.BTrace
   which is raised by the "trigger" function mentioned above.

Notes on usage:

- Annotated code works well together with unannotated code:
Unannotated calls simply do not show up at all in the backtrace.

- It is not a good idea to let modules that were annotated during
different sessions run at the same time.  This is because the compiler
chooses small integers to identify individual functions, and there
will be clashes if different modules were compiled in separate sessions.
(Nothing will crash, and you will even be told about the clashes, but
back-trace information will in general not be useful.)

- Back-tracing can be confused by callcc and capture.

- The only way of getting a back-trace right now is to explicitly
invoke the "trigger" function from your user program.  Eventually, we
should make every exception carry back-trace information (if
available).  But since this creates more overhead at "raise"-time
(similar to the current exnHistory overhead), I have not yet
implemented this.  (The implementation will be rather easy.)  With
exceptions carrying back-trace information, this facility will be even
more useful because users don't need to modify their programs...

- While it is possible to compile the compiler with back-trace
annotations turned on (I did it to get some confidence in
correctness), you must make absolutely sure that core.sml and
btimp.sml are compiled WITHOUT annotation!  (core.sml cannot actually
be compiled with annotation because there is no core access yet, but
if you compile btimp.sml with annotation, then the system will go into
an infinite recursion and crash.)
Since CM currently does not know about BTrace, the only way to turn
annotations on and off for different modules of the compiler is to
interrupt CMB.make, change the settings, and re-invoke it.  Of course,
this is awkward and clumsy.

Sample sessions:

Standard ML of New Jersey v110.28.1 [FLINT v1.5], June 5, 2000
- SMLofNJ.Internals.BTrace.mode (SOME true);
[autoloading]
[autoloading done]
val it = false : bool
- structure X = struct
-     fun main n = let
-         fun a (x, 0) = d x
-           | a (x, n) = b (x, n - 1)
-         and b (x, n) = c (x, n)
-         and c (x, n) = a (x, n)
-         and d x = e (x, 3)
-         and e (x, 0) = f x
-           | e (x, n) = e (x, n - 1)
-         and f 0 = SMLofNJ.Internals.BTrace.trigger ()
-           | f n = n * g (n - 1)
-         and g n = a (n, 3)
-     in
-         f n
-     end
- end;
structure X : sig val main : int -> int end
- X.main 3;
*** BACK-TRACE ***
GOTO   stdIn:4.2-13.20: X.main[2].f
GOTO-( stdIn:4.2-13.20: X.main[2].e
GOTO   stdIn:4.2-13.20: X.main[2].d
     / stdIn:4.2-13.20: X.main[2].a
     | stdIn:4.2-13.20: X.main[2].b
GOTO-\ stdIn:4.2-13.20: X.main[2].c
CALL   stdIn:4.2-13.20: X.main[2].g
GOTO   stdIn:4.2-13.20: X.main[2].f
GOTO-( stdIn:4.2-13.20: X.main[2].e
GOTO   stdIn:4.2-13.20: X.main[2].d
     / stdIn:4.2-13.20: X.main[2].a
     | stdIn:4.2-13.20: X.main[2].b
GOTO-\ stdIn:4.2-13.20: X.main[2].c
CALL   stdIn:4.2-13.20: X.main[2].g
GOTO   stdIn:4.2-13.20: X.main[2].f
GOTO-( stdIn:4.2-13.20: X.main[2].e
GOTO   stdIn:4.2-13.20: X.main[2].d
     / stdIn:4.2-13.20: X.main[2].a
     | stdIn:4.2-13.20: X.main[2].b
GOTO-\ stdIn:4.2-13.20: X.main[2].c
CALL   stdIn:4.2-13.20: X.main[2].g
GOTO   stdIn:4.2-13.20: X.main[2].f
CALL   stdIn:2.15-17.4: X.main[2]
- 

(Note that because of a FLINt bug the above code currently does not
compile without BTrace turned on.)

Here is another example, using my modified Tiger compiler:

Standard ML of New Jersey v110.28.1 [FLINT v1.5], June 5, 2000
- SMLofNJ.Internals.BTrace.mode (SOME true);
[autoloading]
[autoloading done]
val it = false : bool
- CM.make "sources.cm";
[autoloading]
...
[autoloading done]
[scanning sources.cm]
[parsing (sources.cm):parse.sml]
[creating directory CM/SKEL ...]
[parsing (sources.cm):tiger.lex.sml]
...
[wrote CM/sparc-unix/semant.sml]
[compiling (sources.cm):main.sml]
[wrote CM/sparc-unix/main.sml]
[New bindings added.]
val it = true : bool
- Main.compile ("../testcases/merge.tig", "foo.out");
*** BACK-TRACE ***
CALL   lib/semant.sml:99.2-396.21: SemantFun[2].transExp.trvar
CALL   lib/semant.sml:99.2-396.21: SemantFun[2].transExp.trexp
CALL   lib/semant.sml:289.3-295.22: SemantFun[2].transExp.trexp.check[2]
GOTO   lib/semant.sml:289.3-295.22: SemantFun[2].transExp.trexp.check[2]
CALL   lib/semant.sml:99.2-396.21: SemantFun[2].transExp.trexp
CALL   lib/semant.sml:99.2-396.21: SemantFun[2].transExp.trexp
CALL   lib/semant.sml:488.3-505.6: SemantFun[2].transDec.trdec[2].transBody[2]
     / lib/semant.sml:411.65-543.8: SemantFun[2].transDec
CALL-\ lib/semant.sml:413.2-540.9: SemantFun[2].transDec.trdec[2]
CALL   lib/semant.sml:99.2-396.21: SemantFun[2].transExp.trexp
CALL   lib/semant.sml:8.52-558.4: SemantFun[2].transProg[2]
CALL   main.sml:1.18-118.4: Main.compile[2]
- 

----------------------------------------------------------------------
Name: Matthias Blumen
Date: 2000/06/21 18:00:00 JST
Tag: blume-20000621-manual
Description:

CM manual update: Path environments documented.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/06/19 13:40:00
Tag: blume-20000619-manual
Description:

CM manual and system/README update.  This only covers the fact that
there are no more implicit anchors.  (Path environments and the "bind"
option to "cm" have yet to be documented.)

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/06/19 11:05:00 JST
Tag: blume-20000619-chdir-bugfix
Description:

Fixed a bug in new SrcPath module that sometimes led to a bad chDir call.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/06/18 22:00:10 JST
Tag: blume-20000618-implicit-anchors-really-gone
Description:

I updates the previous HISTORY entry where I forgot to mention that
implicit anchors are no longer with us.

The current update also gets rid of the (now useless) controller
CM.Control.implicit_anchors.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/06/16 17:30:00 JST
Tag: blume-20000616-anchorenv
Description:

This patch implements the long anticipated (just kidding :) "anchor
environment" mechanism.  In the course of doing this, I also
re-implemented CM's internal "SrcPath" module from scratch.  The new
one should be more robust in certain boundary cases.  In any case, it
is a lot cleaner than its predecessor (IMHO).

This time, although there is yet another boot file format change, I
kept the unpickler backward-compatible.  As a result, no new bootfiles
are necessary and bootstrapping is straightforward.  (You cannot read
new bootfiles into an old system, but the other way around is no
problem.)

Visible changes:

** 0. Implicit path anchors (without the leading $-symbol) are no
longer recognized at all. This means that such path names are not
illegal either.  For example, the name basis.cm simply refers to a
local file called "basis.cm" (i.e, the name is an ordinary path
relative to .cm-files directory).  Or, to put it differently, only
names that start with $ are anchored paths.

** 1. The $<singlearc> abbreviation for $/<singlearc> has finally
vanished.

John (Reppy) had critizised this as soon as I originally proposed and
implemented it, but at that time I did not really deeply believe
him. :) Now I came full-circle because I need the $<singlearc> syntax
in another place where it cannot be seen as an abbreviation for
$/<singlearc>.  To avoid the confusion, $<singlearc> now means what it
seems to mean (i.e., it "expands" into the corresponding anchor
value).

However, when paths are used as members in CM description files, it
continues to be true that there must be at least another arc after the
anchor.  This is now enforced separately during semantic analysis
(i.e., from a lexical/syntactical point of view, the notation is ok.)

** 2. The "cm" class now accepts an option "bind".  The option's value
is a sub-option list of precisely two items -- one labeled "anchor"
and the other one labeled "value".  As you might expect, "anchor" is
used to specify an anchor name to be bound, and "value" specifies what
the anchor is being bound to.

The value must be a directory name and can be given in either standard
syntax (including the possibility that it is itself an anchored path)
or native syntax.

Examples:

   foo.cm (bind:(anchor:bar value:$mystuff/bar))
   lib.cm (bind:(anchor:a value:"H:\\x\\y\\z"))  (* only works under windows *)

and so on.

The meaning of this is that the .cm-file will be processed with an
augmented anchor environment where the given anchor(s) is/are bound to
the given values(s).

The rationale for having this feature is this: Suppose you are trying
to use two different (already stable) libraries a.cm and b.cm (that
you perhaps didn't write yourself).  Further, suppose each of these
two libraries internally uses its own auxiliary library $aux/lib.cm.
Normally you would now have a problem because the anchor "lib" can not
be bound to more than one value globally.  Therefore, the project that
uses both a.cm and b.cm must locally redirect the anchor to some other
place:

   a.cm (bind:(anchor:lib value:/usr/lib/smlnj/a-stuff))
   b.cm (bind:(anchor:lib value:/usr/lib/smlnj/b-stuff))

This hard-wires $lib/aux.cm to /usr/lib/smlnj/a-stuff/aux.cm or
/usr/lib/smlnj/b-stuff/aux.cm, respectively.

Hard-wiring path names is a bit inflexible (and CM will verbosely warn
you when you do so at the time of CM.stabilize).  Therefore, you can
also use an anchored path as the value:

  a.cm (bind:(anchor:lib value:$a-lib))
  b.cm (bind:(anchor:lib value:$b-lib))

Now you can globally configure (using the usual CM.Anchor.anchor or
pathconfig machinery) bindings for "a-lib" and "b-lib".  Since "lib"
itself is always locally bound, setting it globally is no longer
meaningful or necessary (but it does not hurt either).  In fact, "lib"
can still be used as a global anchor for separate purposes.  As a
matter of fact, one can locally define "lib" in terms of a global
"lib":

  a.cm (bind:(anchor:lib value:$lib/a))
  b.cm (bind:(anchor:lib value:$lib/b))

** 3: The encoding of path names has changed.  This affects the way
path names are shown in CM's progress report and also the internal
protocol encoding used for parallel make.

The encoding now uses one or more ':'-separated segments.  Each
segments corresponds to a file that has been specified relative to the
file given by its preceding segment.  The first segment is either
relative to the CWD, absolute, or anchored.  Each segment itself is
basically a Unix pathname; all segments but the first are relative.

Example:

   $foo/bar/baz.cm:a/b/c.sml

This path denotes the file bar/a/b/c.sml relative to the directory
denoted by anchor "foo".  Notice that the encoding also includes
baz.cm which is the .cm-file that listed a/b/c.sml.  As usual, such
paths are resolved relative to the .cm-files directory, so baz.cm must
be ignored to get the "real" pathname.

To make this fact more obvious, CM puts the names of such "virtual
arcs" into parentheses when they appear in progress reports. (No
parentheses will appear in the internal protocol encoding.)  Thus,
what you really see is:

  $foo/bar/(baz.cm):a/b/c.sml

I find this notation to be much more informative than before.

Another new feature of the encoding is that special characters
including parentheses, colons, (back)slashes, and white space are
written as \ddd (where ddd is the decimal encoding of the character).

*** The CM manual still needs to be updated.

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/06/15 00:38:00
Tag: leunga-20000615-x86-peephole

x86 Peephole fix by Fermin.  Affects c-- and moby only.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/06/12 11:40:00
Tag: blume-20000612-parmakefix
Description:

More cleanup after changing the file naming scheme: This time I
repaired the parallel make mechanism for CMB.make which I broke earlier.

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/06/09 01:25:00
Tag: leunga-20000609-various

None of these things should affect normal SML/NJ operations

1. Peephole improvements provided by Fermin (c--)
2. New annotation DEFUSE for adding extra dependence (moby)
3. New X86 LOCK instructions (moby)
4. New machine description language for reservation tables (scheduling)
5. Fixes to various optimization/analysis modules (branch chaining, dominator
   trees etc.)
6. I've changed the CM files so that they can work with versions
   110.0.6, 110.25 and 110.28

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/06/09 12:40:00
Tag: blume-20000609-log
Description:

- Removed all(?) remaining RCS Log entries from sources.

- Fixed bug in ml-yacc and ml-lex sources (use explicit anchors for
  anchored paths).

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/06/07 17:00:00 JST
Tag: blume-20000607-no-implicit-anchors
Description:

1. This update changes the default setting for
CM.Control.implicit_anchors from true to false.  This means that
implicit anchors are no longer permitted by default.  I also tried to
make sure that nothing else still relies on implicit anchors.
(This is the next step on the schedule towards a CM that does not even
have the notion of implicit anchors anymore.)

2. More CM manual updates.

3. I managed to track down and fix the pickling bug I mentioned last
time.  Because of the previously existing workaround, this entails no
immediate practical changes.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/06/06 11:15:00 JST
Tag: blume-20000606-lazierpickle
Description:

!!!! NEW BOOT FILES !!!!

* The main purpose of this update is to make library pickles lazier in
order to reduce the initial space penalty for autoloading a library.
As a result, it is now possible to have $smlnj/compiler.cm
pre-registered.  This should take care of the many complaints or
inquiries about missing structure Compiler.  This required changes to
CM's internal data structures and small tweaks to some algorithms.

As a neat additional effect, it is no longer necessary (for the sake
of lean heap image files) to distinguish between a "minimal" CM and a
"full" CM.  Now, there is only one CM (i.e., the "full" version:
$smlnj/cm.cm aka $smlnj/cm/full.cm), and it is always available at the
interactive top level. ($smlnj/cm/minimal.cm is gone.)

To make the life of compiler-hackers easier, "makeml" now also
pre-registers $smlnj/cmb.cm (aka $smlnj/cmb/current.cm).  In other
words, after you bootstrap a new sml for the first time, you will not
have to autoload $smlnj/cmb.cm again afterwards.  (The first time
around you will still have to do it, though.)

* A second change consists of major updates to the CM manual.  There
are now several appendices with summary information and also a full
specification of the CM description file syntax.

* In directory src/system I added the script "allcross".  This script
invokes sml and cross-compiles the compiler for all supported
architectures.  (Useful when providing a new set of boot files.)

* There seems to be a latent bug in my "lazy pickles" mechanism.  I
added a small tweak to pickle-util.sml to work around this problem,
but it is not a proper fix yet.  I will investigate further.  (The
effect of the bug was an inflation of library pickle size.)

* Version number increased to 110.28.1 (to avoid compatibility problems).

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/05/25 17:28 EDT
Tag: leunga-20000525-ra
Description:

  Fixed a bug in freezing phase of the register allocator.

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/05/15 22:53 EDT
Tag: leunga-20000515-alpha-x86-ra
Description:

  1. Alpha

      Slight cleanup.  Removed the instruction SGNXL

  2. X86

      Added the following instructions to the instruction set:
   
        ROLx, RORx,
        BTx, BTSx, BTLx, BTRx, 
        XCHGx, and variants with the LOCK prefix

  3. Register Allocation

      The module ra-rewrite-with-renaming has been improved.

  These have no effect on SML/NJ.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/05/15 16:20:00 JST
Tag: blume-20000515-lightrebuild
Description:

1. I added an alternative to "-rebuild" to "makeml".  The difference is
   that prior to calling CMB.make' the CM-variable "LIGHT" will be
   defined.  In effect, the command will not build any cross-compiler
   backends and therefore finish more quickly.

   The "fixpt" script also takes a "-light" switch to be able to use
   this new facility while compiling for a fixpoint.

2. I replaced all mentions of anchored paths in group owner specifications
   with simple relative paths (usually starting with "..").
   The rationale is that a library's internal workings should not be
   compromised by the lack of some anchor.  (An anchor is necessary
   for someone who wants to refer to the library by an anchored path,
   but it should not be necessary to build the same library in the first
   place.)

3. I changed the way CM's tool mechanism determines the shell command
   string used for things like ml-yacc etc. so that it does not break
   when CM.Control.implicit_anchors is turned off.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/05/12 18:20:00 JST
Tag: blume-20000512-ml-build
Description:

Fixed a bug in config/_ml-build that prevented ml-yacc and ml-lex from
getting installed properly (by config/install.sh).

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/05/12 17:30:00 JST
Tag: blume-20000512-anchors
Description:

!!! NEW BOOT FILES !!!

This change is in preparation of fading out support for "implicitly
anchored path names".  I went through all sources and used the
explicit (and relatively new) $-notation.  See system/README and the
CM manual for more info on this.

I also modified the anchoring scheme for some things such as "smlnj",
"MLRISC", "cm", etc. to take advantage of the fact that explicit
anchors are more expressive: anchor name and first arc do not have to
coincide.  This entails the following user-visible change:

You have to write $smlnj/foo/bar instead of smlnj/foo/bar.  In
particular, when you fire up sml with a command-line argument, say,
e.g.:

   sml '$smlnj/cmb.cm'

At the ML toplevel prompt:

   CM.autoload "$smlnj/cmb.cm";

There is also a new controller in CM.Control that can be used to turn
off all remaining support for implicit anchors by saying:

    CM.autoload "$smlnj/
    #set CM.Control.implicit_anchors false;

This causes CM to reject implicitly anchored paths.  This is (for the
time being) less permissive than the "final" version where there will
be no more such implicit anchors and relative paths will be just that:
relative.

The next step (version after next version?) will be to make the
default for CM.Control.implicit_anchors false.  After the dust has
settled, I can then produce the "final" version of this...

Note: Since bootstrapping is a bit tricky, I provided new boot files.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/05/11 16:30:00 JST
Tag: blume-20000511-sources
Description:

The main change is that I added function CM.sources as a generalized
version of the earlier CM.makedepend.  This entails the following
additional changes:

  - CM.makedepend has been dropped.

  - CM manual has been updated.

  - TOOLS signature and API have been changed.

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/05/10 21:17 EDT
Tag: leunga-20000510-moby-c--ssa
Description:

  Various bug fixes and new features for C--, Moby and MLRISC optimizations.
None of these affect SML/NJ.

1. Register Allocation

    a. A new ra spilling module (ra/ra-spill-with-renaming) is implemented.
       This module tries to remove local (i.e. basic block level) redundancies
       during spilling.  

    b. A new framework for performing region based register allocation.
       Not yet entirely functional.

2. X86

   a. DefUse for POP was missing the stack pointer [found by Lal]
   b. Reload for CALL was incorrect in X86Spill [found by John]
   c. Various fixes in X86Spill so that it can be used correctly for 
      the new spilling module.

3. SSA/IR

   a. New module ir/dj-dataflow.sml implements elimination based
      data flow analysis.

4. MLRiscGen

   a. Fix for gc type annotation

5. MDGen

   Various fixes for machine description -> ml code translation.  For ssa
   only.

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/05/08 22:17 EDT
Tag: leunga-20000508-labexp
Description:

  Fermin has found a few assembly problems with constant expressions 
  generated in LabelExp.  Mostly, the problems involve extra parentheses,
  which choke on dumb assemblers.  This is his fix.

----------------------------------------------------------------------
Name: Dave MacQueen
Date: 2000/04/09 14:00 EDT
Tag: dbm-20000502-Version_110_28
Description:

1. Updated src/compiler/TopLevel/main/version.sml to version 110.28

2. Updated config/version to 110.28

3. Updated config/srcarchiveurl

3. New boot files!
   ftp://ftp.research.bell-labs.com/dist/smlnj/working/110.28/

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/05/01 19:05:00 JST
Tag: blume-20000501-noweb
Description:

A new noweb tool has been added.  The existing system is entirely
unaffected by this, but some CM users have asked for renewed noweb
support.  Everything is documented in the CM manual.

New (plugin) libraries:

   noweb-tool.cm
   nw-ext.cm

----------------------------------------------------------------------
Name: Dave MacQueen
Date: 2000/04/30 12:40PM EDT
Tag: dbm-20000430-bug_fixes
Description:

1. Fix for bug 1498
   smlnj/src/system/Basis/Implementation/Unsafe/object.sig
   smlnj/src/system/Basis/Implementation/Unsafe/object.sml
     added toRealArray function
   smlnj/src/compiler/MiscUtil/print/ppobj.sml
     added check for tag Obj.RealArray to array printing case in ppObj

2. Fix for bug 1510
   smlnj/src/compiler/Semant/types/typesutil.sml
     fixed definition of dummyargs (used by equalTycon) so that 
     dummy args are distinct types

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/04/30 01:00:00 JST
Tag: blume-20000430-versions
Description:

1. CM version numbering added.  This is an implementation of Lal's
   proposal for adding version numbers and version checking to .cm
   files.  Lal said that his proposal was just that -- a proposal.
   For the time being I went ahead and implemented it so that people
   can comment on it.  Everything is completely backward-compatible
   (except for the stable library format, i.e., new bootfiles!).

   As usual, see the CM manual for details.

2. An alternative syntax for anchored paths has been implemented.
   Dave has recently voiced the same concerns that I had when I did
   this, so there should be some support.  My take is that eventually
   I will let support for the current syntax (where anchors are
   "implicit") fade out in favor of the new, explicit syntax.
   In order to be backward-compatible, both old and new syntax are
   currently supported.

   Again, see the CM manual for details.

3. Parallel make is trying to be slightly smarter:  When the master
   process finds a "bottleneck", i.e., when there is only one
   compilation unit that can be compiled and everybody else is
   waiting on it, then it will simply compile it directly instead
   of clumsily telling one of the slaves to do it.

4. Support for "unsharing" added.  This is necessary in order to be
   able to have two different versions of the same library running
   at the same time (e.g., for trying out a new MLRISC while still
   having the old MLRISC linked into the current compiler, etc.)
   See the CM manual.

5. Simple "makedepend" functionality added for generating Makefile
   dependency information.  (This is rather crude at the moment.
   Expect some changes here in the future.)

6. ".fun" added as a recognized suffix for ML files. Also documented
   explicitly in the manual that the fallback behavior (unknown suffix
   -> ML file) is not an official feature!

7. Small changes to the pickler for stable libraries.

8. Several internal changes to CM (for cleanup/improvement).


!!!! NEW BINFILES !!!!

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/04/28 17:30:00 JST
Tag: blume-20000428-pathconfig
Description:

1. I changed config/install.sh to remove duplicate entries from the
   lib/pathconfig file at the end.  Moreover, the final version of
   lib/pathconfig is sorted alphabetically.  The same (sorting) is done
   in src/system/installml.

2. The config/install.sh script now consistently uses relative
   pathnames in lib/pathconfig whenever the anchor is in the lib
   directory.  (So far this was true for the libraries that come
   pre-compiled and bundled as part of the bootfiles but not for
   libraries that are compiled by the script itself.)

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/04/26 13:10:00 JST
Tag: blume-20000426-fun_suffix
Description:

Added ".fun" as a recognized file name suffix (for ML code).

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/04/25 17:00:00 EST
Tag: leunga-20000425-alpha-ra
Description:

1. Alpha

    PSEUDOARITH was missing in AlphaRewrite.  This causes an endless loop
in C--. 

2. RA

   Added a flag "ra-dump-size" to print out the size of the flowgraph
   and the interference graph.

----------------------------------------------------------------------
Name: Dave MacQueen
Date: 2000/04/25/
Tag: dbm-20000425-mlyacc_doc_examples
Description: 
  Updated mlyacc.tex sections 5 and 7 for SML '97 and CM.
  Updated all three examples in src/ml-yacc/examples to run
  under 110.* using CM.make.

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/04/20 23:04:00 EST
Tag: leunga-20000420-ssa-c---stuff
Description:

  This update synchronizes my repository with Yale's.  Most of these
changes, however, do not affect SML/NJ at all (the RA is an exception).

1. Register Allocator

   a. An improvement in the interference graph construction:  
      Given a copy

            s <- t

      no interference edge between s and t is added for this definition of s.
 
   b. I've added two new spill heuristic modules that Fermin and I developed
      (in the new library RA.cm). These are unused in SML/NJ but maybe
      useful for others (Moby?)

2. X86

   a. Various fixes in the backend provided by Fermin [C--] and Lal.

3. Alpha

   a. Added the BSR instruction and code generation that goes with it [C--]
   b. Other fixes too numerous to recount provided by Fermin [C--]

4. Regmaps

   a. The regmaps are not initialized with the identity physical bindings 
      at creation time.  This is unneeded.

5. MLRISC Optimizations

   a. The DJ-Graph module can now compute the iterated dominance frontiers
      intersects with liveness incrementally in linear time! Woohoo! 
      This is now used in my new SSA construction algorithm.

   b. THe branch reorganization module is now smarter about linear chains of
      basic blocks.
  

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/04/12 13:52:00 JST
Tag: blume_main_v110p27_1
Description:

Changed install.sh script to handle archive files without version number
and to use "boot.<arch>-<os>" instead of "sml.boot.<arch>-<os>" for the
name of the boot file archive.

----------------------------------------------------------------------
Name: Dave MacQueen
Date: 2000/04/09 14:00 EDT
Tag: dbm-20000410-Version_110_27
Description:

1. Updated src/compiler/TopLevel/main/version.sml to version 110.27

2. Updated src/config/version to 110.27

3. New boot files!

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/04/09 19:09:00 EST
Tag: leunga-20000409-misc
Description:

1.  Yet another fix for x86 assembly for idivl, imull, mull and friends.

2.  Miscellaneous improvements to MLRISC (unused in sml/nj)  

----------------------------------------------------------------------
Name: Stefan
Date: 2000/04/07 10:00:00 EDT
Tag: monnier-20000406-branch-handling
Description:

Improved handling of branches (mostly those generated from
polymorphic equality), removed switchoff and changed the
default optimization settings (more cpsopt and less flintopt).

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/04/06 01:30:00 EST
Tag: leunga-20000406-peephole-x86-SSA-2
Description:

   Forgot a few files.  

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/04/06 00:36:00 EST
Tag: leunga-20000406-peephole-x86-SSA
Description:

1.  New Peephole code

2.  Minor improvement to X86 instruction selection

3.  Various fixes to SSA and machine description -> code translator

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/04/05 12:30:00 JST
Tag: blume_main_v110p26p2_3
Description:

This update just merges three minor cosmetic updates to CM's sources
to get ready for the 110.27 code freeze on Friday.  No functionality
has changed.

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/04/04 19:39:00 EST
Tag: leunga-20000404-x86-asm
Description:

1.  Fixed a problem in X86 assembly.

    Things like

       jmp %eax
       jmp (%eax)

    should be output as

       jmp *%eax
       jmp *(%eax)

2.  Assembly output

      Added a new flag 

          "asm-indent-copies" (default to false)

      When this flag is on, parallel copies will be indented an extra level.

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/04/04 03:18:00 EST
Tag: leunga-20000404-C--Moby
Description:

    All of these fixes are related to C--, Moby, and my own optimization
    stuff; so they shouldn't affect SML/NJ.

1.  X86

    Various fixes related floating point, and extensions.

2.  Alpha 

    Some extra patterns related to loads with signed/zero extension
    provided by Fermin.

3.  Assembly 

    When generating assembly, resolve the value of client defined constants, 
    instead of generating symbolic values.  This is controlled by the 
    new flag "asm-resolve-constants", which is default to true.

4.  Machine Descriptions

    a. The precedence parser was slightly broken when parsing infixr symbols.
    b. The type generalizing code had the bound variables reversed, resulting
       in a problem during arity raising. 
    c. Various fixes in machine descriptions.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/04/03 16:05:00 JST
Tag: blume_main_v110p26p2_2
Description:

I eliminated coreEnv from compInfo.  Access to the "Core" structure is
now done via the ordinary static environment that is context to each
compilation unit.

To this end, I arranged that instead of "structure Core" as "structure
_Core" is bound in the pervasive environment.  Core access is done via
_Core (which can never be accidentally rebound because _Core is not a
legal surface-syntax symbol).

The current solution is much cleaner because the core environment is
now simply part of the pervasive environment which is part of every
compilation unit's context anyway.  In particular, this eliminates all
special-case handling that was necessary until now in order to deal
with dynamic and symbolic parts of the core environment.

Remaining hackery (to bind the "magic" symbol _Core) is localized in the
compilation manager's bootstrap compiler (actually: in the "init group"
handling).  See the comments in src/system/smlnj/init/init.cmi for
more details.

I also tried to track down all mentions of "Core" (as string argument
to Symbol.strSymbol) in the compiler and replaced them with a
reference to the new CoreSym.coreSym.  Seems cleaner since the actual
name appears in one place only.

Binfile and bootfile format have not changed, but the switchover from
the old "init.cmi" to the new one is a bit tricky, so I supplied new
bootfiles anyway.

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/04/02 21:17:00 EST
Tag: leunga-20000402-mltree
Description:

   1. Renamed the constructor CALL in MLTREE by popular demand.
   2. Added a bunch of files from my repository.  These are currently
      used by other non-SMLNJ backends.

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/03/31 21:15:00 EST
Tag: leunga-20000331-aliasing
Description:

This update contains a rewritten (and hopefully more correct) module 
for extracting aliasing information from CPS.  

   To turn on this feature:  

        Compiler.Control.CG.memDisambiguate := true

   To pretty print the region information with assembly

       Compiler.Control.MLRISC.getFlag "asm-show-region" := true;

   To control how many levels of aliasing information are printed, use:

       Compiler.Control.MLRISC.getInt "points-to-show-level" := n

   The default of n is 3.

----------------------------------------------------------------------
Name: David MacQueen
Date: 2000/03/31 11:15:00 EST
Tag: dbm-20000331-runtime_fix
Description:

This update contains:

1. runtime/c-lib/c-libraries.c
   includes added in revision 1.2 caused compilation errors on hppa-hpux

2. fix for bug 1556
   system/Basis/Implementation/NJ/internal-signals.sml

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/03/31 18:00:00 JST
Tag: blume_main_v110p26p2_1
Description:

This update contains:

1. A small change to CM's handling of stable libraries:
   CM now maintains one "global" modmap that is used for all stable
   libraries.  The use of such a global modmap maximizes sharing and
   minimizes the need for re-traversing parts of environments during
   modmap construction.  (However, this has minor impact since modmap
   construction seems to account for just one percent or less of total
   compile time.)

2. I added a "genmap" phase to the statistics.  This is where I got the
   "one percent" number (see above).

3. CM's new tool parameter mechanism just became _even_ better. :)
   - The parser understands named parameters and recursive options.
   - The "make" and "shell" tools use these new features.
     (This makes it a lot easier to cascade these tools.)
   - There is a small syntax change: named parameters use a

       <name> : ( <option> ... )            or
       <name> : <string>

     syntax.  Previously, named parameters were implemented in an
     ad-hoc fashion by each tool individually (by parsing strings)
     and had the form

       <name>=<string>

   See the CM manual for a full description of these issues.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/03/30 18:00:00 JST
Tag: blume_main_v110p26p2_0
Description:

!!!!! WARNING !!!!!!
!!  New binfiles  !!
!!!!!!!!!!!!!!!!!!!!

This update contains:

1. Moderate changes to CM:

   - Changes to CM's tools mechanism.  In particular, it is now possible
   to have tools that accept additional "command line" parameters
   (specified in the .cm file at each instance where the tool's class is
   used).

   This was done to accommodate the new "make" and "shell" tools which
   facilitate fairly seamless hookup to portions of code managed using
   Makefiles or Shell scripts.

   There are no classes "shared" or "private" anymore.  Instead, the
   sharing annotation is now a parameter to the "sml" class.

   There is a bit of generic machinery for implementing one's own
   tools that accept command-line parameters.  However, I am not yet fully
   satisfied with that part, so expect changes here in the future.

   All existing tools are described in the CM manual.

   - Slightly better error handling.  (CM now suppresses many followup
   error messages that tended to be more annoying than helpful.)

2. Major changes to the compiler's static environment data structures.

   - no CMStaticEnv anymore.
        - no CMEnv, no "BareEnvironment" (actually, _only_ BareEnvironment,
          but it is called Environment), no conversions between different
          kinds of static environments

   - There is still a notion of a "modmap", but such modmaps are generated
     on demand at the time when they are needed.  This sounds slow, but I
     sped up the code that generates modmaps enough for this not to lead to
     a slowdown of the compiler (at least I didn't detect any).

   - To facilitate rapid modmap generation, static environments now
     contain an (optional) "modtree" structure.  Modtree annotations are
     constructed by the unpickler during unpickling.  (This means that
     the elaborator does not have to worry about modtrees at all.)
     Modtrees have the advantage that they are compositional in the same
     way as the environment data structure itself is compositional.
     As a result, modtrees never hang on to parts of an environment that
     has already been rendered "stale" by filtering or rebinding.

   - I went through many, many trials and errors before arriving at the
     current solution.  (The initial idea of "linkpaths" did not work.)
     But the result of all this is that I have touched a lot of files that
     depend on the "modules" and "types" data structures (most of the
     elaborator). There were a lot of changes during my "linkpath" trials
     that could have been reverted to their original state but weren't.
     Please, don't be too harsh on me for messing with this code a bit more
     than what was strictly necessary...  (I _did_ resist the temptation
     of doing any "global reformatting" to avoid an untimely death at
     Dave's hands. :)

   - One positive aspect of the previous point:  At least I made sure that
     all files that I touched now compile without warnings (other than
     "polyEqual").

   - compiler now tends to run "leaner" (i.e., ties up less memory in
     redundant modmaps)

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/03/29 18:00:00
Tag: leunga-20000327-mlriscGen_hppa_alpha_x86
Boot files (optional): ftp://react-ilp.cs.nyu.edu/leunga/110.26.1-sml.boot.x86-unix-20000330.tar.gz
Description:
 
   This update contains *MAJOR* changes to the way code is generated from CPS
in the module mlriscGen, and in various backend modules.

CHANGES
=======

1. MLRiscGen: forward propagation fix.

   There was a bug in forward propagation introduced at about the same time
   as the MLRISC x86 backend, which prohibits coalescing to be 
   performed effectively in loops. 

   Effect: speed up of loops in RISC architectures.
           By itself, this actually slowed down certain benchmarks on the x86.

2. MLRiscGen:  forward propagating addresses from consing.

   I've changed the way consing code is generated.  Basically I separated 
   out the initialization part:

        store tag,   offset(allocptr)
        store elem1, offset+4(allocptr)
        store elem2, offset+8(allocptr)
        ...
        store elemn, offset+4n(allocptr)

   and the address computation part:

        celladdr <- offset+4+alloctpr

   and move the address computation part

   Effect:  register pressure is generally lower as a result.  This 
            makes compilation of certain expressions much faster, such as
            long lists with non-trivial elements.

             [(0,0), (0,0), .... (0,0)]

3. MLRiscGen: base pointer elimination.

    As part of the linkage mechanism, we generate the sequence:

     L:  ...  <- start of the code fragment
 
     L1:
         base pointer <- linkreg - L1 + L

     The base pointer was then used for computing relocatable addresses
   in the code fragment.  Frequently (such as in lots of continuations) 
   this is not needed.  We now eliminate this sequence whenever possible.

     For compile time efficiency, I'm using a very stupid local heuristic.  
   But in general, this should be done as a control flow analysis.

   Effect:  Smaller code size.  Speed up of most programs.

4. Hppa back end

     Long jumps in span dependence resolution used to depend on the existence
  of the base pointer.  

     A jump to a long label L was expanded into the following sequence:
     
      LDIL %hi(L-8192), %r29
      LDO  %lo(L-8192)(%r29), %r29
      ADD  %r29, baseptr, %r29
      BV,n %r0(%r29)

     In the presence of change (3) above, this will not work.  I've changed
   it so that the following sequence of instructions are generated, which
   doesn't mention the base pointer at all:

         BL,n  L', %r29           /* branch and link, L' + 4 -> %r29 */
    L':  ADDIL L-(L'+4), %r29     /* Compute address of L */ 
         BV,n  %r0(%r29)          /* Jump */ 

5. Alpha back end

      New alpha instructions LDB/LDW have been added, as per Fermin's
   suggestions.   This is unrelated to all other changes.

6. X86 back end 

     I've changed andl to testl in the floating point test sequence
     whenever appropriate.  The Intel optimization guide states that
     testl is preferable to andl.

7. RA (x86 only)

     I've improved the spill propagation algorithm, using an approximation
   of maximal weighted independent sets.   This seems to be necessary to
   alleviate the negative effect in light of the slow down in (1). 

     I'll write down the algorithm one of these days.

8. MLRiscGen: frequencies

     I've added an annotation that states that all call gc blocks have zero
   execution frequencies.  This improves register allocation on the x86.
    
BENCHMARKS
==========

   I've only perform the comparison on 110.25.

   The platforms are:
  
    HPPA  A four processor HP machine (E9000) with 5G of memory.
    X86   A 300Hhz Pentium II with 128M of memory, and 
    SPARC An Ultra sparc 2 with 512M of memory.

   I used the following parameters for the SML benchmarks:

             @SMLalloc
     HPPA    256k
     SPARC   512k
     X86     256k

COMPILATION TIME
----------------
   Here are the numbers comparing the compilation times of the compilers.
   I've only compared 110.25 compiling the new sources versus
   a fixpoint version of the new compiler compiling the same.

                 110.25                                  New
           Total  Time in RA  Spill+Reload   Total  Time In RA Spill+Reload
     HPPA   627s    116s        2684+3584     599s    95s       1003+1879
     SPARC  892s    173s        2891+3870     708s    116s      1004+1880
     X86    999s    315s       94006+130691   987s    296s    108877+141957

               110.25         New
            Code Size      Code Size
     HPPA   8596736         8561421
     SPARC  8974299         8785143
     X86    9029180         8716783

   So in summary, things are at least as good as before.   Dramatic 
   reduction in compilation is obtained on the Sparc; I can't explain it, 
   but it is reproducible.  Perhaps someone should try to reproduce this 
   on their own machines.

SML BENCHMARKS
--------------

    On the average, all benchmarks perform at least as well as before. 

      HPPA         Compilation Time     Spill+Reload      Run Time
                 110.25  New            110.25    New   110.25  New    

      barnesHut  3.158  3.015  4.75%    1+1       0+0   2.980  2.922   2.00%
          boyer  6.152  5.708  7.77%    0+0       0+0   0.218  0.213   2.34%
   count-graphs  1.168  1.120  4.32%    0+0       0+0  22.705 23.073  -1.60%
            fft  0.877  0.792 10.74%    1+3       1+3   0.602  0.587   2.56%
    knuthBendix  3.180  2.857 11.32%    0+0       0+0   0.675  0.662   2.02%
         lexgen  6.190  5.290 17.01%    0+0       0+0   0.913  0.788  15.86%
           life  0.803  0.703 14.22%   25+25      0+0   0.153  0.140   9.52%
          logic  2.048  2.007  2.08%    6+6       1+1   4.133  4.008   3.12%
     mandelbrot  0.077  0.080 -4.17%    0+0       0+0   0.765  0.712   7.49%
         mlyacc 22.932 20.937  9.53%  154+181    32+57  0.468  0.430   8.91%
        nucleic  5.183  5.060  2.44%    2+2       0+0   0.125  0.120   4.17%
  ratio-regions  3.357  3.142  6.84%    0+0       0+0  116.225 113.173 2.70%
            ray  1.283  1.290 -0.52%    0+0       0+0   2.887  2.855   1.11%
         simple  6.307  6.032  4.56%   28+30      5+7   3.705  3.658   1.28%
            tsp  0.888  0.862  3.09%    0+0       0+0   7.040  6.893   2.13%
           vliw 24.378 23.455  3.94%  106+127    25+45  2.758  2.707   1.91%
  --------------------------------------------------------------------------
   Average                     6.12%                                   4.09%

      SPARC        Compilation Time     Spill+Reload      Run Time
                 110.25  New            110.25    New   110.25  New    

      barnesHut  3.778  3.592  5.20%    2+2       0+0   3.648  3.453    5.65%
          boyer  6.632  6.110  8.54%    0+0       0+0   0.258  0.242    6.90%
   count-graphs  1.435  1.325  8.30%    0+0       0+0  33.672 34.737   -3.07%
            fft  0.980  0.940  4.26%    3+9       2+6   0.838  0.827    1.41%
    knuthBendix  3.590  3.138 14.39%    0+0       0+0   0.962  0.967   -0.52%
         lexgen  6.593  6.072  8.59%    1+1       0+0   1.077  1.078   -0.15%
           life  0.972  0.868 11.90%   26+26      0+0   0.143  0.140    2.38%
          logic  2.525  2.387  5.80%    7+7       1+1   5.625  5.158    9.05%
     mandelbrot  0.090  0.093 -3.57%    0+0       0+0   0.855  0.728   17.39%
         mlyacc 26.732 23.827 12.19%  162+189    32+57  0.550  0.560   -1.79%
        nucleic  6.233  6.197  0.59%    3+3       0+0   0.163  0.173   -5.77%
  ratio-regions  3.780  3.507  7.79%    0+0       0+0 133.993 131.035   2.26%
            ray  1.595  1.550  2.90%    1+1       0+0   3.440  3.418    0.63%
         simple  6.972  6.487  7.48%   29+32      5+7   3.523  3.525   -0.05%
            tsp  1.115  1.063  4.86%    0+0       0+0   7.393  7.265    1.77%
           vliw 27.765 24.818 11.87%  110+135    25+45  2.265  2.135    6.09%
  ----------------------------------------------------------------------------
   Average                     6.94%                                    2.64%

      X86          Compilation Time     Spill+Reload      Run Time
                 110.25  New            110.25    New   110.25  New    

      barnesHut  5.530  5.420  2.03%  593+893   597+915   3.532  3.440   2.66%
          boyer  8.768  7.747 13.19%  493+199   301+289   0.327  0.297  10.11%
   count-graphs  2.040  2.010  1.49%  298+394   315+457  26.578 28.660  -7.26%
            fft  1.327  1.302  1.92%  112+209   115+210   1.055  0.962   9.71%
    knuthBendix  5.218  5.475 -4.69%  451+598   510+650   0.928  0.932  -0.36%
         lexgen  9.970  9.623  3.60% 1014+841  1157+885   0.947  0.928   1.97%
           life  1.183  1.183  0.00%  162+182   145+148   0.127  0.103  22.58%
          logic  3.285  3.512 -6.45%  514+684   591+836   5.682  5.577   1.88%
     mandelbrot  0.147  0.143  2.33%   38+41     33+54    0.703  0.690   1.93%
         mlyacc 35.457 32.763  8.22% 3496+4564 3611+4860  0.552  0.550   0.30%
        nucleic  7.100  6.888  3.07%  239+168   201+158   0.175  0.173   0.96%
  ratio-regions  6.388  6.843 -6.65% 1182+257   981+300  120.142 120.345 -0.17%
            ray  2.332  2.338 -0.29%  346+398   402+494   3.593  3.540   1.51%
         simple  9.912  9.903  0.08% 1475+941  1579+1168  3.057  3.178  -3.83%
            tsp  1.623  1.532  5.98%  266+200   250+211   8.045  7.878   2.12%
           vliw 33.947 35.470 -4.29% 2629+2774 2877+3171  2.072  1.890   9.61%
  ----------------------------------------------------------------------------
   Average                     1.22%                                     3.36%

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/03/23 16:25:00
Tag: leunga-20000323-fix_x86_alpha
Description:

1. X86 fixes/changes  

   a.  The old code generated for SETcc was completely wrong.  
       The Intel optimization guide is VERY misleading.

2. ALPHA fixes/changes

   a.  Added the instructions LDBU, LDWU, STB, STW as per Fermin's suggestion.
   b.  Added a new mode byteWordLoadStores to the functor parameter to Alpha()
   c.  Added reassociation code for address computation.

----------------------------------------------------------------------
Name: Allen Leung
Date: 2000/03/22 01:23:00
Tag: leunga-20000322-fix_x86_hppa_ra
Description:

1. X86 fixes/changes  

   a.  x86Rewrite bug with MUL3 (found by Lal)
   b.  Added the instructions FSTS, FSTL

2. PA-RISC fixes/changes

   a.  B label should not be a delay slot candidate!  Why did this work?
   b.  ADDT(32, REG(32, r), LI n) now generates one instruction instead of two,
       as it should be.
   c.  The assembly syntax for fstds and fstdd was wrong.
   d.  Added the composite instruction COMICLR/LDO, which is the immediate
       operand variant of COMCLR/LDO.

3. Generic MLRISC

   a.  shuffle.sml rewritten to be slightly more efficient
   b.  DIV bug in mltree-simplify fixed (found by Fermin)

4. Register Allocator

   a.  I now release the interference graph earlier during spilling.
       May improve memory usage.  

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/03/14 14:15:32
Tag: blume_main_v110p26p1_2
Description:

1. Tools.registerStdShellCmdTool (from smlnj/cm/tool.cm) takes an
additional argument called "template" which is an optional string that
specifies the layout of the tool command line.  See the CM manual for
explanation.

2. A special-purpose tool can be "registered" by simply dropping the
corresponding <...>-tool.cm (and/or <...>-ext.cm) into the same
directory where the .cm file lives that uses this tool.  (The
behavior/misfeature until now was to look for the tool description
files in the current working directory.)  As before, tool description
files could also be anchored -- in which case they can live anywhere
they like.  Following the recent e-mail discussion, this change should
make it easier to have special-purpose tools that are shipped together
with the sources of the program that uses them.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/03/10 07:48:34
Tag: blume_main_v110p26p1_1
Description:

I added a re-written version of Dave's fixpt script to src/system.
Changes relative to the original version:
  - sh-ified (not everybody has ksh)
  - automatically figures out which architecture it runs on
  - uses ./makeml a bit more cleverly
  - never invokes ./installml (and, thus, does not clobber your
    good and working installation of sml in case something goes wrong)
  - accepts max iteration count using option "-iter <n>"
  - accepts a "base" name using option "-base <base>"

It does not build any extraneous heap images but directly rebuilds
bin- and boot-hierarchies using makeml's "-rebuild" switch. Finally,
it can incorporate existing bin- and boot- hierarchies.  For example,
suppose the base is set to "sml" (which is the default).  Then it
successively builds

        sml.bin.<arch>-unix and sml.boot.<arch>-unix
then    sml1.bin.<arch>-unix and sml1.boot.<arch>-unix
then    sml2.bin.<arch>-unix and sml2.boot.<arch>-unix
...
then    sml<n>.bin.<arch>-unix and sml<n>.boot.<arch>-unix

and so on.  If any of these already exist, it will just use what's
there.  In particular, many people will have the initial set of bin
and boot files around, so this saves time for at least one full
rebuild.  Having sets of the form <base><k>.{bin,boot}.<arch>-unix for
<k>=1,2,... is normally not a good idea when invoking fixpt.  However,
they might be the result of an earlier partial run of fixpt (which
perhaps got accidentally killed).  In this case, fixpt will quickly
move through what exists before continuing where it left off earlier,
and, thus, saves a lot of time.

----------------------------------------------------------------------
Name: Allen Leung
Date: 00/03/10 02:20:00
Tag: leunga-20000310-fix_x86_asm_ra
Description:

More assembly output problems involving the indexed addressing mode
on the x86 have been found and corrected. Thanks to Fermin Reig for the
fix.

The interface and implementation of the register allocator have been changed
slightly to accommodate the possibility to skip the register allocation 
phases completely and go directly to memory allocation.  This is needed
for C-- use.

----------------------------------------------------------------------
Name: Matthias Blume
Date: 00/03/09 10:23:53
Tag: blume_main_v110p26p1_0
Description:

* Complete re-organization of library names.  Many libraries have been
consolidated so that they share the same path anchor.  For example,
all MLRISC-related libraries are anchored at MLRISC, most libraries that
are SML/NJ-specific are under "smlnj".  Notice that names like
host-cmb.cm or host-compiler.cm no longer exist.  See system/README
for a complete description of the new naming scheme.  Quick reference:

   host-cmb.cm        -> smlnj/cmb.cm
   host-compiler.cm   -> smlnj/compiler.cm
   full-cm.cm         -> smlnj/cm.cm
   <arch>-<os>.cm     -> smlnj/cmb/<arch>-<os>.cm
   <arch>-compiler.cm -> smlnj/compiler/<arch>.cm

* Bug fixes in CM.
    - exceptions in user code are being passed through (i.e., reach top level)
    - more bugs in paranoia mode fixed
    - bug related to checking group owners fixed

* New install.sh script that automagically fetches archive files:
  The new file config/srcarchiveurl must contain the URL of the
  (remote) directory that contains bin files (or other source archives).
  If install.sh does not find the archive locally, it tries to get
  it from that remote directory.
  This should simplify installation further:  For machines that have
  access to the internet, just fetch <version>-config.tgz, unpack it,
  edit config/targets, and go (run config/install.sh).  The script will
  fetch everything else that it might need all by itself.

  For CVS users, this mechanism is not relevant for source archives, but
  it is convenient for getting new sets of binfiles.

  Archives should be tar files compressed with either gzip, compress, or
  bzip2.  The script recognizes .tgz, .tar, tar.gz, tz, .tar.Z, and .tar.bz2.
  
----------------------------------------------------------------------
Name: Matthias Blume
Date: 2000/03/07 04:01:04
Tag: blume_main_v110_26_2
Description:
- size info in BOOTLIST
     * no fixed upper limits for number of bootfiles or length of
       bootfile names in runtime
     * falling back to old behavior if no BOOTLIST size info found
- allocation size heuristics in .run-sml
     * tries to read cache size from /proc/cpuinfo (this is important for
        small-cache Celeron systems!)
- install.sh robustified
- CM manual updates
- paranoid mode
     * no more CMB.deliver() (i.e., all done by CMB.make())
     * can re-use existing sml.boot.* files
     * init.cmi now treated as library
     * library stamps for consistency checks
- sml.boot.<arch>-<os>/PIDMAP file
     * This file is read by the CM startup code.  This is used to minimize
       the amount of dynamic state that needs to be stowed away for the
       purpose of sharing between interactive system and user code.
- CM.Anchor.anchor instead of CM.Anchor.{set,cancel}
     * Upon request by Elsa.  Anchors now controlled by get-set-pair
       like most other CM state variables.
- Compiler.CMSA eliminated
     * No longer supported by CM anyway.
- fixed bugs in pickler that kept biting Stefan
     * past refs to past refs (was caused by the possibility that
       ad-hoc sharing is more discriminating than hash-cons sharing)
     * integer overflow on LargeInt.minInt
- ml-{lex,yacc} build scripts now use new mechanism
  for building standalone programs
- fixed several gcc -Wall warnings that were caused by missing header
  files, missing initializations, etc., in runtime (not all warnings
  eliminated, though)
