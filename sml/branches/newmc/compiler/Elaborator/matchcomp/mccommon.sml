(* mccommon.sml
 *
 * COPYRIGHT (c) 2018 The Fellowship of SML/NJ (http://www.smlnj.org)
 * All rights reserved.
 *)

(* TODO: this module requires a signature ! *)

structure MCCommon =
struct

local
  structure EM = ErrorMsg
  structure DA = Access
  structure LV = LambdaVar
  structure TU = TypesUtil
  structure V = VarCon

  open Types VarCon PLambda Absyn

  fun bug s = EM.impossible ("MCCommon: " ^ s)

in

(* --------------------------------------------------------------------------- *)
(* ruleno and ruleset types *)

structure RuleSet = IntListSet

type ruleno = RuleSet.item (* = int *)
type ruleset = RuleSet.set


(* --------------------------------------------------------------------------- *)
(* con: case discriminators *)

(* con translates direclty to PLambda.con, except that VLENcon (n,t) is translated
 *  to PLambda.INTcon n (in Generate.genMatch). *)
datatype con
  = DATAcon of datacon * tyvar list
  | INTcon of int IntConst.t
  | WORDcon of int IntConst.t
  | STRINGcon of string
  | VLENcon of int * ty (* translated to INTcon in genMatch *)


(* --------------------------------------------------------------------------- *)
(* andor trees *)

(* nodeId: node id numbers added in the translateAndor 2nd pass of andor tree construction.
 *  These are used as a more efficient node identifier than paths, and useful for forming
 *  maps over nodes (e.g. mvarenv). *)
type nodeId = int

(* varBindings: which variables are bound (at a node) in which rules.
 *  No distinction is made between simple variable bindings and "as" (layered) bindings. *)
type varBindings = (V.var * ruleno) list

datatype 'a subcase  (* kinds of andor0/andor subcases *)
  = CONST            (* discriminant is int, word, string, or constant datacon *)
  | DCON of 'a       (* discriminant is non-constant datacon, 'a is its argument *)
  | VEC of 'a list   (* discrimanant is vector length, 'a list are the vector elements *)


(* "proto" or "basic" AndOr trees, built by the first pass of andor tree construction *)
datatype protoAndor
  = ANDs of
     {bindings : varBindings,
      children : protoAndor list}
  | ORs of
     {bindings : varBindings,
      sign : DA.consig,
      cases : protoVariant list}
  | VARs of
     {bindings : varBindings}
withtype protoVariant = con * ruleset * protoAndor subcase

 
(* The "full" andor tree, with node Ids, paths and binding rulesets and
 *  defaults. These are generated by a 2nd pass tree construction from the basic
 *  form of andor trees (andor0). Not sure that brule ruleset is all that is needed
 *  -- it is basically the varBindings from andor0 with the variables forgotten.
 *  [OR]defaults are computed based on subtracting case rules (directs) from inherited
 *  live rule sets (active), without reference to variable bindings. The (id, path, brules)
 *  values could be collected into a single "info" record field. *)
datatype andor
  = AND of  (* implicit record type, #fields = length children *)
      {id : nodeId,
       children: andor list} (* tuple/record components *)
  | OR of   (* case descrimination *)
      {id: nodeId,
       sign : DA.consig,     (* retained in CASETEST, to be passed eventually to genswitch *)
       defaults: ruleset,    (* "default" rules (how defined? how used?) *)
       cases: variant list}  (* case "variants" *)
  | VAR of  (* variable node, not merged into and ANO or OR node  *)
      {id : nodeId}
withtype variant = con * ruleset * andor subcase


(* --------------------------------------------------------------------------- *)
(* decision tree *)

datatype dectree
  = CHOICE of
      {andor : andor,   (* the andor OR node that is the basis of the CHOICE *)
       sign: DA.consig, (* only needed to determine datatype width, but passed to PL.SWITCH
                         * in Generate..genswitch *)
       cases: (con * dectree) list,  (* CHOICE is saturated if cons are exhaustive *)
       default: dectree option}      (* possible default (if CHOICE is not saturated?) *)
  | RHS of ruleno  (* match succeeds, dispatching to rule ruleno *)
  | FAIL           (* match fails, raise Match/Bind exn, or reraise unmatched exn *)


(* ================================================================================ *)
(* match compiler utility definitions *)

fun mkRECORDpat (RECORDpat{fields, flex=false, typ, ...}) pats =
      RECORDpat {flex = false, typ = typ,
                 fields = ListPair.map (fn((id,_),p)=>(id,p)) (fields, pats)}
  | mkRECORDpat (RECORDpat{flex=true,...}) _ =
      bug "mkRECORDpat - flex record"
  | mkRECORDpat _ _ = bug "mkRECORDpat - non-record"

(* conEq : con * con -> bool *)
fun conEq (DATAcon (d1, _), DATAcon (d2, _)) = TU.eqDatacon (d1, d2)
  | conEq (INTcon n, INTcon n') = (#ival n = #ival n')   (* types assumed compatible *)
  | conEq (WORDcon n, WORDcon n') = (#ival n = #ival n') (* types assumed compatible *)
  | conEq (STRINGcon s, STRINGcon s') = (s = s')
  | conEq (VLENcon (n, _), VLENcon (n', _)) = (n = n')   (* types assumed compatible *)
  | conEq _ = false

(* conToSTring : con -> string *)
fun conToString (DATAcon (dcon,_)) = Symbol.name(TU.dataconName dcon)
  | conToString (VLENcon (n, _)) = "L" ^ (Int.toString n)
  | conToString (INTcon {ival,ty}) = "I" ^ (IntInf.toString ival)
  | conToString (WORDcon {ival,ty}) = "W" ^ (IntInf.toString ival)
  | conToString (STRINGcon s) = "S:"^ s

(* getId : andor -> nodeId *)
fun getId (AND{id, ...}) = id
  | getId (OR{id, ...}) = id
  | getId (VAR{id, ...}) = id

end (* toplevel local *)
end (* structure MCCommon *)
