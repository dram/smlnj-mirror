Example "hand" code generation for to4.sml (1st 4 rules from to55.sml + default rule)

revmc:

use "to4.sml";
[opening to4.sml]
** matchComp: andor
  AND 0  {0-4}
     OR 1 {4} : int {l 0-4} {d 4}
        I0 CONST  {0;4}  {cr 0}
        I1 CONST  {1;4}  {cr 1}
        I2 CONST  {2;4}  {cr 2}
        I3 CONST  {3;4}  {cr 3}
     OR 2 {2,4}  : s list, {0-4}
        :: AND 3 : s * s list, {l 0-4}
         0: AND 4 : s, {0-4}                                   -- hd (1st)
             0: OR 5 {2,4} : v {l 0-4}, {d 2,4}
                   C2 VAR{x0a/0} 6 : unit {0; 2,4}  {cr 0}
                   C4 VAR{x1a/1} 7 : unit {1; 2,4}  {cr 1}
                   C5 VAR{x3/3}  8 : unit {3; 2,4}  {cr 3}
             1: VAR{l11/1} 9 : int,  {0-4}
             2: VAR{r0/0,r1/1,r3/3} 10 : int {0-4}
         1: OR 11 {2,4}  : s list {0-4}                        -- hd.tl (2nd)
              :: AND 12 : s * s list, {0,1,3; 2,4}
               0: AND 13 : s, {0-4}
                   0: OR 14 {0,2,3,4} : v {0-4}
                        C3 VAR{x1b/1} 15 : v  {1; 0,2,3,4}
                   1: VAR{l12/1} 16 {0-4}
                   2: WC     {0-4}
               1: OR 17 {1,2,3,4} : s list {0-4}               -- hd.tl.tl (3rd)
                    :: AND 18 : s * s list {0; 1,2,3,4}} {cr 0,1,3}
                     0: AND 19 : s  {0-4}
                         0: OR 20 {1,2,3,4} : v
                              C3 VAR{x0b/0} 21 {0; 1,2,3,4} {cr 0}
                         1: WC
                         2: WC
                     1: OR 22 {1,2,3,4} : s list, {0; 1,2,3,4}  -- hd.tl.tl.tl (4th)
                          :: AND 23 : s * s list, {0; 1,2,3,4}
                            0: AND 24 : s = v * int * int
                                0: OR 25 {1,2,3,4} : v,
                                     C1 VAR{x0c/0} 26 : v, {0; 1,2,3,4} {cr 0}
                                1: VAR{l0/0} 27
                                2: WC
                            1: VAR{t0/0} 28

Outer switch on <1> eliminates 2 rules in each branch.

(cr = caserules, cl = caselive}

** matchComp: dectree = 
  SWITCH 1 @ <0> {0-4}
     I0 SWITCH 2 @ <1>                   {l 0; 4}   -- 0 because I0 @ <0>, 4 because _, {1,2,3} dead
        :: SWITCH 11 @ <1.tl>            {l 0; 4}
           :: SWITCH 5 @ <1.hd.0>        {l 0; 4}
              C2 SWITCH 17 @ <1.tl.tl>   {l 0; 4}
                 :: SWITCH 20 @ <1.tl.tl.hd.0>   {l 0; 4}
                    C3 SWITCH 22 @ <1.tl.tl.tl>	 {l 0; 4}
                       :: SWITCH 25 @ <1.tl.tl.tl.hd.0>  {l 0; 4}
                          C1 RHS 0  cr {0}     {l 0; 4}
                          * RHS 4
                       * RHS 4
                    * RHS 4
                 * RHS 4
              * RHS 4
           * RHS 4
        * RHS 4
     I1 SWITCH 2 @ <1>              {l 1; 4}
        :: SWITCH 11 @ <1.tl>       {l 1; 4}
           :: SWITCH 5 @ <1.hd.0>   {l 1; 4}
              C4 SWITCH 14 @ <1.tl.hd.0>  {l 1; 4}
                 C3 RHS 1  cr {1}
                 * RHS 4
              * RHS 4
           * RHS 4
        * RHS 4
     I2 RHS 2  {0,1,3,4} not relevant
     I3 SWITCH 2 @ <1>    live = {3,4}
        :: SWITCH 11 @<1.tl>
           :: SWITCH 5 @<1.tl.hd.0> 
              C5 RHS 3   cr = {3},  cl = cr /\ live = {3}
              * RHS 4
           * RHS 4
        * RHS 4
     * RHS 4

** hand translation of the dectree into (pseudo-) plambda code:

sel(n,e) : record selection
ss = switch subject
rt = root mvar, bound to full matching value
hd = ::.0  
tl = ::.1

   swi sel(0,rt)  (#1)                                -- ss = rt.0 : int
     0 => swi sel(1,rt) (#2)                          -- ss = rt.1 : s list
            :: s0 =>                                  -- s0 = rt.1.::  
  	      swi sel(1,s0) (#11)                     -- ss = rt.1.tl : s list
	        :: s1 =>                              -- s1 = rt.1.tl.::
		  swi sel(0, sel(0,s0)) (#5)          -- ss = rt.1.hd.0 : v
		    C2 s2 =>                          -- s2 = rt.t.hd.0.C2 = pvar a
		      swi sel(1, s1) (#17)            -- ss = rt.1.tl.tl : s list
		        :: s3 =>                      -- s3 = rt.1.tl.tl.::
			  swi sel(0, sel(0,s3)) (#20) -- ss = rt.1.tl.tl.hd.0 : v
		           C3 s4 =>                   -- s4 = rt.1.tl.tl.hd.0.C3 = pvar c
			     swi sel(1, s3) (#22)     -- ss = rt.1.tl.tl.tl : s list
			       :: s5 =>	              -- s5 = rt.1.tl.tl.tl.::
			         swi (sel 0 (sel 0, s5)) (#25)  -- ss = rt.1.tl.tl.tl.hd.0 : v
				  C1 s6 => rhs0(...)  -- s6 rt.1.tl.tl.tl.hd.0.C1 = pvar d : unit
				  * => rhs4()  (#25 default)
			       * => rhs4()  (#22)
			   * => rhs4()  (#20)
			* => rhs4()  (#17)
		    * => rhs4()  (#5)
                * => rhs4()  (#11)
            * => rhs4()  (#2) 
     1 => swi sel(1,rt) (#2)                          -- ss = rt.1 : s list
            :: s7 =>                                  -- s7 = rt.1.::  
  	      swi sel(1,s0) (#11)                     -- ss = rt.1.tl : s list
	        :: s8 =>                              -- s8 = rt.1.tl.::
		  swi sel(0, sel(0,s7)) (#5)          -- ss = rt.1.hd.0 : v
		    C4 s9 =>                          -- s9 = rt.1.hd.0.C4 = pvar g
		      swi sel(0, sel(0, s8)) (#14)    -- ss = rt.1.tl.hd.0 : v
                        C3 s10 => rhs1(...)           -- s10 = rt.1.tl.hd.0.C3 = pvar j : unit
                        * => rhs4()  (#14 default)
		    * => rhs4()  (#5)
		* => rhs4()  (#11)
            * => rhs4()  (#2) 
     2 => rhs2(sel(1,rt))
     3 => swi sel(1,rt) (#2)                          -- ss = rt.1 : s list
            :: s11 =>                                 -- s11 = rt.1.::  
  	      swi sel(1,s11) (#11)                    -- ss = rt.1.tl : s list
	        :: s12 =>                             -- s12 = rt.1.tl.::
		  swi sel(0, sel(0,s11)) (#5)         -- ss = rt.1.hd.0 : v
     		    C5 s13 => rhs3(...)               -- s13 = rt.t.hd.0.C2 = pvar n : unit
		    * => rhs4()  (#5 default)
		* => rhs4()  (#11)
            * => rhs4()  (#2) 
     * => rhs4()  (#1)

Notes:
1. switches #2, #11, #5 common to switch #1 branches 0, 1, and 3 (modulo decon mvar renaming)
   but they are not relevant to branch 2

   sel(1,rt) appears in 4 out of 5 banches of the top switch, so could be pulled up and bound
   to an mvar (saving code space in 4 branches, but doing unnecessary work in the default branch).

2. This code would be sufficient if it was predetermined that the rhs expressions did not
   contain occurrences of the pattern variables, in which case the rhs function rhs0, rhs1,
   and rhs3 could take unit as argument and we would not need any (more) mvar bindings for
   the missing pvars (e.g. b,e,f for rhs1).
   Only uses 14 mvars (all dcon mvars)

3. For rhs0, mvar bindings are already available for pvars a (s2), c (s4), and d (s6). Missing
   bindings could be provided by replacing the call rhs0(...) with:

      let m_b = sel(2, sel(0,s0))      -- rt.1.hd.2
        let m_e = sel(1, sel(0,s3))     -- rt.1.tl.tl.hd.1
          let m_f = sel(1,s5)
	    rhs0 (s2, m_b, s4, s6, m_e, m_f)
   (here sel(0,s0) and sel(0,s3) would appear twice, so could be bound to mvars above those
   uses)

   Replace rhs1(...) with:

      let m_h = sel(1, sel(0,s7))
        let m_i = sel(2, sel(0,s7))
          let m_k = sel(1, sel(0,s8))
            let m_l = sel(1, s8)
	      rhs1 (s9, m_h, m_i, s10, m_k, m_l)

   (here sel(0,s7) and sel(0,s8) are used multiple times so could be pulled out and
   bound to mvars)

   Replace rhs3(...) with:

      let m_p = sel(2, sel(0, s11))
        let m_q = sel(1, sel(0, s12))
          let m_r = sel (1, s12)
	    rhs3 (s13, m_p, m_q, m_r)

   (here sel(0,s11) is used twice, so could be pulled out and bound to an mvar)

   These expanded rhs expressions add 10 additional mvars, giving a total of 24.
   oldmc1 uses 47 mvars, revmc uses 73.

   [QUESTION: would the common subexpression optimization be able to lift out common
    subexpressions like sel(0,s0), sel(0,s7), etc.?]


--------------------------------------------------------------------------------
For comparison, here is the code produced by revmc:

** matchComp: code = 
  v28 = FN(v27: TYC({{},PRIM(I63),{},{},PRIM(I63),TCAP(list, [{v,PRIM(I63),PRIM(I63)}])}),
           v20 = v27[0]
             v19 = v27[1]
               v18 = v27[2]
                 v17 = v27[3]
                   v16 = v27[4]
                     v15 = v27[5]
                       (I63)0)
    v30 = FN(v29: TYC({{},PRIM(I63),PRIM(I63),{},PRIM(I63),TCAP(list, [{v,PRIM(I63),PRIM(I63)}])}),
             v14 = v29[0]
               v13 = v29[1]
                 v12 = v29[2]
                   v11 = v29[3]
                     v10 = v29[4]
                       v9 = v29[5]
                         (I63)1)
      v31 = FN(v8: TYC(TCAP(list, [{v,PRIM(I63),PRIM(I63)}])),(I63)2)
        v33 = FN(v32: TYC({{},PRIM(I63),PRIM(I63),TCAP(list, [{v,PRIM(I63),PRIM(I63)}])}),
                 v7 = v32[0]
                   v6 = v32[1]
                     v5 = v32[2]
                       v4 = v32[3]
                         (I63)3)
          v35 = FN(v34: TYC({}),(I63)4)
            v37 = v36[0]
              v38 = v36[1]
                SWIv37
                   of (I63)0 =>
                     SWIv38
                        of ::.v39 =>
                          v40 = v39[0]
                            v41 = v40[0]
                              v42 = v40[2]
                                v43 = v39[1]
                                  SWIv43
                                     of ::.v44 =>
                                       v45 = v44[1]
                                         SWIv41
                                            of C2.v46 =>
                                              SWIv45
                                                 of ::.v47 =>
                                                   v48 = v47[0]
                                                     v49 = v48[0]
                                                       v50 = v47[1]
                                                         SWIv49
                                                            of C3.v51 =>
                                                              SWIv50
                                                                 of ::.v52 =>
                                                                   v53 =
                                                                         v52[0]
                                                                     v54 =
                                                                           v53[0]
                                                                       v55 =
                                                                             v53[1]
                                                                         v56 =
                                                                               v52[1]
                                                                           SWIv54
                                                                              of C1.v57 =>
                                                                                APP(v28,
                                                                                RCD(v46,v42,v51,v57,v55,v56))
                                                                              _ =>
                                                                                APP(v35,
                                                                                RCD())
                                                                 _ =>
                                                                   APP(v35,
                                                                   RCD())
                                                            _ =>
                                                              APP(v35, RCD())
                                                 _ => APP(v35, RCD())
                                            _ => APP(v35, RCD())
                                     _ => APP(v35, RCD())
                        _ => APP(v35, RCD())
                   (I63)1 =>
                     SWIv38
                        of ::.v72 =>
                          v73 = v72[0]
                            v74 = v73[0]
                              v75 = v73[1]
                                v76 = v73[2]
                                  v77 = v72[1]
                                    SWIv77
                                       of ::.v78 =>
                                         v79 = v78[0]
                                           v80 = v79[0]
                                             v81 = v79[1]
                                               v82 = v78[1]
                                                 SWIv74
                                                    of C4.v83 =>
                                                      SWIv80
                                                         of C3.v84 =>
                                                           APP(v30,
                                                           RCD(v83,v75,v76,v84,v81,v82))
                                                         _ => APP(v35, RCD())
                                                    _ => APP(v35, RCD())
                                       _ => APP(v35, RCD())
                        _ => APP(v35, RCD())
                   (I63)2 => APP(v31, v38)
                   (I63)3 =>
                     SWIv38
                        of ::.v93 =>
                          v94 = v93[0]
                            v95 = v94[0]
                              v96 = v94[2]
                                v97 = v93[1]
                                  SWIv97
                                     of ::.v98 =>
                                       v99 = v98[0]
                                         v100 = v99[1]
                                           v101 = v98[1]
                                             SWIv95
                                                of C5.v102 =>
                                                  APP(v33,
                                                  RCD(v102,v96,v100,v101))
                                                _ => APP(v35, RCD())
                                     _ => APP(v35, RCD())
                        _ => APP(v35, RCD())
                   _ => APP(v35, RCD())
  
