- use "t5m.sml";
transVB:pat = ittransVB:exp = use "t5m.sml"
[opening t5m.sml]
>> matchComp
<< makeAndor
andor:
<> AND 2 {0} {}
   <0> VARS 0 (state,0) {0}
   <1> VARS 1 (stack,0) {0}
>> decisionTree: andor ID = 2, numRules = 1
** decisionTree: intialOrNodes = []
>> makeDecisionTree: survivors = [0]; orNodes = []
<< incrementRuleCount: 0 to 1
<< makeDecisionTree: NO relevant
<< decisionTree: ruleCounts = [1]
<< decisionTree
dectree:
DLEAF 0
>> genMatch
** genMatch: ruleCounts: [1], length rules: 1
multirules = []
>> genNode:AND: 2, 0
>> bindPatVars: |vars| = 0, |asvars| = 0
>> genNode:VARS: 1, 1
>> bindPatVars: |vars| = 1, |asvars| = 0
VarEnvMC.bindVar: stack[lv2], 0 --> <1>[lv12]
>> genNode:VARS: 0, 1
>> bindPatVars: |vars| = 1, |asvars| = 0
VarEnvMC.bindVar: state[lv3], 0 --> <0>[lv13]
>> bindSVars
>> lookVar: stack[lv2] @ 0 --> <1>[lv12]
>> lookVar: state[lv3] @ 0 --> <0>[lv13]
bindSvars: venv = stack[lv2]-><1>[lv12], state[lv3]-><0>[lv13]
<< bindSvar
>> transExp: CASEexp
>> matchComp
>> addBind: id = 26; |bind| = 1
<< makeAndor
andor:
<> AND 26 {0} {1}
   <0> OR 0 {0} {1}
      I0 LEAF {0} {1}
   <1> OR 1 {0} {1}
      ::
      <1.::> AND 25 {0} {1}
         <1.::.0> AND 6 {0} {1}
            <1.::.0.0> OR 2 {0} {1}
               C1 <1.::.0.0.C1> VARS 3 (x0a,0) {0,1}
            <1.::.0.1> VARS 4 (%WILD%,0) {0,1}
            <1.::.0.2> VARS 5 (right,0) {0,1}
         <1.::.1> OR 7 {0} {1}
            ::
            <1.::.1.::> AND 24 {0} {1}
               <1.::.1.::.0> VARS 8 (%WILD%,0) {0,1}
               <1.::.1.::.1> OR 9 {0} {1}
                  ::
                  <1.::.1.::.1.::> AND 23 {0} {1}
                     <1.::.1.::.1.::.0> AND 14 {0} {1}
                        <1.::.1.::.1.::.0.0> OR 10 {0} {1}
                           C2 <1.::.1.::.1.::.0.0.C2> VARS 11 (x0b,0) {0,1}
                        <1.::.1.::.1.::.0.1> VARS 12 (%WILD%,0) {0,1}
                        <1.::.1.::.1.::.0.2> VARS 13 (%WILD%,0) {0,1}
                     <1.::.1.::.1.::.1> OR 15 {0} {1}
                        ::
                        <1.::.1.::.1.::.1.::> AND 22 {0} {1}
                           <1.::.1.::.1.::.1.::.0> AND 20 {0} {1}
                              <1.::.1.::.1.::.1.::.0.0> OR 16 {0} {1}
                                 C3
                                 <1.::.1.::.1.::.1.::.0.0.C3> VARS 17 (x0c,0) {0,1}
                              <1.::.1.::.1.::.1.::.0.1> VARS 18 (left,0) {0,1}
                              <1.::.1.::.1.::.1.::.0.2> VARS 19 (%WILD%,0) {0,1}
                           <1.::.1.::.1.::.1.::.1> VARS 21 (rest,0) {0,1}
>> decisionTree: andor ID = 26, numRules = 2
** decisionTree: intialOrNodes = [0,1]
>> makeDecisionTree: survivors = [0,1]; orNodes = [0,1]
** makeDecisionTree[SOME(OR)]: best relevant = 0
** andorToDecTree: id = ~1
  path = <0.I0>
  live = [0,1]
  variantSurvivors = [0,1]
  variantCandidates = [1]
>> makeDecisionTree: survivors = [0,1]; orNodes = [1]
** makeDecisionTree[SOME(OR)]: best relevant = 1
** andorToDecTree: id = 25
  path = <1.::>
  live = [0,1]
  variantSurvivors = [0,1]
  variantCandidates = [2,7]
>> makeDecisionTree: survivors = [0,1]; orNodes = [2,7]
** makeDecisionTree[SOME(OR)]: best relevant = 2
** andorToDecTree: id = 3
  path = <1.::.0.0.C1>
  live = [0,1]
  variantSurvivors = [0,1]
  variantCandidates = [7]
>> makeDecisionTree: survivors = [0,1]; orNodes = [7]
** makeDecisionTree[SOME(OR)]: best relevant = 7
** andorToDecTree: id = 24
  path = <1.::.1.::>
  live = [0,1]
  variantSurvivors = [0,1]
  variantCandidates = [9]
>> makeDecisionTree: survivors = [0,1]; orNodes = [9]
** makeDecisionTree[SOME(OR)]: best relevant = 9
** andorToDecTree: id = 23
  path = <1.::.1.::.1.::>
  live = [0,1]
  variantSurvivors = [0,1]
  variantCandidates = [10,15]
>> makeDecisionTree: survivors = [0,1]; orNodes = [10,15]
** makeDecisionTree[SOME(OR)]: best relevant = 10
** andorToDecTree: id = 11
  path = <1.::.1.::.1.::.0.0.C2>
  live = [0,1]
  variantSurvivors = [0,1]
  variantCandidates = [15]
>> makeDecisionTree: survivors = [0,1]; orNodes = [15]
** makeDecisionTree[SOME(OR)]: best relevant = 15
** andorToDecTree: id = 22
  path = <1.::.1.::.1.::.1.::>
  live = [0,1]
  variantSurvivors = [0,1]
  variantCandidates = [16]
>> makeDecisionTree: survivors = [0,1]; orNodes = [16]
** makeDecisionTree[SOME(OR)]: best relevant = 16
** andorToDecTree: id = 17
  path = <1.::.1.::.1.::.1.::.0.0.C3>
  live = [0,1]
  variantSurvivors = [0,1]
  variantCandidates = []
>> makeDecisionTree: survivors = [0,1]; orNodes = []
<< incrementRuleCount: 0 to 1
<< makeDecisionTree: NO relevant
defaultOp: id = 16, defaultSurvivors = [1]
>> makeDecisionTree: survivors = [1]; orNodes = []
<< incrementRuleCount: 1 to 1
<< makeDecisionTree: NO relevant
<< makeDecisionTree: 16 relevant
defaultOp: id = 15, defaultSurvivors = [1]
>> makeDecisionTree: survivors = [1]; orNodes = []
<< incrementRuleCount: 1 to 2
<< makeDecisionTree: NO relevant
<< makeDecisionTree: 15 relevant
defaultOp: id = 10, defaultSurvivors = [1]
>> makeDecisionTree: survivors = [1]; orNodes = [15]
<< incrementRuleCount: 1 to 3
<< makeDecisionTree: NO relevant
<< makeDecisionTree: 10 relevant
defaultOp: id = 9, defaultSurvivors = [1]
>> makeDecisionTree: survivors = [1]; orNodes = []
<< incrementRuleCount: 1 to 4
<< makeDecisionTree: NO relevant
<< makeDecisionTree: 9 relevant
defaultOp: id = 7, defaultSurvivors = [1]
>> makeDecisionTree: survivors = [1]; orNodes = []
<< incrementRuleCount: 1 to 5
<< makeDecisionTree: NO relevant
<< makeDecisionTree: 7 relevant
defaultOp: id = 2, defaultSurvivors = [1]
>> makeDecisionTree: survivors = [1]; orNodes = [7]
<< incrementRuleCount: 1 to 6
<< makeDecisionTree: NO relevant
<< makeDecisionTree: 2 relevant
defaultOp: id = 1, defaultSurvivors = [1]
>> makeDecisionTree: survivors = [1]; orNodes = []
<< incrementRuleCount: 1 to 7
<< makeDecisionTree: NO relevant
<< makeDecisionTree: 1 relevant
defaultOp: id = 0, defaultSurvivors = [1]
>> makeDecisionTree: survivors = [1]; orNodes = [1]
<< incrementRuleCount: 1 to 8
<< makeDecisionTree: NO relevant
<< makeDecisionTree: 0 relevant
<< decisionTree: ruleCounts = [1,8]
<< decisionTree
dectree:
CHOICE <0>
  I0
  CHOICE <1>
    ::
    CHOICE <1.::.0.0>
      C1
      CHOICE <1.::.1>
        ::
        CHOICE <1.::.1.::.1>
          ::
          CHOICE <1.::.1.::.1.::.0.0>
            C2
            CHOICE <1.::.1.::.1.::.1>
              :: CHOICE <1.::.1.::.1.::.1.::.0.0>
                C3 DLEAF 0
                * DLEAF 1
              * DLEAF 1
            * DLEAF 1
          * DLEAF 1
        * DLEAF 1
      * DLEAF 1
    * DLEAF 1
  * DLEAF 1
>> genMatch
** genMatch: ruleCounts: [1,8], length rules: 2
multirules = [1]
>> genNode:AND: 26, 1
>> bindPatVars: |vars| = 1, |asvars| = 0
>> genNode:OR: 1, 0
>> bindPatVars: |vars| = 0, |asvars| = 0
>> genNode:OR: 0, 0
>> bindPatVars: |vars| = 0, |asvars| = 0
>> genNode:AND: 25, 0
>> bindPatVars: |vars| = 0, |asvars| = 0
>> genNode:OR: 7, 0
>> bindPatVars: |vars| = 0, |asvars| = 0
>> genNode:AND: 6, 0
>> bindPatVars: |vars| = 0, |asvars| = 0
>> genNode:VARS: 5, 1
>> bindPatVars: |vars| = 1, |asvars| = 0
VarEnvMC.bindVar: right[lv8], 0 --> <1.::.0.2>[lv22]
>> genNode:VARS: 4, 1
>> bindPatVars: |vars| = 1, |asvars| = 0
>> genNode:OR: 2, 0
>> bindPatVars: |vars| = 0, |asvars| = 0
>> genNode:VARS: 3, 1
>> bindPatVars: |vars| = 1, |asvars| = 0
VarEnvMC.bindVar: x0a[lv9], 0 --> <1.::.0.0.C1>[lv25]
>> genNode:AND: 24, 0
>> bindPatVars: |vars| = 0, |asvars| = 0
>> genNode:OR: 9, 0
>> bindPatVars: |vars| = 0, |asvars| = 0
>> genNode:VARS: 8, 1
>> bindPatVars: |vars| = 1, |asvars| = 0
>> genNode:AND: 23, 0
>> bindPatVars: |vars| = 0, |asvars| = 0
>> genNode:OR: 15, 0
>> bindPatVars: |vars| = 0, |asvars| = 0
>> genNode:AND: 14, 0
>> bindPatVars: |vars| = 0, |asvars| = 0
>> genNode:VARS: 13, 1
>> bindPatVars: |vars| = 1, |asvars| = 0
>> genNode:VARS: 12, 1
>> bindPatVars: |vars| = 1, |asvars| = 0
>> genNode:OR: 10, 0
>> bindPatVars: |vars| = 0, |asvars| = 0
>> genNode:VARS: 11, 1
>> bindPatVars: |vars| = 1, |asvars| = 0
VarEnvMC.bindVar: x0b[lv7], 0 --> <1.::.1.::.1.::.0.0.C2>[lv35]
>> genNode:AND: 22, 0
>> bindPatVars: |vars| = 0, |asvars| = 0
>> genNode:VARS: 21, 1
>> bindPatVars: |vars| = 1, |asvars| = 0
VarEnvMC.bindVar: rest[lv4], 0 --> <1.::.1.::.1.::.1.::.1>[lv37]
>> genNode:AND: 20, 0
>> bindPatVars: |vars| = 0, |asvars| = 0
>> genNode:VARS: 19, 1
>> bindPatVars: |vars| = 1, |asvars| = 0
>> genNode:VARS: 18, 1
>> bindPatVars: |vars| = 1, |asvars| = 0
VarEnvMC.bindVar: left[lv5], 0 --> <1.::.1.::.1.::.1.::.0.1>[lv40]
>> genNode:OR: 16, 0
>> bindPatVars: |vars| = 0, |asvars| = 0
>> genNode:VARS: 17, 1
>> bindPatVars: |vars| = 1, |asvars| = 0
VarEnvMC.bindVar: x0c[lv6], 0 --> <1.::.1.::.1.::.1.::.0.0.C3>[lv42]
>> bindSVars
>> lookVar: rest[lv4] @ 0 --> <1.::.1.::.1.::.1.::.1>[lv37]
>> lookVar: left[lv5] @ 0 --> <1.::.1.::.1.::.1.::.0.1>[lv40]
>> lookVar: x0c[lv6] @ 0 --> <1.::.1.::.1.::.1.::.0.0.C3>[lv42]
>> lookVar: x0b[lv7] @ 0 --> <1.::.1.::.1.::.0.0.C2>[lv35]
>> lookVar: right[lv8] @ 0 --> <1.::.0.2>[lv22]
>> lookVar: x0a[lv9] @ 0 --> <1.::.0.0.C1>[lv25]
bindSvars: venv = rest[lv4]-><1.::.1.::.1.::.1.::.1>[lv37], left[lv5]-><1.::.1.::.1.::.1.::.0.1>[lv40], x0c[lv6]-><1.::.1.::.1.::.1.::.0.0.C3>[lv42], x0b[lv7]-><1.::.1.::.1.::.0.0.C2>[lv35], right[lv8]-><1.::.0.2>[lv22], x0a[lv9]-><1.::.0.0.C1>[lv25]
<< bindSvar
>> bindSVars
bindSvars: venv = 
<< bindSvar
>> bindSVars
bindSvars: venv = 
<< bindSvar
>> bindSVars
bindSvars: venv = 
<< bindSvar
>> bindSVars
bindSvars: venv = 
<< bindSvar
>> bindSVars
bindSvars: venv = 
<< bindSvar
>> bindSVars
bindSvars: venv = 
<< bindSvar
>> bindSVars
bindSvars: venv = 
<< bindSvar
>> bindSVars
bindSvars: venv = 
<< bindSvar
<< genMatch
<< matchComp
<< genMatch
<< matchComp
structure T5m :
  sig
  datatype svalue = C1 of unit | C2 of unit | C3 of unit
  type spp = svalue * int * int
  type stack = spp list
  val actions : int * stack -> int
end
