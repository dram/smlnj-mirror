Types:

ModuleId:  (ElabData/modules/moduleid.sml)
static identifiers (collectively called statIds)
Used for statenv pickle isolation

tycId
  stamp
sigId
  stamp
strId
  { sign: stamp, rlzn: stamp }
fctId
  { paramsig: stamp, bodysig: stamp, rlzn: stamp }
envId
  stamp

tmap -- maps from identifiers to static representations of corresponding entity
  { m_tyc: T.gtrec StampM.map,
    m_sig: M.sigrec StampM.map,
    m_str: M.strEntity StrM.map,
    m_fct: M.fctEntity FctM.map, 
    m_env: M.envrec StampM.map }
'a umap -- generic maps from static identifiers


EntPath (ElabData/modules/entpath.sml)
    entVar   -- entity variable 
      == stamp
    entPath  -- entity path
      == entVar list  ==  stamp list
    rEntPath -- reverse entity path
      == entVar list (reverse order)

EntPathContext: (ElabData/modules/epcontext.sml)
    pathmap -- mapping from statIds to reverse entpaths
      EP.rEntPath MI.umap
    epContext -- "environment" for mapping statIds to relative entity paths
	datatype context
	  = EMPTY
	  | LAYER of {locals: pathmap ref, 
		      lookContext: EP.entPath,
		      bindContext: EP.rEntPath,
		      outer: context}

epContexts maintain a mapping from statIds to reverse entity paths.
It maintains a local pathmap for each closed structure scope (where closed
means a functor body whose entities won't be referenced from outside the scope).
It also maintains an entity path (lookContext) telling the entity path to the
current structure node, and a memoized reverse version of that path in bindContext.

To relativize an entity path to the current structure scope, we remove the longest
common prefix of that path and the current lookContext path.

Question: When is NONE passed to enterOpen? (entsv param of elabStr)
  1. when elaborating the body of a functor with no result signature contraint


ElabStr

Q: How could we have a ConstrainedStr(strexp,constraint) where constraint is NoSig?
A: This should not happen.  ConstrainedStr is constructed in the parser only when
there is a constraint signature.

Q: When is the entVarOp argument of elabStr a SOME ev?
A: List of elabStr calls:

   1. AppStrI(spath,[(arg,b)]) case in elabStr
      elabStr called with (SOME entv) where entv is a fresh entvar.
      the binding entv |-> argEnt is added to argDee to make resDee  ???

   2. ?

============================================================================
Notes from code.
============================================================================
[extractSig.1] Here is an example where the entity path of a tycon element
is a nonsingular path:

functor F(X: sig type t end) =
struct
  open X
end

In this case, the value of epOp will be SOME[ev_X, ev_t].  Longer entity paths
could result from nested structures in the parameter, e.g.

functor F(X: sig structure A : sig type t end end) =
struct
  open X.A
end

would give epOp = SOME[ev_X, ev_A, ev_t].