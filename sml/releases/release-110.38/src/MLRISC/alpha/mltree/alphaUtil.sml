(*
 * This file was automatically generated by MDGen
 * from the machine description file "alpha/alpha.md".
 *)


   val lookupOpn = I.OT.lookupOpn operandTable
   val lookupInt = I.OT.lookupInt operandTable
   val dummy = MLExp.NOP
   val DEFFREG = (fn FP => let
                     in I.OP {i=I.DEFFREG FP, s=[], t=[], e=dummy}
                     end

                 )
   val LDA = (fn {r, b, d} => let
                 in I.OP {i=I.LDA {r=r, b=b, d=d}, s=[], t=[], e=dummy}
                 end

             )
   val LDAH = (fn {r, b, d} => let
                  in I.OP {i=I.LDAH {r=r, b=b, d=d}, s=[], t=[], e=dummy}
                  end

              )
   val LOAD = (fn {ldOp, r, b, d, mem} => let
                  in I.OP {i=I.LOAD {ldOp=ldOp, r=r, b=b, d=d, mem=mem}, s=[], t=[], e=dummy}
                  end

              )
   val STORE = (fn {stOp, r, b, d, mem} => let
                   in I.OP {i=I.STORE {stOp=stOp, r=r, b=b, d=d, mem=mem}, s=[], t=[], e=dummy}
                   end

               )
   val FLOAD = (fn {ldOp, r, b, d, mem} => let
                   in I.OP {i=I.FLOAD {ldOp=ldOp, r=r, b=b, d=d, mem=mem}, s=[], t=[], e=dummy}
                   end

               )
   val FSTORE = (fn {stOp, r, b, d, mem} => let
                    in I.OP {i=I.FSTORE {stOp=stOp, r=r, b=b, d=d, mem=mem}, s=[], t=[], e=dummy}
                    end

                )
   val JMPL = (fn ({r, b, d}, label) => let
                  in I.OP {i=I.JMPL ({r=r, b=b, d=d}, label), s=[], t=[], e=dummy}
                  end

              )
   val JSR = (fn ({r, b, d}, cellset1, cellset2, region) => let
                 in I.OP {i=I.JSR ({r=r, b=b, d=d}, cellset1, cellset2, region), s=[], t=[], e=dummy}
                 end

             )
   val RET = (fn {r, b, d} => let
                 in I.OP {i=I.RET {r=r, b=b, d=d}, s=[], t=[], e=dummy}
                 end

             )
   val BRANCH = (fn (branch, GP, label) => let
                    in I.OP {i=I.BRANCH (branch, GP, label), s=[], t=[], e=dummy}
                    end

                )
   val FBRANCH = (fn (fbranch, FP, label) => let
                     in I.OP {i=I.FBRANCH (fbranch, FP, label), s=[], t=[], e=dummy}
                     end

                 )
   val OPERATE = (fn {oper, ra, rb, rc} => let
                     in I.OP {i=I.OPERATE {oper=oper, ra=ra, rb=rb, rc=rc}, s=[], t=[], e=dummy}
                     end

                 )
   val OPERATEV = (fn {oper, ra, rb, rc} => let
                      in I.OP {i=I.OPERATEV {oper=oper, ra=ra, rb=rb, rc=rc}, s=[], t=[], e=dummy}
                      end

                  )
   val PSEUDOARITH = (fn {oper, ra, rb, rc, tmps} => let
                         in I.OP {i=I.PSEUDOARITH {oper=oper, ra=ra, rb=rb, rc=rc, tmps=tmps}, s=[], t=[], e=dummy}
                         end

                     )
   val COPY = (fn {dst, src, impl, tmp} => let
                  in I.OP {i=I.COPY {dst=dst, src=src, impl=impl, tmp=tmp}, s=[], t=[], e=dummy}
                  end

              )
   val FCOPY = (fn {dst, src, impl, tmp} => let
                   in I.OP {i=I.FCOPY {dst=dst, src=src, impl=impl, tmp=tmp}, s=[], t=[], e=dummy}
                   end

               )
   val FOPERATE = (fn {oper, fa, fb, fc} => let
                      in I.OP {i=I.FOPERATE {oper=oper, fa=fa, fb=fb, fc=fc}, s=[], t=[], e=dummy}
                      end

                  )
   val FOPERATEV = (fn {oper, fa, fb, fc} => let
                       in I.OP {i=I.FOPERATEV {oper=oper, fa=fa, fb=fb, fc=fc}, s=[], t=[], e=dummy}
                       end

                   )
   val TRAPB = ()
   val CALL_PAL = (fn {code, def, use} => let
                      in I.OP {i=I.CALL_PAL {code=code, def=def, use=use}, s=[], t=[], e=dummy}
                      end

                  )
