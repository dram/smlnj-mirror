(*
 * Interface of rtl info extraction from instructions.
 * The code matching this interface automatically is generated by the MDL tool.
 *)
signature RTL_PROPERTIES =
sig

   structure I   : INSTRUCTIONS
   structure C   : CELLS
   structure RTL : MLTREE_RTL
   structure OT  : OPERAND_TABLE
      sharing I.C            = C
      sharing OT.I           = I
      sharing RTL.T.Region   = I.Region
      sharing RTL.T.LabelExp = I.LabelExp

   datatype opnkind = 
     IMM  (* immed value *)
   | REG  (* normal register *)
   | FIX  (* fixed register *)
   | MEM  (* memory *)
   | CTRL (* control dependence *)

   (* Return the RTL describing the semantics of an instruction 
    * The rtl returned is in lambda-lifted form, i.e. it contains
    * references to PARAM n, which refers to the nth input or output parameter.
    *)
   val rtl : I.instruction -> RTL.rtl  

   (*
    *  Return the input/ouput parameters of an instruction. 
    *  The input/output matches positionally with the info returned by
    *  the function rtl.
    *) 
   val defUse : OT.valueNumber -> I.instruction -> C.cell list * C.cell list

   (* 
    * Return the def/use of an instruction with cellkind information 
    * This function works the same way as the above.  But with cellkind
    * information attached.
    *) 
   val defUseWithCellKind : OT.valueNumber -> I.instruction -> 
                (C.cell * C.cellkind) list * (C.cell * C.cellkind) list 


   (* 
    * Return the operand kinds of an instruction.   
    *)
   val opnKind : I.instruction -> opnkind list * opnkind list (* dst/src *)

   (* 
    * Initialize the cellkinds of variables 
    *)
   val updateCellKind : {update:C.cell * C.cellkind -> unit} -> 
                        I.instruction -> unit

end
