(*
 * This file was automatically generated by MDGen (v2.0)
 * from the machine description file "x86/x86.md".
 *)


functor X86MCEmitter(structure Instr : X86INSTR
                     structure Stream : INSTRUCTION_STREAM
                     structure CodeString : CODE_STRING
                    ) : INSTRUCTION_EMITTER =
struct
   structure I = Instr
   structure S = Stream
   structure C = I.C
   structure Constant = I.Constant
   structure LabelExp = I.LabelExp
   structure P = S.P
   structure W = Word32
   
   (* X86 is little endian *)
   
   fun error msg = MLRiscErrorMsg.error("X86MC",msg)
   fun makeStream _ =
   let infix && || << >> ~>>
       val op << = W.<<
       val op >> = W.>>
       val op ~>> = W.~>>
       val op || = W.orb
       val op && = W.andb
       val itow = W.fromInt
       fun emit_bool false = 0w0 : W.word
         | emit_bool true = 0w1 : W.word
       val emit_int = itow
       fun emit_word w = w
       fun emit_label l = itow(Label.addrOf l)
       fun emit_labexp le = itow(LabelExp.valueOf le)
       fun emit_const c = itow(Constant.valueOf c)
       val loc = ref 0
   
       (* emit a byte *)
       fun eByte b =
       let val i = !loc in loc := i + 1; CodeString.update(i,b) end
   
       (* emit the low order byte of a word *)
       (* note: fromLargeWord strips the high order bits! *)
       fun eByteW w =
       let val i = !loc
       in loc := i + 1; CodeString.update(i,Word8.fromLargeWord w) end
   
       fun doNothing _ = ()
   
       fun pseudoOp pOp = P.emitValue{pOp=pOp, loc= !loc,emit=eByte}
   
       fun init n = (CodeString.init n; loc := 0)
   
   
       fun emitter regmap =
       let
   fun eWord8 w = let
          val b8 = w
       in eByteW b8
       end

   and eWord32 w = let
          val b8 = w
          val w = w >> 0wx8
          val b16 = w
          val w = w >> 0wx8
          val b24 = w
          val w = w >> 0wx8
          val b32 = w
       in 
          ( eByteW b8; 
          eByteW b16; 
          eByteW b24; 
          eByteW b32 )
       end

   fun emit_GP r = itow (regmap r)
   and emit_FP r = itow ((regmap r) - 32)
   and emit_CC r = itow ((regmap r) - 64)
   and emit_MEM r = itow ((regmap r) - 64)
   and emit_CTRL r = itow ((regmap r) - 64)
   fun modrm {mod, reg, rm} = eWord8 ((op mod << 0wx6) + ((reg << 0wx3) + rm))
   and sib {ss, index, base} = eWord8 ((ss << 0wx6) + ((index << 0wx3) + base))
   and immed8 {imm} = eWord8 imm
   and immed32 {imm} = eWord32 imm
   fun emitInstr (I.NOP) = error "NOP"
     | emitInstr (I.JMP(operand, label)) = error "JMP"
     | emitInstr (I.JCC{cond, opnd}) = error "JCC"
     | emitInstr (I.CALL(operand, cellset1, cellset2, region)) = error "CALL"
     | emitInstr (I.ENTER{src1, src2}) = error "ENTER"
     | emitInstr (I.LEAVE) = error "LEAVE"
     | emitInstr (I.RET operand) = error "RET"
     | emitInstr (I.MOVE{mvOp, src, dst}) = error "MOVE"
     | emitInstr (I.LEA{r32, addr}) = error "LEA"
     | emitInstr (I.CMPL{lsrc, rsrc}) = error "CMPL"
     | emitInstr (I.CMPW{lsrc, rsrc}) = error "CMPW"
     | emitInstr (I.CMPB{lsrc, rsrc}) = error "CMPB"
     | emitInstr (I.TESTL{lsrc, rsrc}) = error "TESTL"
     | emitInstr (I.TESTW{lsrc, rsrc}) = error "TESTW"
     | emitInstr (I.TESTB{lsrc, rsrc}) = error "TESTB"
     | emitInstr (I.BITOP{bitOp, lsrc, rsrc}) = error "BITOP"
     | emitInstr (I.BINARY{binOp, src, dst}) = error "BINARY"
     | emitInstr (I.MULTDIV{multDivOp, src}) = error "MULTDIV"
     | emitInstr (I.MUL3{dst, src2, src1}) = error "MUL3"
     | emitInstr (I.UNARY{unOp, opnd}) = error "UNARY"
     | emitInstr (I.SET{cond, opnd}) = error "SET"
     | emitInstr (I.CMOV{cond, src, dst}) = error "CMOV"
     | emitInstr (I.PUSHL operand) = error "PUSHL"
     | emitInstr (I.PUSHW operand) = error "PUSHW"
     | emitInstr (I.PUSHB operand) = error "PUSHB"
     | emitInstr (I.POP operand) = error "POP"
     | emitInstr (I.CDQ) = error "CDQ"
     | emitInstr (I.INTO) = error "INTO"
     | emitInstr (I.COPY{dst, src, tmp}) = error "COPY"
     | emitInstr (I.FCOPY{dst, src, tmp}) = error "FCOPY"
     | emitInstr (I.FBINARY{binOp, src, dst}) = error "FBINARY"
     | emitInstr (I.FIBINARY{binOp, src}) = error "FIBINARY"
     | emitInstr (I.FUNARY funOp) = error "FUNARY"
     | emitInstr (I.FUCOMPP) = error "FUCOMPP"
     | emitInstr (I.FCOMPP) = error "FCOMPP"
     | emitInstr (I.FXCH{opnd}) = error "FXCH"
     | emitInstr (I.FSTPL operand) = error "FSTPL"
     | emitInstr (I.FSTPS operand) = error "FSTPS"
     | emitInstr (I.FSTPT operand) = error "FSTPT"
     | emitInstr (I.FSTL operand) = error "FSTL"
     | emitInstr (I.FSTS operand) = error "FSTS"
     | emitInstr (I.FLD1) = error "FLD1"
     | emitInstr (I.FLDL2E) = error "FLDL2E"
     | emitInstr (I.FLDL2T) = error "FLDL2T"
     | emitInstr (I.FLDLG2) = error "FLDLG2"
     | emitInstr (I.FLDLN2) = error "FLDLN2"
     | emitInstr (I.FLDPI) = error "FLDPI"
     | emitInstr (I.FLDZ) = error "FLDZ"
     | emitInstr (I.FLDL operand) = error "FLDL"
     | emitInstr (I.FLDS operand) = error "FLDS"
     | emitInstr (I.FLDT operand) = error "FLDT"
     | emitInstr (I.FILD operand) = error "FILD"
     | emitInstr (I.FILDL operand) = error "FILDL"
     | emitInstr (I.FILDLL operand) = error "FILDLL"
     | emitInstr (I.FNSTSW) = error "FNSTSW"
     | emitInstr (I.FENV{fenvOp, opnd}) = error "FENV"
     | emitInstr (I.SAHF) = error "SAHF"
     | emitInstr (I.ANNOTATION{i, a}) = error "ANNOTATION"
     | emitInstr (I.SOURCE{}) = ()
     | emitInstr (I.SINK{}) = ()
     | emitInstr (I.PHI{}) = ()
       in
           emitInstr
       end
   
   in  S.STREAM{beginCluster=init,
                pseudoOp=pseudoOp,
                emit=emitter,
                endCluster=doNothing,
                defineLabel=doNothing,
                entryLabel=doNothing,
                comment=doNothing,
                exitBlock=doNothing,
                annotation=doNothing,
                phi=doNothing,
                alias=doNothing
               }
   end
end

