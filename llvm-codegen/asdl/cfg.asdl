-- cps.asdl
--
-- COPYRIGHT (c) 2020 The Fellowship of SML/NJ (http://www.smlnj.org)
-- All rights reserved.
--
-- ASDL description of the CFG IR.
--

-- primitive module for pickling lvars
--
primitive module LambdaVar {
    type lvar
}

-- should agree with PrimCTypes
--
module CTypes {

    c_type
      = C_void
      | C_float
      | C_double
      | C_long_double
      | C_unsigned (c_int)
      | C_signed (c_int)
      | C_PTR
      | C_ARRAY (c_type, int)
      | C_STRUCT (c_type*)
      | C_UNION (c_type*)

    c_int
      = I_char
      | I_short
      | I_int
      | I_long
      | I_long_long

    calling_convention = string

    c_proto = (calling_convention conv, c_type retTy, c_type* paramTys)

}

-- CFG primitive operations
--
module CFG_Prim {

    numkind = INT | FLT

  -- rounding modes for float conversions *)
    rounding_mode = TO_NEAREST | TO_NEGINF | TO_POSINF | TO_ZERO

  -- These operations bump the allocation pointer
    alloc
    -- allocates an initialized record object with the given descriptor.
    -- The `mut` field is true for mutable objects
      = RECORD(integer desc, bool mut)
    -- allocates an initialized record of raw data with the given descriptor.
    -- The `sz` field specifies the size of the values (in bits).
      | RAW_RECORD(integer desc, numkind kind, int sz)
    -- Allocates an uninitialized record.  The descriptor is optional (it will
    -- be NONE for spill records).  The `align` field specifies the alignment
    -- in bytes and the `len` field is the size in bytes.
      | RAW_ALLOC(integer? desc, int align, int len)

  -- signed arithmetic operations that may overflow; for the division operators,
  -- we assume that the second argument is never zero (i.e., an explicit
  -- test for zero is done before the operation).
    arithop
      = IADD | ISUB | IMUL
-- Quesion: perhaps the division operators should be moved out of `arith`, since
-- the div-by-zero and overflow tests will have to be explicit?
      | IDIV | IREM

  -- These operations might raise exceptions and do not access mutable memory.
    arith
      = ARITH (arithop oper, int sz)
      | REAL_TO_INT (rounding_mode mode, int from, int to)

  -- arithmetic operations that do not overflow; for the division operators,
  -- we assume that the second argument is never zero (i.e., an explicit
  -- test for zero is done before the operation).
    pureop
      = ADD | SUB
    -- NOTE: we distinguish between signed and unsigned MUL because MLRisc makes
    -- that distinction; even though 2's-complement multiplication is sign agnostic
      | SMUL | SDIV | SREM
      | UMUL | UDIV | UREM
      | LSHIFT | RSHIFT | RSHIFTL
      | ORB | XORB | ANDB
      | FADD | FSUB | FMUL | FDIV
      | FNEG | FABS | FSQRT

  -- These operations do not raise exceptions and do not access mutable memory.
    pure
      = PURE_ARITH (pureop oper, int sz)
      | EXTEND (bool signed, int from, int to)	-- extend a smaller value to a larger
						-- one (from < to) by zeros (signed is
						-- false) or the sign (signed is true)
      | INT_TO_REAL (int from, int to)		-- int to float conversion
      | PURE_SUBSCRIPT				-- indexed load of ML value
      | PURE_RAW_SUBSCRIPT(numkind kind, int sz) -- indexed load of raw value

  -- These operations fetch from mutable memory.
    looker
      = DEREF
      | SUBSCRIPT
      | RAW_SUBSCRIPT (numkind kind, int sz)
      | RAW_LOAD (numkind kind, int sz)		-- load raw value from base+offset
      | GET_HDLR | GET_VAR

  -- These operations all update mutable memory.
    setter
      = UNBOXED_UPDATE | UPDATE			-- array update
      | UNBOXED_ASSIGN | ASSIGN			-- reference assignment
      | RAW_UPDATE (numkind kind, int sz)	-- raw array update
      | RAW_STORE (numkind kind, int sz)	-- raw store to base+offset
      | SET_HDLR | SET_VAR

  -- comparison operators
  -- NOTE: this type is defined in the ArithOps structure (ElabData/prim/arithops.sml)
    cmpop = GT | GTE | LT | LTE | EQL | NEQ

  -- fcmpop conforms to the IEEE std 754 predicates.
    fcmpop
      = F_EQ	-- =
      | F_ULG	-- ?<>
      | F_UN	-- ?
      | F_LEG	-- <=>
      | F_GT	-- >
      | F_GE	-- >=
      | F_UGT	-- ?>
      | F_UGE	-- ?>=
      | F_LT	-- <
      | F_LE	-- <=
      | F_ULT	-- ?<
      | F_ULE	-- ?<=
      | F_LG	-- <>
      | F_UE	-- ?=

  -- These operations are two-way branches dependent on pure inputs
    branch
      = CMP (cmpop oper, bool signed, int sz)
      | FCMP (fcmpop oper, int sz)
      | FSGN (int)
      | PEQL | PNEQ

}

-- CFG IR
--
-- This IR is a simplified version of the first-order CPS IR, where we have
-- turned expressions into trees.
--
module CFG (
    import LambdaVar
    import CTypes
    import CFG_Prim
  ) {

  -- CFG types.
  --
    ty
      = NUMt (int)	-- integers of given size
      | FLTt (int) 	-- float of given size
      | PTRt		-- pointer
      | FUNt		-- function
      | CNTt		-- continuation

  -- Calling conventions for function entries and internal calls (i.e., `GOTO`)
  --
    calling_conv
      = STD_FUN		-- escaping function
      | STD_CONT	-- escaping continuation
      | KNOWN_CHK	-- non-escaping function with GC check
      | KNOWN		-- non-escaping function

  -- expressions; note that reals and strings are represented by access into the
  -- literal table, so we do not include them here.
  --
    exp
      = VAR (LambdaVar.lvar)
      | LABEL (LambdaVar.lvar)
      | NUM (integer iv, bool signed, int sz)
      | LOOKER (CFG_Prim.looker, exp*)
      | PURE (CFG_Prim.pure, exp*)
      | SELECT (int, exp)
      | OFFSET (int, exp)

    param = (LambdaVar.lvar, ty)

  -- branch probabilities are measured in percent (1..99).  We use 0 to
  -- represent the absence of probability information.
  --
    probability = int

    stm
      = LET (exp, param, stm)
      | ALLOC (CFG_Prim.alloc, exp*, LambdaVar.lvar, stm)
      -- `APPLY(args, tys)` is an external function application; the first
      -- argument is the function to be called and the `tys` are the argument
      -- types
      | APPLY (exp*, ty*)
      -- `THROW(args, tys)` is an external continuation application; the first
      -- argument is the continuation to be called and the `tys` are the argument
      -- types
      | THROW (exp*, ty*)
      -- `GOTO(cc, lab, args, tys)` is an internal function call to the specified
      -- label; `cc` is the calling convention, `args` are the arguments, and
      -- `tys` are the argument types
      | GOTO (calling_conv, LambdaVar.lvar, exp*, ty*)
      -- `SWITCH(v, exps)` is a multiway branch on `v`
      | SWITCH (exp, stm*)
      -- `BRANCH(br, args, p, trueExp, falseExp)` is a two-way conditional branch,
      -- where `p` is the probability that the branch is taken
      | BRANCH (CFG_Prim.branch, exp*, probability, stm, stm)
      -- `STREQL(n, s1, s2, trueExp, falseExp)` branches to `trueExp` if the string
      -- data `s1` is equal to `s2`, and to `falseExp` otherwise.
      | STREQL (int, exp, exp, stm, stm)
      -- "raw C call"
      | ARITH (CFG_Prim.arith, exp*, param, stm)
      | SETTER (CFG_Prim.setter, exp*, stm)
      | RCC (
	  bool reentrant,		-- true for reentrant calls
	  string linkage,		-- ??
	  CTypes.c_proto proto,		-- function prototype
	  exp* args,			-- arguments
	  param* results,		-- result variables (with types)
	  param* live,			-- live variables across call (with types)
	  stm k)			-- the continuation

  -- cluster entry fragment
  --
    entry = Entry (calling_conv cc, LambdaVar.lvar lab, param* params, stm body)

  -- internal cluster fragment
  --
    frag = Frag (bool gcCheck, LambdaVar.lvar lab, param* params, stm body)

  -- meta data about a cluster
  --
    attrs = (
	int alignHP,		-- alignment requirement for allocation pointer
	bool needsBasePtr,	-- true if cluster does PC-relative addressing
	bool hasTrapArith,	-- true if cluster has trapping arithmetic
	bool hasRCC		-- true if cluster contains raw C Calls
      )

  -- a cluster is a maximal flow graph where every known call is to a fragment in the
  -- the cluster.
  --
    cluster = Cluster (attrs attrs, entry entry, frag* frags)

    comp_unit = (string srcFile, cluster entry, cluster* fns)

}

-- C++ specialization
--
view Cxx {
    <file> <= interface_prologue %%
#include "code-buffer.hxx"
#include "lambda-var.hxx"

using Args_t = std::vector<llvm::Value *>;
%%
    <file> <= suppress : pickler

-- branch
    { CFG_Prim.branch }  <= public_code %%
        virtual llvm::Value *codegen (code_buffer *buf, Args_t &args) = 0;
%%
    { CFG_Prim.branch.* } <= public_code %%
        llvm::Value *codegen (code_buffer *buf, Args_t &args);
%%

-- setter
    { CFG_Prim.setter }  <= public_code %%
        virtual void codegen (code_buffer *buf, Args_t &args) = 0;
%%
    { CFG_Prim.setter.* } <= public_code %%
        void codegen (code_buffer *buf, Args_t &args);
%%

-- looker
    { CFG_Prim.looker }  <= public_code %%
        virtual llvm::Value *codegen (code_buffer *buf, Args_t &args) = 0;
%%
    { CFG_Prim.looker.* } <= public_code %%
        llvm::Value *codegen (code_buffer *buf, Args_t &args);
%%

-- arith
    { CFG_Prim.arith }  <= public_code %%
        virtual llvm::Value *codegen (code_buffer *buf, Args_t &args) = 0;
%%
    { CFG_Prim.arith.* } <= public_code %%
        llvm::Value *codegen (code_buffer *buf, Args_t &args);
%%

-- pure
    { CFG_Prim.pure }  <= public_code %%
        virtual llvm::Value *codegen (code_buffer *buf, Args_t &args) = 0;
%%
    { CFG_Prim.pure.* } <= public_code %%
        llvm::Value *codegen (code_buffer *buf, Args_t &args);
%%

-- alloc
    { CFG_Prim.alloc }  <= public_code %%
        virtual llvm::Value *codegen (code_buffer *buf, Args_t &args) = 0;
%%
    { CFG_Prim.alloc.* } <= public_code %%
        llvm::Value *codegen (code_buffer *buf, Args_t &args);
%%

-- ty
    { CFG.ty } <= public_code %%
	virtual llvm::Type *codegen (code_buffer *buf) = 0;
%%
    { CFG.ty.* } <= public_code %%
	llvm::Type *codegen (code_buffer *buf);
%%

-- exp
    { CFG.exp } <= public_code %%
        virtual llvm::Value *codegen (code_buffer *buf) = 0;
%%
    { CFG.exp.* } <= public_code %%
        llvm::Value *codegen (code_buffer *buf);
%%

-- stm
    { CFG.stm } <= public_code %%
        virtual void init (code_buffer *buf, bool blkEntry) = 0;
        virtual void codegen (code_buffer *buf) = 0;
        llvm::BasicBlock *bb () { return this->_bb; }
%%
    { CFG.stm } <= protected_code %%
        llvm::BasicBlock *_bb;  // for the first stm in a block
	void _initBB (code_buffer *buf, bool blkEntry);
%%

    { CFG.stm.* } <= public_code %%
        void init (code_buffer *buf, bool blkEntry);
        void codegen (code_buffer *buf);
%%

-- entry
    { CFG.entry } <= public_code %%
        void init (code_buffer *buf);
        void codegen (code_buffer *buf, Args_t &args);
%%

-- frag
    { CFG.frag } <= public_code %%
        void init (code_buffer *buf);
        void codegen (code_buffer *buf);
	llvm::BasicBlock *bb() const { return this->_v_body->bb(); }
	void setIncoming (int i, const llvm::BasicBlock *bblk, llvm::Value *v)
	{
	    this->_phiNodes[i]->setIncomingValueForBlock(bblk, v);
	}
%%
    { CFG.frag } <= private_code %%
        std::vector<llvm::PHINode *> _phiNodes;
%%

-- cluster
    { CFG.cluster } <= public_code %%
        void codegen (code_buffer *buf, bool isFirst);
%%

-- comp_unit
    { CFG.comp_unit } <= public_code %%
        void codegen (code_buffer *buf);
%%

}
