<HTML>
<HEAD>
<TITLE>SML/NJ Error Messages</TITLE></HEAD>
<!-- Changed by: Andrew Appel, 31-Oct-1997 -->
<BODY BGCOLOR="d3f8fc">
<H1>SML/NJ Error and Warning Messages</H1>
This document contains lists of error and warning messages produced by
the SML/NJ Version 110 compiler, sorted alphabetically, with 
short explanations and examples.

<h3>Parsing Errors</h3>
The parser used by SML/NJ is produced by ML-Yacc, and it uses a lexer
generated by ML-Lex.  The parser uses an error repair scheme that
attempts to get a correct parse by deleting, adding, or substituting
tokens.  The parser produces error messages like:
<pre>
  let x = 4 in x+3 end

  foo.sml:1.5 Error: syntax error: inserting  VAL
</pre>
This error message indicates how the parser attempted to "repair"
the input (from a file <tt>foo.sml</tt>), 
and in this case indicates that the parser thinks that
<tt>val</tt> is needed after the <tt>let</tt> (at line 1, column 5 of
<tt>foo.sml</tt>).
<p>
Syntax errors in expressions typed into the interactive system
(instead of taken from files) are not repaired very well, since the
parser cannot take advantage of lookahead beyond what you have typed.
<p>
If a syntax error is found in a program, then semantic errors
will not be reported (and the program will not be executed).
<p>
For more detailed discussion of syntax errors generated by the parser,
see the explanations of errors [76] through [79] below.

<h3>Compiler Bug Error Messages</h3>
Error messages that start with "<code>Error: Compiler bug:</code>
indicate that an unexpected situation has been encountered by
the compiler.  Example:
<pre>
Error: Compiler bug: ModuleUtil: getStr: bad entity
</pre>
Such a message indicates a bug in the compiler, and it 
should be reported to
<img src="../smlnj-list-logo.png" align=center>, with self-contained code
to reproduce the message if possible.
<p>
Most such messages will be <em>secondary</em> error messages, meaning
that they occur immediately following a normal (i.e. non "Compiler
Bug") error message.  Secondary errors typically occur when a primary
error disrupts the internal state or data structures of the compiler,
and the corrupted state then causes further failures.  The SML/NJ
compiler is pretty good at recovering from errors and failing
gracefully, so secondary Compiler Bug errors are rare.

<h3>Error Messages</h3>
In the example code shown for the following errors, the interactive
prompt symbols have been omitted to improve readability.  The user
input is shown in regular font, with the compiler responses in
italics.  For convenient cross-referencing we have numbered the error
messages, but since the messages are listed in alphabetical order, the
numbers will change globally when messages are added or deleted.

<dl>
<dt>[1] <strong>argument of raise is not an exception</strong><dd>
The expression following the <code><b>raise</b></code> keyword should
evaluate to an exception value, i.e. a value of type <code>exn</code>.
In this case, the value has some other, inappropriate type.  E.g.:
<pre>
  raise 3;
  <i>stdIn:16.7 Error: argument of raise is not an exception [literal]
    raised: int
    in expression:
      raise 3</i>
</pre>

<dt>[2] <strong>argument type variables in datatype replication</strong><dd>
In a datatype replication declaration, neither the type name on the
left hand side nor the type path (longid) on the right hand side
should be preceeded by formal type variable arguments, even if the
right hand side datatype is of arity n>0.
<pre>
  datatype 'a T = A of 'a;
  <i>datatype 'a T = A of 'a</i>

  datatype 'a T1 = datatype T;
  <i>stdIn:18.1-18.28 Error: argument type variables in datatype replication</i>

  datatype T1 = datatype T;
  <i>datatype 'a T = A of 'a</i>
</pre>

<dt>[3] <strong>can't find function arguments in clause</strong><dd>
This occurs when an formal parameter pattern is not supplied on the
left hand side in a <code>fun</code> declaration, or one of the
formal parameters of an infix function symbol is missing.
<pre>
  fun f = 3;
  <i>stdIn:1.5 Error: can't find function arguments in clause</i>

  infix 3 ++;
  <i>infix 3 ++</i>

  fun (x xx) = 3;
  <i>stdIn:1.5-2.6 Error: can't find function arguments in clause
  stdIn:1.5-2.6 Error: illegal function symbol in clause</i>
</pre>

<dt>[4] <strong>case object and rules don't agree</strong><dd>
The <em> case object </em> is the expression following the <code><b>case</b></code>
keyword.  It's type must agree with the type of the lhs patterns in
the <em>rules</em> (<code><i>pat</i> => <i>exp</i></code>) following the
<code><b>of</b></code> keyword.  All the patterns of the rules also have
to agree in type, but that is another error.
<pre>
  case 3
    of true => 1
     | false => 2;
  <i>stdIn:1.1-25.16 Error: case object and rules don't agree [literal]
    rule domain: bool
    object: int
    in expression:
      (case 3
	of true => 1
	 | false => 2)</i>
</pre>

<dt>[5] <strong>clauses don't all have function name</strong><dd>
In a <code>fun</code> definition, the function name must appear in
each clause.  If it is omitted from one or more clauses, this error results.
<pre>
  fun f nil = 1
    | (x::y) = x;
  <i>stdIn:1.5-17.15 Error: clauses don't all have function name</i>
</pre>
This error is also reported when the function name in two
clauses of the function definition differ, for instance because
of a misspelling.
<pre>
  fun test (SOME s) = true
    | teat (NONE) = false;
  stdIn:120.5-121.24 Error: clauses don't all have function name
</pre>

<dt>[6] <strong>clauses don't all have same number of patterns</strong><dd>
In a <code>fun</code> declaration, each clause, or rule, separated by
<code>|</code> (vertical bar symbol), has to have the same number of
curried arguments.
<pre>
  fun f x y = 3
    | f a b c = 4;
  <i>stdIn:1.5-26.16 Error: clauses don't all have same number of patterns
  stdIn:24.6-26.16 Error: types of rules don't agree [tycon mismatch]
    earlier rule(s): 'Z * 'Y -> int
    this rule: 'X * 'W * 'V -> int
    in rule:
      (a,b,c) => 4</i>
</pre>

<dt>[7] <strong>constant constructor applied to argument in pattern: %</strong><dd>
A constant constructor like <code>nil</code> can't be applied to an
argument in a pattern.
<pre>
  val nil x = [];
  <i>stdIn:1.5-24.8 Error: constant constructor applied to argument in pattern:nil</i>
</pre>

<dt>[8] <strong>constructor and argument don't agree in pattern</strong><dd>
A nonconstant constructor in a pattern must be applied to an argument
pattern of the appropriate type (i.e. the domain type of the constructor).
<pre>
  datatype t = A of int;
  val A true = A 3;
  <i>stdIn:1.1-26.3 Error: constructor and argument don't agree in pattern [tycon mismatch]
    constructor: int -> t
    argument:    bool
    in pattern:
      A true</i>
</pre>

<dt>[9] <strong>data constructor % used without argument in pattern</strong><dd>
A nonconstant constructor must be applied to an argument when it is
used in a pattern (though not necessarily when it is used in an expression).
<pre>
  datatype t = A of int
  val A = A 3;
  <i>stdIn:17.5-17.12 Error: data constructor A used without argument in pattern</i>
</pre>

<dt>[10] <strong>datatype % does not match specification</strong><dd>
Usually occurs because the constructors for a datatype declared in a
structure don't agree with the constructors (in names or number) of
a signature that the structure must match.
<pre>
  signature S = 
  sig
    datatype t = A of int
  end;
  <i>signature S = sig datatype t = A of int end</i>

  structure A : S =
  struct
    datatype t = A of int | B
  end;
  <i>stdIn:1.1-27.4 Error: datatype t does not match specification
     constructors in actual only: B</i>
</pre>

<dt>[11] <strong>datatype % has duplicate constructor name(s): %, %</strong><dd>
The names of the constructors of a given datatype must all be distinct.
<pre>
  datatype t = A | B | A of int;
  <i>stdIn:1.1-26.5 Error: datatype t has duplicate constructor name(s): A</i>
</pre>

<dt>[12] <strong>dependency cycle in instantiate</strong><dd>
The <em>instantiate</em> process takes a signature and creates a dummy
structure matching that signature with no extraneous sharing (i.e.
no types are identified that don't need to be).  This process can
fail because of various kinds of circularities.  An example of one
of the simpler forms of circularity would be:
<pre>
  signature S =
  sig
    type u
    datatype s = A of u
    sharing type u = s
  end;
  <i>stdIn:16.1-21.4 Error: dependency cycle in instantiate</i>
</pre>
By default, every signature is instantiated when it is declared, to
detect errors as early as possible.  However, signature instantiation
is strictly only necessary when a signature is used as a functor
parameter signature or in an opaque (<code>:></code>) signature constraint.
<p>

<dt>[13] <strong>duplicate constructor specifications for % caused by include</strong><dd>
A signature should have only one specification of a given value or
constructor name.  A common way that multiple constructor
specifications for a name can occur is if a constructor is
specified explicitly, and also implicitly through an included
signature.
<pre>
  signature S =
  sig
    datatype t = A of int
  end;
  <i>signature S = sig datatype t = A of int end</i>

  signature T =
  sig
    datatype u = A
    include S
  end;
  <i>stdIn:27.3-28.13 Error: duplicate constructor specifications for A caused by include</i>
</pre>

<dt>[14] <strong>duplicate exception declaration</strong><dd>
An exception name is declared multiple times in a single exception
declaration.
<pre>
  exception E of int
  and E of bool;
  <i>stdIn:17.1-18.14 Error: duplicate exception declaration: E</i>
</pre>
Note that it is ok if the same exception name is declared in different
exception declarations, as in the following.
<pre>
  exception E of int;
  <i>exception E of int</i>

  exception E of bool;
  <i>exception E of bool</i>
</pre>

<dt>[15] <strong>duplicate function name in val rec dec</strong><dd>
When declaring several functions in a single <code>val rec</code>
declaration, the names of the functions must be distinct.
<pre>
  val rec f = (fn x => x)
  and f = (fn y => y + 3);
  <i>stdIn:21.1-22.24 Error: duplicate function name in val rec dec: f</i>
</pre>

<dt>[16] <strong>duplicate function names in fun dec</strong><dd>
When declaring several functions in a single <code>fun</code>
declaration, the names of the functions must be distinct.
<pre>
  fun f x = x
  and f y = y + 3;
  <i>stdIn:1.1-23.16 Error: duplicate function names in fun dec: f</i>
</pre>

<dt>[17] <strong>duplicate label in record</strong><dd>
The label names in a record expression or pattern must be distinct.
<pre>
  {a=3,b=true,a="abc"};
  <i>stdIn:1.1-1.21 Error: duplicate label in record: a</i>
  fun f {a=x,a=y} = 3;
  <i>stdIn:2.2-2.11 Error: duplicate label in record: a</i>
</pre>

<dt>[18] <strong>duplicate specifications for % % in signature</strong><dd>
Only one specification for a given name in a given name space is
allowed in signatures.  Values and constructors (including exception
constructors) are in one name space; types, structures, and functors
are disjoint name spaces.  So <code>x</code> cannot be specified
twice as a value or constructor, but it can be specified as a
value, as a type, as a structure, and as a functor in the same
signature.
<pre>
  signature S =
  sig
    val x : int
    val x : bool
  end;
  <i>stdIn:20.3-21.16 Error: duplicate specifications for variable or constructor x in signature</i>

  signature S =
  sig
    type t
    type t
  end;
  <i>stdIn:24.3-25.10 Error: duplicate specifications for type constructor t in signature</i>
  signature S =
  sig
    exception Foo
    exception Foo of int
  end;
  <i>stdIn:28.3-29.24 Error: duplicate specifications for variable or constructor Foo in signature</i>

  signature S =
  sig
    structure A : sig end
    structure A : sig end
  end;
  <i>stdIn:32.3-33.25 Error: duplicate specifications for structure A in signature</i>

  signature S =
  sig
    val x : int
    datatype t = x
  end;
  <i>stdIn:36.3-37.18 Error: duplicate specifications for variable or constructor x in signature</i>

  signature S =
  sig
    val x : int
    type x
    structure x : sig end
  end;
  <i>signature S =
    sig
      val x : int
      type x
      structure x : sig end
    end</i>
</pre>

<dt>[19] <strong>duplicate specifications for functor % caused by include</strong><dd>
Multiple specifications for a functor name occur in a signature, with one of
the later ones introduced via an <code>include</code> spec.  If the
included functor spec comes first, you get error [19] instead.
<pre>
  signature S1 =
  sig
    functor F () : sig end
  end;
  <i>signature S1 = sig functor F : (<param>: <sig>) : <sig> end</i>

  signature S2 =
  sig
    include S1
    functor F(X: sig val x : int end): sig end
  end;
  <i>stdIn:55.3-56.46 Error: duplicate specifications for functor F in signature</i>

  signature S2 =
  sig
    functor F(X: sig val x : int end): sig end
    include S1
  end;
  <i>stdIn:59.3-60.14 Error: duplicate specifications for functor F caused by include</i>
</pre>

<dt>[20] <strong>duplicate specifications for structure % caused by include</strong><dd>
Multiple specifications for a structure name occur in a signature, with one of
the later ones introduced via an <code>include</code> spec.  If the
included structure spec comes first, you get error [19] instead.
<pre>
  signature S1 =
  sig
    structure A : sig end
  end;
  <i>signature S1 = sig structure A : sig end end</i>

  signature S2 =
  sig
    structure A : sig val x : int end
    include S1
  end;
  <i>stdIn:67.3-68.14 Error: duplicate specifications for structure A caused by include</i>

  signature S3 =
  sig
    include S1
    structure A : sig val x : int end
  end;
  <i>stdIn:71.3-72.37 Error: duplicate specifications for structure A in signature</i>
</pre>

<dt>[21] <strong>duplicate specifications for type % caused by include</strong><dd>
Multiple specifications for a type name occur in a signature, with one of
the later ones introduced via an <code>include</code> spec.  If the
included structure spec comes first, you get error [19] instead.
<pre>
  signature S1 =
  sig
    type t
  end;
  <i>signature S1 = sig type t end</i>

  signature S2 =
  sig
    type 'a t
    include S1
  end;
  <i>stdIn:79.3-80.14 Error: duplicate specifications for type t caused by include</i>

  signature S3 =
  sig
    include S1
    type 'a t
  end;
  <i>stdIn:83.3-84.13 Error: duplicate specifications for type constructor t in signature</i>
</pre>

<dt>[22] <strong>duplicate type definition</strong><dd>
A type name is defined twice in a single simultaneous type
declaration (i.e. type declarations separated by
<code><strong>and</strong></code>.
If the simultaneous declaration is split into
separate declarations, there is no error.
<pre>
  type t = int
  and t = bool;
  <i>stdIn:17.1-18.13 Error: duplicate type definition: t</i>

  type t = int;
  <i>type t = int</i>
  type t = bool;
  <i>type t = bool</i>
</pre>

<dt>[23] <strong>duplicate type names in type declaration</strong><dd>
A type name is defined multiple times in a datatype declaration
(including possibly in the <code><strong>withtype</strong></code> part.
<pre>
  datatype t = A
  and t = B;
  <i>stdIn:1.1-19.10 Error: duplicate type names in type declaration: t</i>

  datatype t = A
  withtype t = int;
  <i>stdIn:1.1-20.17 Error: duplicate type names in type declaration: t</i>
</pre>

<dt>[24] <strong>duplicate type variable name</strong><dd>
A type variable name is repeated in a type parameter list, when
defining an n-ary type or datatype constructor, or explicitly binding
types in a value declaration.
<pre>
  type ('a,'a) t = 'a * 'a;
  <i>stdIn:21.4-21.11 Error: duplicate type variable name: a</i>

  datatype ('a,'a) t = A of 'a;
  <i>stdIn:1.1-21.15 Error: duplicate type variable name: a</i>

  fun ('a,'a) f(x:'a) = x;
  <i>stdIn:1.1-21.10 Error: duplicate type variable name: a</i>
</pre>

<dt>[25] <strong>duplicate value specifications for % caused by include</strong><dd>
Multiple specifications for a value name occur in a signature, with one of
the later ones introduced via an <code>include</code> spec.  If the
included structure spec comes first, you get error [19] instead.  It
does not matter whether the multiple value specifications give the
same type or not.
<pre>
  signature S1 =
  sig
    val x : int
  end;
  <i>signature S1 = sig val x : int end</i>

  signature S2 =
  sig
    val x : bool
    include S1
  end;
  <i>stdIn:29.3-30.14 Error: duplicate value specifications for x caused by include</i>

  signature S3 =
  sig
    val x : int
    include S1
  end;
  <i>stdIn:33.3-34.14 Error: duplicate value specifications for x caused by include</i>

  signature S4 =
  sig 
    include S1
    val x : int
  end;
  <i>stdIn:37.3-38.15 Error: duplicate specifications for variable or constructor x in signature</i>
</pre>

<dt>[26] <strong>duplicate variable in pattern(s)</strong><dd>
A variable may only occur once in a pattern (or in the sequence of argument
patterns of a curried function declaration.
<pre>
  fun f(x,x) = x;
  <i>stdIn:1.5-2.10 Error: duplicate variable in pattern(s): x</i>

  fun f x x = x;
  <i>stdIn:1.5-2.9 Error: duplicate variable in pattern(s): x</i>

  val (x,x) = (3,3);
  <i>stdIn:1.1-36.3 Error: duplicate variable in pattern(s): x</i>
</pre>

<dt>[27] <strong>explicit type variable cannot be generalized at its binding declaration: %</strong><dd>
A type variable used in a type constraint within a value expression or
declaration must be generalized at the appropriate point (determined
either explicitly or implicitly).  If the type variable cannot be generalized
at that point because of the value restriction, this error message results.
<pre>
  val x : 'a list = (fn x => x) nil;
  <i>stdIn:1.1-37.14 Error: explicit type variable cannot be generalized at its binding declaration: 'a</i>

  val 'a (x: 'a list) = (fn x => x) nil;
  <i>stdIn:1.1-38.5 Error: explicit type variable cannot be generalized at its binding declaration: 'a</i>
</pre>

<dt>[28] <strong>expression and handler don't agree</strong><dd>
The type of the right hand side of the each rule in an exception
handler must agree with the type of the base expression that the
handler is attached to, because the value returned by the entire
handle expression is either that of the base expression or the
value returned by one of the handler rules.
<pre> 
  fun f x = (hd x)+1 handle Empty => true;
  <i>stdIn:2.6-38.7 Error: expression and handler don't agree [literal]
    body:          int
    handler range:          bool
    in expression:
      hd x + 1
      handle 
	  Empty => true
      | exn => raise exn</i>
</pre>

<dt>[29] <strong>expression or pattern begins with infix identifier "%"</strong><dd>
An infix identifier cannot be the first identifier in an expression,
unless it is preceded by the <code><strong>op</strong></code> keyword.
<pre>
  +(2,3);
  <i>stdIn:1.1 Error: expression or pattern begins with infix identifier "+"</i>

  op +(2,3);
  <i>val it = 5 : int</i>
</pre>

<dt>[30] <strong>expression or pattern ends with infix identifier "%"</strong><dd>
An expression cannot end with an infix identifier.  Perhaps there is
a missing <code><strong>op</strong></code> keyword.
<pre>
  2 +;
  <i>stdIn:40.4 Error: expression or pattern ends with infix identifier "+"
  stdIn:40.1-40.4 Error: operator is not a function [literal]
    operator: int
    in expression:
      2 +</i>

  (fn x => x) +;
  <i>stdIn:40.3 Error: expression or pattern ends with infix identifier "+"</i>

  (fn x => x) op +;
  <i>val it = fn : int * int -> int</i>
</pre>

<dt>[31] <strong>fixity precedence must be between 0 and 9</strong><dd>
This one is obvious.  When defining new infix operators, you have
to fit them into the existing precedence ranking, which is limited to
ten levels, from 0 to 9, with higher numbers giving stronger precedence.
See the <a href="basis/pages/top-level-chapter.html">Top Level Environment</a>
chapter of the Basis documentation for the precedences of the predefined
infix operators.
<pre>
  infix 10 ++;
  <i>stdIn:43.7-43.9 Error: fixity precedence must be between 0 and 9</i>

  infix ~2 ++;
  <i>stdIn:2.2-2.4 Error: fixity precedence must be between 0 and 9</i>
</pre>

<dt>[32] <strong>found data constructor instead of exception</strong><dd>
In a context where an exception constructor identifier was expected,
a dataconstructor identifier was found instead.
<pre>
  exception Foo = nil;
  <i>stdIn:17.1-17.20 Error: found data constructor instead of exception</i>
</pre>

<dt>[33] <strong>found variable instead of exception</strong><dd>
In a context where an exception constructor identifier was expected,
a value variable was found instead.
<pre>
  val x = 3;
  <i>val x = 3 : int</i>
  exception Foo = x;
  <i>stdIn:18.1-18.18 Error: found variable instead of exception</i>
</pre>

<dt>[34] <strong>handler domain is not exn</strong><dd>
In the rules following the <code><strong>handler</strong></code>
keyword, the type of the patterns on the left hand side the rule
must be <code>exn</code>.  In the example below, the first error
message is caused by a mismatch with an implicit default rule that
handles exceptions not handled by the explicit rules of the handler.
<pre>
  3 handle nil => 4;
  <i>stdIn:1.1-18.7 Error: types of rules don't agree [tycon mismatch]
    earlier rule(s): 'Z list -> int
    this rule: exn -> 'Y
    in rule:
      exn => raise exn
  stdIn:1.1-18.7 Error: handler domain is not exn [tycon mismatch]
    handler domain: 'Z list
    in expression:
      3
      handle 
	  nil => 4
      | exn => raise exn</i>
</pre>

<dt>[35] <strong>ill-formed datatype spec</strong><dd>
In a datatype replication specification in a signature, type
parameters were found on the left hand side of the specification.
<pre>
  signature S =
  sig
    datatype 'a t = datatype bool
  end;
  <i>stdIn:26.3-26.33 Error: ill-formed datatype spec</i>
</pre>

<dt>[36] <strong>illegal (multiple?) type constraints in AS pattern</strong><dd>
The value variable in front of the <code><strong>as</strong></code>
keyword can have a type constraint, but only one.  This error also
occurs in other circumstances, as illustrated by the second example.
<pre>
  val x : int list : int list as y::z = [1,2];
  <i>stdIn:29.5-29.36 Error: illegal (multiple?) type constraints in AS pattern</i>

  val (x: int list) as (y::z : int list) = [1];
  <i>stdIn:1.5-24.10 Error: illegal (multiple?) type constraints in AS pattern
  stdIn:1.5-24.10 Error: parentheses illegal around variable in AS pattern</i>

  val x : int list as (y::z) = [1,2];
  <i>stdIn:1.1-24.6 Warning: binding not exhaustive
	    x as y :: z = ...
  val x = [1,2] : int list
  val y = 1 : int
  val z = [2] : int list</i>
</pre>

<dt>[37] <strong>illegal function symbol in clause</strong><dd>
In a function declaration, the left hand side between
the keyword <code><strong>fun</strong></code> and the equal sign
must be a well-formed applicative term, and the operator (i.e. the function
part of the top-level application) of this term must be a simple
identifier.  If the application has an infix operator, it must
be parenthesized (unless followed immediately by a type constraint
or the equal sign); otherwise it may not be parenthesized.
<pre>
  fun (f x) = 3;  (* bad parentheses *)
  <i>stdIn:1.5-2.5 Error: can't find function arguments in clause
  stdIn:1.5-2.5 Error: illegal function symbol in clause</i>

  fun (x+y) = 3;  (* ok; redefines infix + operator *)
  <i>val + = fn : 'a * 'b -> int</i>
</pre>

<dt>[38] <strong>inconsistent arities in type sharing % = %: % has arity % and % has arity %</strong><dd>
Two types involved in a type sharing constraint have different
arities. 
<pre>	
  signature XSIG = sig
    datatype ('a, 'b) t = A of 'a | B of 'b
  end

  functor F
     (type u 
      structure X: XSIG
	  sharing type X.t = u) = 
  struct
  end

  <i>stdIn:49.11-54.6 Error: inconsistent arities in type sharing t = u : t
  has arity 2 and u has arity 0.</i>
</pre>	

<dt>[39] <strong>inconsistent equality properties in type sharing</strong><dd>
This error occurs when type constructors with incompatible equality
properties are equated by sharing constraints.  When this happens, the
signature is not consistent, and could not be successfully matched.
<pre>
  signature S =
  sig
    eqtype t
    datatype u = U of int -> int  (* not an equality type *)
    sharing type t = u
  end;
  <i>stdIn:17.1-22.4 Error: inconsistent equality properties in type sharing</i>
</pre>

<dt>[40] <strong>infix operator "%" used without "op" in fun dec</strong><dd>
    A function symbol declared to be an infix symbol is used in a 
    function declaration used to declare nonfix functions. 
<pre>
  infix foo;
  <i>infix foo</i>
  fun foo (x,y) = x + y;
  <i>stdIn:34.5-34.8 Error: infix operator "foo" used without "op" in fun dec</i>
</pre>
The correct definition is:
<pre>
  fun op foo(x,y) = x +y;
  <i>val foo = fn : int * int -> int</i>
</pre>

<dt>[41] <strong>infix operator required, or delete parentheses</strong><dd>
The first term following keyword <code><strong>fun</strong></code> in
a function declaration is a parenthesized application, implying an
infix application, but the middle subterm is not an infix symbol.
<pre>
  fun (x f y) = ();  (* would work if "f" were infix *)
  <i>stdIn:18.8 Error: infix operator required, or delete parentheses</i>

  fun x f y = ();    (* ok, but maybe not what was intended *)
  <i>val x = fn : 'a -> 'b -> unit</i>
</pre>

<dt>[42] <strong>infix symbol "%" used where a nonfix identifier was expected</strong><dd>
In a <code><strong>val rec</strong></code> declaration, the if the
identifier being declared (on the left hand side of the declaration) is
an infix symbol, it must be preceeded by the <code><strong>op</strong></code>
keyword.
<pre>
  infix ++;
  <i>infix ++</i>
  val rec ++ = (fn x => x);
  <i>stdIn:17.9-17.11 Error: infix symbol "++" used where a nonfix identifier was expected</i>

  val rec op ++ = (fn x => x);
  <i>val ++ = fn : 'a -> 'a</i>
</pre>

<dt>[43] <strong>install_pp: empty path</strong><dd>
The function <code>Compiler.PPTable.install_pp</code> installs a
user-defined pretty printer function (the second argument) for a
generative (i.e. datatype or abstype) designated by the first
argument, which must be a nonempty list of strings that can be
interpreted as a symbolic path (longTyCon) naming a
datatype or abstract type in the current environment.
This function should only be called at top level.
<pre>
  Compiler.PPTable.install_pp [] (fn x => fn y => ());
   <i>Error: install_pp: empty path</i>
</pre>

<dt>[44] <strong>install_pp: nongenerative type constructor</strong><dd>
The function <code>Compiler.PPTable.install_pp</code> installs a
user-defined pretty printer function (the second argument) for a
generative (i.e. datatype or abstype) designated by the first
argument, which must be a nonempty list of strings that can be
interpreted as a symbolic path (longTyCon) naming a datatype
or abstype in the current environment.  This function should only
be called at top level.
<pre>
  Compiler.PPTable.install_pp ["t"] (fn x => fn y => ());
   <i>Error: install_pp: nongenerative type constructor</i>
</pre>

<dt>[45] <strong>int constant too large</strong><dd>
    Integer literal in program is too large. Default integers are 
    represented using 31 bits, and range from ~1073741824 to 1073741823, 
    or from:
<pre>		
	 Option.valOf(Int.minInt) to Option.valOf(Int.maxInt)
</pre>

<pre>
  val x = 1073741823;
  <i>val x = 1073741823 : int</i>

  val x = 1073741824;
  <i>stdIn:2.4-22.7 Error: int constant too large</i>

  val x = ~1073741824;
  <i>val x = ~1073741824 : int</i>

  val  x = ~1073741825;
  <i>stdIn:30.10-30.21 Error: int constant too large</i>
</pre>

<dt>[46] <strong>match nonexhaustive</strong><dd>
Insufficient patterns in clause to match against all the 
possible inputs. This is an error if the flag
<code>Compiler.Control.MC.matchNonExhaustiveError</code>
is set to true (the default is false), otherwise it is a warning if
<code>Compiler.Control.MC.matchNonExhaustiveWarn</code>
is set to true.  If neither of these flags is true, then
the compiler does not complain about nonexhaustive matches.
<pre>
  fun f 0 = 1
    | f 1 = 1;
  <i>stdIn:1.1-22.12 Error: match nonexhaustive
	    0 => ...
	    1 => ...

  val f = fn : int -> int</i>
</pre>

<dt>[47] <strong>match redundant</strong><dd>
A pattern is provided that is covered by some earlier pattern. 
If the compiler flag 
<code>Compiler.Control.MC.matchRedundantError</code>
is set to false (default is true), only a warning message
is given.  If 
<code>Compiler.Control.MC.matchRedundantWarn</code>
is also false (default is true), no message is generated.
<pre>	
  fun f (0, true) = 1
    | f (0, false) = 2
    | f (0, _) = 3
    | f _ = 4;
  <i>stdIn:24.1-27.14 Error: match redundant
	    (0,true) => ...
	    (0,false) => ...
      -->   (0,_) => ...
	    _ => ...</i>
</pre>  

<dt>[48] <strong>match redundant and nonexhaustive</strong><dd>
A pattern is provided that is covered by some earlier pattern, 
and the set of patterns do not cover all the possible inputs.
Whether this message is generated, and its severity (Error or
Warning), are controlled by the compiler flags
<pre>
    <code>Compiler.Control.MC.matchNonExhaustiveError</code>
    <code>Compiler.Control.MC.matchNonExhaustiveWarn</code>
    <code>Compiler.Control.MC.matchRedundantError</code>
    <code>Compiler.Control.MC.matchRedundantWarn</code>
</pre>
Example:
<pre>
  fun f 1 = 1
    | f 2 = 3
    | f 1 = 4 ;
  <i>stdIn:1.1-24.12 Error: match redundant and nonexhaustive
	    1 => ...
	    2 => ...
      -->   1 => ...</i>
</pre>

<dt>[49] <strong>multiple where defs for %</strong><dd>
The <tt>where</tt> clauses of a signature expression must not
bind the same type-specification multiple times.
<pre>
  signature S = sig
    type t
  end 
  where type t = int
    and type t = bool;
  <i>stdIn:1.1-72.20 Error: multiple where defs for t</i>
</pre>
or even:
<pre>
  signature S = sig
    type t
  end
  where type t = int
    and type t = int;
  <i>stdIn:1.1-76.19 Error: multiple where defs for t</i>
</pre>

<dt>[50] <strong>non-constructor applied to argument in pattern</strong><dd>
The value applied to an argument in a pattern is not a constructor.
<pre>
  fun f (0 0) = true;
  <i>stdIn:17.5-17.19 Error: non-constructor applied to argument in pattern</i>
</pre>    

<dt>[51] <strong>non-constructor applied to argument in pattern: %</strong><dd>
Same error as [58]. This particular error occurs when the applied value has a 
name that can be reported. 
<pre>
  val a = 0;
  <i>val a = 0 : int</i>

  fun f (a 0) = true;
  <i>stdIn:18.5-18.19 Error: non-constructor applied to argument in pattern: a</i>
</pre>

<dt>[52] <strong>nonlocal path in structure sharing: %</strong><dd>
A structure participating in a structure <strong>sharing</strong>
specification was not declared in the current signature.
<pre>
  signature S = sig
    structure A : sig end
    sharing A = B.C
  end;
  <i>stdIn:41.11-41.18 Error: nonlocal path in structure sharing: B.C</i>
</pre>

<dt>[53] <strong>nonlocal path in type sharing: %</strong><dd>
A type participating in a type <strong>sharing</strong> specification 
was not declared in the current signature.
<pre>
  signature S = sig
    type t
    sharing type t = B.t
  end;
  <i>stdIn:44.16-44.23 Error: nonlocal path in type sharing: B.t</i>
</pre>

<dt>[54] <strong>operator and operand don't agree</strong><dd>
A function (operator) is applied to a value (operand) with a type different than 
the type expected by the function.
<pre>
  fun f true = 0
    | f false = 1;
  <i>val f = fn : bool -> int</i>

  f 3;
  <i>stdIn:25.1-25.4 Error: operator and operand don't agree [literal]
    operator domain: bool
    operand:         int
    in expression:
      f 3</i>
</pre>

<dt>[55] <strong>operator is not a function</strong><dd>
The value used in operator position is not a function.
<pre>
  3 true;
  <i>stdIn:1.1-19.6 Error: operator is not a function [literal]
    operator: int
    in expression:
      3 true</i>
</pre>

<dt>[56] <strong>or-patterns don't agree</strong><dd>
In a pattern that uses <it>or-ed</tt> subpatterns (via <code>|</code>), the type
of all the subpatterns must agree.
<pre>
  fun f (0 | 1 | true) = 0;
  <i>stdIn:1.1-21.4 Error: or-patterns don't agree [literal]
    expected: int
    found: bool
    in pattern:
      (1 | true)</i>
</pre>

<dt>[57] <strong>out-of-range word literal in pattern: 0w%</strong><dd>
A word literal used in a pattern is larger than the largest representable word.
<pre>
  fun f 0w100000000000 = 0 
    | f _ = 1;
  <i>stdIn:1.1-27.12 Error: out-of-range word literal in pattern: 0w100000000000</i>
</pre>

<dt>[58] <strong>overloaded variable not defined at type</strong><dd>
An overloaded variable is being instantiated at a type for which it has no 
definition. Typical overloaded variables include numerical operations, 
overloaded over the numerical types (int, word, etc.)
<pre>
  true + true;
  <i>stdIn:19.5 Error: overloaded variable not defined at type
    symbol: +
    type: bool</i>
</pre>

<dt>[59] <strong>parameter or result constraints of clauses don't agree</strong><dd>
In a <code><strong>fun</strong></code> declaration, each clause, or rule, separated by
<code><strong>|</strong></code> (vertical bar symbol), has to have the same type (both 
in the type accepted by the clauses, and the type returned by the clauses).
<pre>
  datatype typeA = A;
  <i>datatype typeA = A</i>
  datatype typeB = B;
  <i>datatype typeB = B</i>
  fun f A = 0
    | f B = 0;
  <i>stdIn:36.1-37.12 Error: parameter or result constraints of clauses don't agree [tycon mismatch]
    this clause:      typeB -> 'Z
    previous clauses:      typeA -> 'Z
    in declaration:
      f =
	(fn A => 0
	  | B => 0)</i>
</pre>

<dt>[60] <strong>parentheses illegal around variable in AS pattern</strong><dd>
In an "as"-pattern <code><i>pat</i> as <i>pat</i></code>, where the pattern to the left 
of the "as" is a simple variable, the variable must not be wrapped in parentheses.
<pre>
  val ((a) as (b,c)) = (4,5);
  <i>stdIn:19.5-31.2 Error: parentheses illegal around variable in AS pattern</i>
</pre>

<dt>[61] <strong>pattern and constraint don't agree</strong><dd>
In a pattern, the type of the pattern and the constaint type of the pattern must agree.
<pre>
  fun f (0:bool)=0;
  <i>stdIn:38.1-38.17 Error: pattern and constraint don't agree [literal]
    pattern:    int
    constraint:    bool
    in pattern:
      0 : bool</i>
</pre>

<dt>[62] <strong>pattern and expression in val dec don't agree</strong><dd>
In a declaration <code>val <i>pat</i> = <i>exp</i></code>, the type of
<i>pat</i> must match the type of <i>exp</i>.
<pre>
  val s:string = 6;
  <i>stdIn:1.1-18.6 Error: pattern and expression in val dec don't agree [literal]
    pattern:    string
    expression:    int
    in declaration:
      s : string = 6</i>
</pre>

<dt>[63] <strong>pattern and expression in val dec don't agree</strong><dd>
In a declaration <code>val <i>pat</i> = <i>exp</i></code>, the type of
<code><i>pat</i></code> must match the type of <code><i>exp</i></code>.
<pre>
  val s:string = 6;
  <i>stdIn:1.1-18.6 Error: pattern and expression in val dec don't agree [literal]
    pattern:    string
    expression:    int
    in declaration:
      s : string = 6</i>
</pre>

<dt>[64] <strong>pattern to left of "as" must be variable</strong><dd>
In an "as"-pattern <code><i>pat</i> as <i>pat</i></code>, the first pattern
must be a simple variable, not a more complex pattern using tuples
or data constructors.
<pre>
  val (a,_) as (_,b) = (7,5);
  <i>stdIn:1.5-18.8 Error: pattern to left of AS must be variable</i>
</pre>

<dt>[65] <strong>pattern to left of AS must be variable</strong><dd>
In an "as"-pattern <i>pat</i> <tt>as</tt> <i>pat</i>, the first pattern
must be a simple variable, not a more complex pattern using tuples
or data constructors.
<pre>
  val (a,_) as (_,b) = (7,5);
  <i>stdIn:1.5-18.8 Error: pattern to left of AS must be variable</i>
</pre>

<dt>[66] <strong>possibly inconsistent structure definitions at: %</strong><dd>
When a signature contains a sharing constraint between 
two structure-specifications, each of which is specified using a <tt>where</tt>
clause, the compiler is unable to calculate whether the structures
are compatible.  This is a bug in the compiler and will be fixed
in a future version.
<pre>
  signature SIG =  
  sig
     structure A : sig end
     structure B : sig structure Z : sig end 
                   end where Z = A
     structure C : sig structure Z : sig end 
                   end where Z = A
     sharing B = C
  end;
  
  <i>stdIn:1.1-38.4 Error: possibly inconsistent structure definitions at: B.Z</i>
</pre>

<dt>[67] <strong>real constant out of range: %</strong><dd>
A real literal must have an exponent in the proper range for the
floating-point representation of the target machine.  At present
all SML/NJ target machines use IEEE double-precision floating point,
so real literals must be in the range 
~1.79769313486e308 to 1.79769313486e308.
<pre>
  2e309;
 
  <i>uncaught exception BadReal
    raised at: bignums/realconst.sml:228.54-228.63</i>
</pre>
At present, a bug in the compiler raises an exception instead of
printing the appropriate error message.
<p>

<dt>[68] <strong>rebinding data constructor "%" as variable</strong><dd>
An identifier bound as a data constructor cannot be rebound as a variable
in a pattern.
<pre>
  fun nil x = x;
  <i>stdIn:1.5-2.9 Error: rebinding data constructor "nil" as variable</i>
</pre>

<dt>[69] <strong>redundant patterns in match</strong><dd>
In a multi-clause pattern match, if one of the later patterns can only
match cases that are covered by earlier patterns, then the
later pattern is redundant and can never be matched.  In SML '97 it
is an error to have useless (redundant) patterns.
<pre>
  4 handle Match => 5 | e => 6 | Bind => 7;
  <i>stdIn:1.1-20.15 Error: redundant patterns in match
            Match => ...
            e => ...
      -->   Bind => ...</i>
</pre>

<dt>[70] <strong>redundant where definitions</strong><dd>
The <tt>where</tt> clauses of a signature expression must not
bind the same structure-specification to different structures.
<pre>
  signature S1 =
  sig
    structure A : sig type t end
  end
  where A=Int and A=Real;
  <i>stdIn:32.1-36.23 Error: redundant where definitions</i>
</pre>

<dt>[71] <strong>rhs of datatype replication not a datatype</strong><dd>
The declaration
<pre>
  datatype <i>id1</i> = datatype <i>id2</i>
</pre>
that binds the name <i>id1</i> to the existing datatype <i>id2</i>,
requires that <i>id2</i> must be a datatype, and not an ordinary type.
<pre>
  datatype myint = datatype int;
  <i>stdIn:38.1-38.30 Error: rhs of datatype replication not a datatype</i>
</pre>

<dt>[72] <strong>rhs of datatype replication spec not a datatype</strong><dd>
The specification
<pre>
  datatype <i>id1</i> = datatype <i>id2</i>
</pre>
that binds the name <code><i>id1</i></code> to the existing datatype
<code><i>id2</i></code>, requires that <code><i>id2</i></code> must be
a datatype, and not an ordinary type.
<pre>
  signature S = sig type t   
                    datatype d = datatype t
                end;
  <i>stdIn:37.18-40.17 Error: rhs of datatype replication spec not a datatype</i>
</pre>

<dt>[73] <strong>right-hand-side of clause doesn't agree with function result type</strong><dd>
The body of (each clause of) a function must have the type specified
in the function-result type constraint (if it is present).
<pre>
  fun f(x) : int = "hello";
  <i>stdIn:1.1-37.24 Error: right-hand-side of clause doesn't agree with function result type [tycon mismatch]
    expression:  string
    result type:  int
    in declaration:
      f = (fn x => "hello": int)</i>
</pre>

<dt>[74] <strong>sharing structure with a descendent substructure</strong><dd>
A structure cannot share with one of its components.
<pre>
  signature S = sig structure A : sig structure B : sig end end
                    sharing A = A.B 
                end;
  <i>stdIn:1.1-44.20 Error: Sharing structure with a descendent substructure</i>
</pre>

<dt>[75] <strong>structure % defined by partially applied functor</strong><dd>
Functors in SML/NJ may be higher-order, so that the functor F in the
example below returns (as its result) another functor, which in turn
returns a structure.  The result of applying F to an argument cannot,
therefore, be bound to a structure name.
<pre>
  functor F()() = struct end;
  <i>functor F : <sig></i>

  structure S = F();
  <i>stdIn:45.15-45.18 Error: structure S defined by partially applied functor</i>
</pre>

<dt>[76] <strong>syntax error found at %</strong> <dd>
This message is produced if the parser finds a syntax error and is
unable to correct the problem using its built-in heuristics (<a
href=#syndel>deletion</a>, <a href=#synins>insertion</a>, or <a
href=#synrepl>replacement</a> of tokens).  Example:
<pre>
  x andalso val y orelse z;
  <i>stdIn:1.6 Error: syntax error found at VAL</i>
</pre>
<i>Note:</i> Error correction in the parser relies on lookahead.
Different amounts of lookahead are used depending on whether input is
taken from the interactive toplevel or from a source file.  Therefore,
error messages for the same program can vary depending on circumstances.
(See also the <a href=#noteins>note on error [78]</a>.)
<p>

<dt><a name=syndel>[77]</a> <strong>syntax error: deleting %</strong><dd>
This message indicates that the error-correcting parser
attempted to rectify a syntax error by deleting (ignoring) some input
token(s).
<p>
For example, let's assume that file <i>delete.sml</i> contains the
following code:
<pre>
  structure 99 X =
      struct
	  val x = 1
      end
</pre>
Compiling this file produces:
<pre>
  - use "delete.sml";
  <i>[opening delete.sml]</i>
  <i>delete.sml:1.11-1.13 Error: syntax error: deleting  INT</i>
</pre>
<i>Note:</i> Error correction in the parser relies on lookahead.
Different amounts of lookahead are used depending on whether input is
taken from the interactive toplevel or from a source file.  Therefore,
error messages for the same program can vary depending on circumstances.
(See also the <a href=#noteins>note on error [78]</a>.)
<p>

<dt><a name=synins>[78]</a> <strong>syntax error: inserting %</strong>
<dd>
This error message, like the previous one, is generated by SML/NJ's
error-correcting parser.  It indicates that the parser was able to
correct a syntactic error by inserting an additional token.
<p>
For example, let's assume that file <i>insert.sml</i> contains the
following code:
<pre>
  let
    val x = 1; y = x + x
  in
    x * y
  end
</pre>
Compiling this file produces:
<pre>
  - use "insert.sml";
  <i>[opening insert.sml]
  insert.sml:2.16 Error: syntax error: inserting  VAL</i>
</pre>
<a name=noteins><i>Note:</i></a> Error correction in the parser relies
on lookahead.
Since the interactive parser cannot use lookahead, it is likely that
its syntax error messages differ from those that are generated when
compiling files.  For example, typing the contents of
<i>insert.sml</i> directly into the interactive toplevel produces:
<pre>
  let
    val x = 1; y = x + x
  in
    x * y
  end;
  <i>stdIn:2.14-2.19 Error: syntax error: deleting  ID EQUALOP ID
  stdIn:2.20-3.3 Error: syntax error: deleting  ID ID IN
  stdIn:4.3-4.8 Error: syntax error: deleting  ID ASTERISK ID</i>
</pre>

<dt><a name=synrepl>[79]</a> <strong>syntax error: replacing % with %</strong><dd>
The parser found a syntax error and has attempted to fix the problem
by replacing some token(s) by some other token(s).
<p>
For example, let's assume that file <i>replace.sml</i> contains the
following code:
<pre>
  fn x = x
</pre>
Compiling this file produces:
<pre>
  - use "replace.sml";
  <i>[opening replace.sml]
  replace.sml:1.6 Error: syntax error: replacing  EQUALOP with  DARROW</i>
</pre>
<i>Note:</i> Error correction in the parser relies on lookahead.
Different amounts of lookahead are used depending on whether input is
taken from the interactive toplevel or from a source file.  Therefore,
error messages for the same program can vary depending on circumstances.
(See also the <a href=#noteins>note on error [78]</a>.)
<p>

<dt>[80] <strong>tycon arity for % does not match specified arity</strong><dd>
The arity of a type constructor differs between the definition inside
a structure and its declaration in the corresponding signature
constraint.
<p>
Example:
<pre>
  signature S = sig type ('a, 'b) t end;
  <i>signature S = sig type ('a,'b) t end</i>

  structure S : S = struct
    type 'a t = 'a list
  end;
  <i>stdIn:75.1-77.4 Error: tycon arity for t does not match specified arity</i>
</pre>

<dt>[81] <strong>type % must be a datatype</strong><dd>
This message indicates that the signature constraint for a given
structure requires some type to be a <strong>datatype</strong> but the
structure defines it as different type (i.e., not a datatype).
<p>
Example:
<pre>
signature S = sig datatype t = A | B end;
<i>signature S = sig datatype t = A | B end</i>

structure S : S = struct
  type t = int
end;
<i>stdIn:80.1-82.4 Error: type t must be a datatype
stdIn:80.1-82.4 Error: unmatched constructor specification: A
stdIn:80.1-82.4 Error: unmatched constructor specification: B</i>
</pre>

<dt>[82] <strong>type % must be an equality type</strong>
<dd>
This error message is issued when the definition for some type inside
a structure does not permit equality while the corresponding signature
constraint for the structure specifies that type as an
<strong>eqtype</strong>.
<p>
Example:
<pre>
  signature S = sig eqtype t end;
  <i>signature S = sig eqtype t end</i>

  structure S : S = struct
    type t = int -> int
  end;
  <i>stdIn:86.1-88.4 Error: type t must be an equality type</i>
</pre>

<dt>[83] <strong>type constraint of val rec dec is not a function type</strong>
<dd>
Names that are defined using <strong>val rec</strong> must refer to
function values.  Therefore, their types must be function types.
<p>
Example:
<pre>
  val rec f : int = fn x => x;
  <i>stdIn:1.1-79.26 Error: type constraint of val rec dec is not a function type [tycon mismatch]
    constraint:           int
    in declaration:
      f = (fn x => x)</i>
</pre>

<dt>[84] <strong>type constraints on val rec declaraction [sic] disagree</strong><dd>
This error message occurs when a declaration has the form
<pre>
  val rec <i>id</i> : <i>ty1</i> = <i>exp : ty2</i>
</pre>
and the types <code><i>ty1</i></code> and <code><i>ty2</i></code> disagree.
<pre>
  val rec f : int -> int = (fn x => x) : bool -> bool;
  <i>stdIn:1.1-29.30 Error: type constraints on val rec declaraction disagree [tycon mismatch]
    this constraint:   bool -> bool
    outer constraints:   int -> int
    in declaration:
      f = (fn x => x): bool -> bool</i>
</pre>

<p>

<dt>[85] <strong>type constructor % given % arguments, wants %</strong>
<dd>
A type constructor was used with the wrong number of type arguments.
<p>
Example:
<pre>
  type ('a, 'b) t = 'a * 'b;
  <i>type ('a,'b) t = 'a * 'b</i>

  type u = (int, bool, real) t;
  <i>stdIn:103.28 Error: type constructor t given 3 arguments, wants 2</i>
</pre>

<dt>[86] <strong>type variable % occurs with different equality
properties in the same scope</strong> <dd>
This message indicates that different occurences of the same type
variable have inconsistent equality properties.  In practice this
means that the same name of a type variable was used both with one
apostrophe and with two apostrophes. (Note that this would have been
ok if the two occurences are clearly separated by scope.)
<p>
Example:
<pre>
  fun f (x: 'a, y: ''a) = (x, y);
  <i>stdIn:118.2-119.12 Error: type variable a occurs with different equality properties in the same scope</i>
</pre>
But:
<pre>
  fun 'a f (x: 'a) = let
    fun ''a g (y: ''a) = y = y
  in x end;
  <i>val f = fn : 'a -> 'a</i>
</pre>

<dt>[87] <strong>type variable in exception spec: %</strong> <dd>
Exception declarations in signatures cannot contain type variables.
<p>
Example:
<pre>
  signature S = sig
    exception E of 'a list
  end;
  <i>stdIn:135.3-135.26 Error: type variable in exception spec: E</i>
</pre>

<dt>[88] <strong>type variable in top level exception type</strong><dd>
Exception definitions at top level cannot contain type variables.
<p>
Example:
<pre>
  exception E of 'a list;
  <i>stdIn:1.1-135.4 Error: type variable in top level exception type</i>
</pre>

<dt>[89] <strong>types of rules don't agree</strong><dd>
The right-hand sides of the rules in a match must agree in type.
Matches occur both in <code><strong>case</strong></code>- and in
<code><strong>fn</strong></code>-expressions.
<p>
Examples:
<pre>
  fn true => false
   | false => 1;
  <i>stdIn:144.1-144.30 Error: types of rules don't agree [literal]
    earlier rule(s): bool -> bool
    this rule: bool -> int
    in rule:
      false => 1</i>

  fn x =>
     case x
       of true => false
	| false => 1;
  <i>stdIn:144.6-144.42 Error: types of rules don't agree [literal]
    earlier rule(s): bool -> bool
    this rule: bool -> int
    in rule:
      false => 1</i>
</pre>

<dt>[90] <strong>unbound functor signature: %</strong><dd>
This error message is related to SML/NJ's higher-order module
extension to Standard ML.  The constraint on a functor declaration in
some signature uses an undefined functor signature name.
<p>
Example:
<pre>
  signature S = sig
    functor F: FS
  end;
  <i>stdIn:145.3-145.17 Error: unbound functor signature: FS</i>
</pre>

<dt>[91] <strong>unbound functor: %</strong><dd>
The name of the functor being used is not defined.
<p>
Example:
<pre>
  structure S = F ();
  <i>stdIn:147.15-147.19 Error: unbound functor: F</i>
</pre>

<dt>[92] <strong>unbound left hand side in where (structure): %</strong><dd>
A <strong>where</strong> specification refers to a structure inside a
signature that was not declared there.
<p>
Example:
<pre>
  structure A = struct end;
  <i>structure A : sig end</i>

  signature S = sig end;
  <i>signature S = sig end</i>

  signature S' = S where B = A;
  <i>stdIn:158.1-158.29 Error: unbound left hand side in where (structure): B</i>
</pre>
But:
<pre>
  signature S = sig structure B : sig end end;
  <i>signature S = sig structure B : sig end end</i>

  signature S' = S where B = A;
  <i>signature S' = sig structure B : sig end end</i>
</pre>

<dt>[93] <strong>unbound left hand side in where type: %</strong><dd>
A <code><strong>where type</strong></code> specification refers to a type inside a
signature that was not declared there.
<p>
Example:
<pre>
  type t = int;
  <i>type t = int</i>

  signature S = sig end;
  <i>signature S = sig end</i>

  signature S' = S where type u = t;
  <i>stdIn:169.1-169.34 Error: unbound left hand side in where type: u</i>
</pre>
But:
<pre>
  signature S = sig type u end;
  <i>signature S = sig type u end</i>

  signature S' = S where type u = t;
  <i>signature S' = sig type u = t end</i>
</pre>

<dt>[94] <strong>unbound signature: %</strong><dd>
A signature name is used but it has not been defined; for instance
<code>S</code> in the following example:
<pre>
  structure A : S = struct end;
  <i>stdIn:16.15 Error: unbound signature: S</i>
</pre>

<dt>[95] <strong>unbound structure: %</strong><dd>
A structure name is used but it has not been defined; for instance
<code>B</code> in the following example:
<pre>
  - structure A = B;
  stdIn:2.10 Error: unbound structure: B
</pre>

<dt>[96] <strong>unbound type constructor: %</strong><dd>
A type constructor name is used but it has not been defined, for instance
<code>t</code> in the following example:
<pre>
  val x : t = ();
  <i>stdIn:2.4 Error: unbound type constructor: t</i>
</pre>

<dt>[97] <strong>unbound type variable in type declaration: %</strong><dd>
A type variable occurs on the right hand side of a type or datatype
declaration, without having been bound as a formal parameter on the
left hand side.
<pre>
  type t = 'a list;
  <i>stdIn:2.5-2.12 Error: unbound type variable in type declaration: 'a</i>

  datatype 'a t = A of 'b;
  <i>stdIn:1.1-18.2 Error: unbound type variable in type declaration: 'b</i>
</pre>

<dt>[98] <strong>unbound variable or constructor: %</strong><dd>
A value variable or constructor is used without having been defined
or bound as a formal parameter.
<pre>
  x;
  <i>stdIn:1.1 Error: unbound variable or constructor: x</i>

  fun f x = x+y;
  <i>stdIn:2.8 Error: unbound variable or constructor: y</i>
</pre>

<dt>[99] <strong>unresolved flex record (can't tell what fields there are besides %)</strong><dd>
When a flexible record pattern (one containing <code><strong>...</strong></code>)
is used, the context must provide enough type information to determine
what all the fields are (though not necessarily their types).
<pre>
  fun f {x,...} = x;
  <i>stdIn:37.1-37.18 Error: unresolved flex record
     (can't tell what fields there are besides #x)</i>

  fun f ({x,...} : {x: int, y:bool}) = x;
  <i>val f = fn : {x:int, y:bool} -> int</i>
</pre>
If more than one field occurs in the flexible record pattern, then
a different variant of this error message is generated.  See error [100].
<p>

<dt>[100] <strong>unresolved flex record (need to know the names of ALL
the fields in this context)</strong><dd>
The pattern in a pattern match was a <i>flexible record</i>.  The
pattern omitted some of the record's members and summarized their
existence using ellipses ("<strong>...</strong>").  But in the given
context there was not enough information for the type checker to be
able to infer the missing field names.
<pre>
  fun f {x,y,...} = (x,y);
  <i>stdIn:118.1-118.24 Error: unresolved flex record (need to know the names of ALL the fields
   in this context)
    type: {x:'Y, y:'X; 'Z}</i>
</pre>

<dt>[101] <strong>value type in structure doesn't match signature spec</strong><dd>
A value component of a structure has a different type than that
specified in a signature that the structure is matched against.
<pre>
  signature S =
  sig
    val x : int
  end;
  <i>signature S = sig val x : int end</i>

  structure A : S =
  struct
    val x = true
  end;
  <i>stdIn:21.1-24.4 Error: value type in structure doesn't match signature spec
      name: x
    spec:   int
    actual: bool</i>
</pre>

<dt>[102] <strong>variable % does not occur in all branches of or-pattern</strong><dd>
SML/NJ supports or-patterns, where a single rule can have several patterns
separated with the <code><strong>|</strong></code> symbol.  The
component patterns of an or-pattern are required to have exactly the
same variables with the same types.
<pre>
  fun f(nil | x::_) = 1;
  <i>stdIn:1.5-2.18 Error: variable x does not occur in all branches of or-pattern</i>
</pre>
Here the component patterns are <code>nil</code> and
<code>x::_</code>, and the variable <code>x</code> doesn't
occur in the first pattern.
<p>

<dt>[103] <strong>variable found where constructor is required: %</strong><dd>
A symbolic path (longid) of length greater than 1 occurring in a
pattern must designate a data constructor.
<pre>
  fun f(Int.+) = 3;
  <i>stdIn:1.5-2.12 Error: variable found where constructor is required: Int.+</i>
</pre>

<dt>[104] <strong>vector expression type failure</strong><dd>
In a vector expression of the form
<code>#[<i>exp<sub>1</sub></i>,exp<sub>2</sub></i>,...]</code>,
all the vector element expressions must be of the same type.
<pre>
  #[1,true];
  <i>stdIn:1.1-2.5 Error: vector expression type failure [literal]</i>

  fun f(x:int) = #[x,true];
  <i>stdIn:2.11-2.20 Error: vector expression type failure [tycon mismatch]</i>
</pre>

<dt>[105] <strong>vector pattern type failure</strong><dd>
In a vector pattern of the form
<code>#[<i>pat<sub>1</sub></i>,pat<sub>2</sub></i>,...]</code>,
all the vector element patterns must be of the same type.
<pre>
  fun f(#[x:int,y:bool]) = (x + 1; not y);
  <i>stdIn:1.1-2.35 Error: vector pattern type failure [tycon mismatch]</i>
</pre>

<dt>[106] <strong>where defn applied to definitional spec</strong><dd>
SML/NJ does not allow multiple definitions of a structure in a signature
(one through a definitional spec, another through a
<code><strong>where</strong></code> clause).
<pre>
  structure A = struct end;
  <i>structure A : sig end</i>

  signature S =
  sig
    structure X : sig end = A
  end
  where X = A;
  <i>stdIn:27.1-31.12 Error: where defn applied to definitional spec</i>
</pre>

<dt>[107] <strong>where type definition has wrong arity: %</strong><dd>
The arity implied by a <code><strong>where type</strong></code>
definition must agree with the arity in type specification that
it applies to.
<pre>
  signature S =
  sig
    type 'a t
  end
  where type t = int;
  <i>stdIn:1.1-26.19 Error: where type definition has wrong arity: t</i>
</pre>

<dt>[108] <strong>where type defn applied to definitional spec: %</strong><dd>
SML/NJ does not allow multiple definitions of a type in a signature
(one through a definitional spec, another through a
<code><strong>where type</strong></code> clause).
<pre>
  signature S =
  sig
    type t = int
  end
  where type t = int;
  <i>stdIn:1.1-22.19 Error: where type defn applied to definitional spec: t</i>
</pre>

<dt>[109] <strong>withtype not allowed in datatype replication</strong><dd>
One can't attach a <code><strong>withtype</strong></code> clause to a
datatype replication declaration or specification.
<pre>
  datatype t = A;
  <i>datatype t = A</i>

  datatype s = datatype t
  withtype u = s list;
  <i>stdIn:37.1-38.20 Error: withtype not allowed in datatype replication</i>
</pre>

<dt>[110] <strong>word constant too large</strong><dd>
Word constants (by default Word31.word) are limited to values less
than <code>0w2147483648</code> (<code>0wx80000000</code>).  Similarly
for word literals of type Word32.word (bound <code>0w4294967296</code>)
and Word8.word (bound 0w256).
<pre>
  0w2147483648;
  <i>stdIn:1.1-18.3 Error: word constant too large</i>
  0wx80000000;
  <i>stdIn:1.1-18.2 Error: word constant too large</i>

  0w4294967296 : Word32.word;
  <i>stdIn:25.1-25.13 Error: word constant too large</i>
  0wx100000000 : Word32.word;
  <i>stdIn:23.1-23.13 Error: word constant too large</i>

  0w256: Word8.word;
  <i>stdIn:1.1-1.6 Error: word constant too large</i>
  0wx100 : Word8.word;
  <i>stdIn:1.1-24.2 Error: word constant too large</i>
</pre>
</dl>

<h3>Warnings</h3>
<dl>
<dt>[1] <strong>match nonexhaustive</strong><dd>
Insufficient patterns in clause to match against all the 
possible inputs. This is an warning if the flag
<code>Compiler.Control.MC.matchNonExhaustiveError</code>
is set to <code>false</code> (the default), 
<code>Compiler.Control.MC.matchNonExhaustiveWarn</code>
is set to true.  If neither of these flags is true, then
the compiler does not complain about nonexhaustive matches.
<pre>
  fun f 0 = 1
    | f 1 = 1;
  <i>stdIn:1.1-22.12 Warning: match nonexhaustive
	    0 => ...
	    1 => ...

  val f = fn : int -> int</i>
</pre>

<dt>[2] <strong>match redundant</strong><dd>
A pattern is provided that is covered by some earlier pattern. 
This is a warning if the compiler flag 
<code>Compiler.Control.MC.matchRedundantError</code>
is set to false (default is true) and
<code>Compiler.Control.MC.matchRedundantWarn</code>
is <code>true</code> (the default).
<pre>	
  fun f (0, true) = 1
    | f (0, false) = 2
    | f (0, _) = 3
    | f _ = 4;
  <i>stdIn:24.1-27.14 Warning: match redundant
	    (0,true) => ...
	    (0,false) => ...
      -->   (0,_) => ...
	    _ => ...</i>
</pre>  

<dt>[3] <strong>match redundant and nonexhaustive</strong><dd>
A pattern is provided that is covered by some earlier pattern, 
and the set of patterns do not cover all the possible inputs.
Whether this message is generated, and its severity (Error or
Warning), are controlled by the compiler flags
<pre>
    <code>Compiler.Control.MC.matchNonExhaustiveError</code>
    <code>Compiler.Control.MC.matchNonExhaustiveWarn</code>
    <code>Compiler.Control.MC.matchRedundantError</code>
    <code>Compiler.Control.MC.matchRedundantWarn</code>
</pre>
If the first two are set to false and the latter
two are set to true, then this warning is generated.
<pre>
  fun f 1 = 1
    | f 2 = 3
    | f 1 = 4 ;
  <i>stdIn:1.1-24.12 Warning: match redundant and nonexhaustive
	    1 => ...
	    2 => ...
      -->   1 => ...</i>
</pre>

<dt>[4] <strong>mixed left- and right-associative operators of same precedence</strong><dd>
If an infix expression like
<pre>
  <i>aexp id<sub>1</sub> aexp id<sub>2</sub> aexp</i>
</pre>
involves two infix operators <code><i>id<sub>1</sub></i></code> and
<code><i>id<sub>2</sub></i></code> of the same precedence but opposite
associativity, the SML '97 Definition states that the expression is illegal.
But SML/NJ only issues this warning message and associates the
two operators to the left.
<pre>
  - infix 4 <<;
  infix 4 <<
  - infixr 4 >>;
  infixr 4 >>
  - fun (x>>y) = "right";
  val >> = fn : 'a * 'b -> string
  - fun (x&lt;&lt;y) = "left";
  val << = fn : 'a * 'b -> string
  - 1 << 2 >> 3;
  stdIn:21.8-21.10 Warning: mixed left- and right-associative operators of same precedence
  val it = "right" : string
  - 1 >> 2 << 3;
  stdIn:22.8-22.10 Warning: mixed left- and right-associative operators of same precedence
  val it = "left" : string
</pre>

<dt>[5] <strong>nongeneralizable type variable</strong><dd>
This warning is given for a top level value declaration whose
type has free type variables that cannot be generalized because
of the <em>value restriction</em>.  See the detailed discussion of the
value restriction in the
<a href="Conversion/index.html">SML '97 Conversion Guide</a>.
<pre>
  val x = (fn x => x) nil;
  <i>stdIn:17.1-17.24 Warning: type vars not generalized because of
     value restriction are instantiated to dummy types (X1,X2,...)
  val x = [] : ?.X1 list</i>
</pre>
In this example, the right hand side of the declaration of <code>x</code>
has type <code>'X list</code>, where <code>'X</code> is a free type
variable.  This type variable cannot be generalized to form a
polymorphic type for <code>x</code> because the right hand expression
is <em>expansive</em> (a function call in this case).  So the compiler
eliminates the free type variable <code>'X</code> be inventing a new
dummy type named <code>X1</code> and instantiates <code>'X</code> to
<code>X1</code>.  Since <code>X1</code> won't match any other type,
there is little one can do with <code>x</code> now (one could take
its lenght (0), but one cannot cons any values onto <code>x</code>).
</dl>

<HR>
<CENTER><STRONG>
| <A HREF="../index.html">SML/NJ Home Page</A> | <br>
| <A HREF="index.html">SML/NJ Documentation Home Page</A> |
</STRONG></CENTER>
<HR>
Send your comments to <img src="../smlnj-list-logo.png" align=center>.<br>
<FONT SIZE="-3">
  Copyright &#169; 1998,
  <A HREF="http://www.lucent.com/">Lucent Technologies; Bell Laboratories</A>.
  <BR>
</FONT>
</BODY>
</HTML>
