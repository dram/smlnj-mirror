<!-- HTML/list-pair.html -->

<!-- COPYRIGHT (c) 1997 Bell Labs, Lucent Technologies. -->

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>The ListPair structure</TITLE>
</HEAD>
<BODY>
<A NAME="top"></A>
<H1 align=CENTER>The Standard ML Basis Library</H1>
<HR>


<H3>The <CODE>ListPair</CODE> structure</H3>
<P>
The ListPair structure provides operations on pairs of lists. These operations do not require that the lists have the same length; when the lists are of uneven lengths, the excess elements from the tail of the longer list are ignored. 
<HR>
<H4>Synopsis</H4>
<BLOCKQUOTE>
<CODE><B>signature </B><A NAME="LIST_PAIR:SIG:SPEC"><CODE>LIST_PAIR</CODE></A><BR>
<B>structure </B><A NAME="ListPair:STR:SPEC"><CODE>ListPair</CODE></A><B> : </B>LIST_PAIR<BR>
</CODE>
</BLOCKQUOTE>
<HR>
<H4>Interface</H4>
<BLOCKQUOTE>
<CODE><B>val</B> <A NAME="SIG:LIST_PAIR.zip:VAL:SPEC" HREF="#SIG:LIST_PAIR.zip:VAL">zip</A> <B>:</B> ('a list * 'b list) -&gt; ('a * 'b) list     <BR>
<B>val</B> <A NAME="SIG:LIST_PAIR.unzip:VAL:SPEC" HREF="#SIG:LIST_PAIR.unzip:VAL">unzip</A> <B>:</B> ('a * 'b) list -&gt; ('a list * 'b list)     <BR>
<B>val</B> <A NAME="SIG:LIST_PAIR.map:VAL:SPEC" HREF="#SIG:LIST_PAIR.map:VAL">map</A> <B>:</B> ('a * 'b -&gt; 'c) -&gt; ('a list * 'b list) -&gt; 'c list     <BR>
<B>val</B> <A NAME="SIG:LIST_PAIR.app:VAL:SPEC" HREF="#SIG:LIST_PAIR.app:VAL">app</A> <B>:</B> ('a * 'b -&gt; unit) -&gt; ('a list * 'b list) -&gt; unit     <BR>
<B>val</B> <A NAME="SIG:LIST_PAIR.foldl:VAL:SPEC" HREF="#SIG:LIST_PAIR.foldl:VAL">foldl</A> <B>:</B> (('a * 'b * 'c) -&gt; 'c) -&gt; 'c -&gt; ('a list * 'b list) -&gt; 'c       <BR>
<B>val</B> <A NAME="SIG:LIST_PAIR.foldr:VAL:SPEC" HREF="#SIG:LIST_PAIR.foldl:VAL">foldr</A> <B>:</B> (('a * 'b * 'c) -&gt; 'c) -&gt; 'c -&gt; ('a list * 'b list) -&gt; 'c         <BR>
<B>val</B> <A NAME="SIG:LIST_PAIR.all:VAL:SPEC" HREF="#SIG:LIST_PAIR.all:VAL">all</A> <B>:</B> ('a * 'b -&gt; bool) -&gt; ('a list * 'b list) -&gt; bool   <BR>
<B>val</B> <A NAME="SIG:LIST_PAIR.exists:VAL:SPEC" HREF="#SIG:LIST_PAIR.all:VAL">exists</A> <B>:</B> ('a * 'b -&gt; bool) -&gt; ('a list * 'b list) -&gt; bool     <BR>
</CODE>
</BLOCKQUOTE>
<H4>Description</H4>
<DL>
<DT> <A NAME="SIG:LIST_PAIR.zip:VAL"><CODE>zip (<VAR>l1</VAR>, <VAR>l2</VAR>)
      </CODE></A>
<DD>
combines the two lists <VAR>l1</VAR> and <VAR>l2</VAR> into a list of pairs, with       the first element of each list comprising the first element of the result,       the second elements comprising the second element of the result, and so on.       If the lists are of unequal lengths, the excess elements from the tail       of the longer one are ignored.   
<BR>
<BR>

<DT> <A NAME="SIG:LIST_PAIR.unzip:VAL"><CODE>unzip <VAR>l</VAR>
      </CODE></A>
<DD>
returns a pair of lists formed by splitting the elements of <VAR>l</VAR>.       This is the inverse of <CODE>zip</CODE> for equal length lists.   
<BR>
<BR>

<DT> <A NAME="SIG:LIST_PAIR.map:VAL"><CODE>map <VAR>f</VAR> (<VAR>l1</VAR>, <VAR>l2</VAR>)
      </CODE></A>
<DD>
maps the function <VAR>f</VAR> over the list of pairs of elements from       the lists <VAR>l1</VAR> and <VAR>l2</VAR>, returning the list of results.       If the lists are of unequal lengths, the excess elements from the tail       of the longer one are ignored.       The above expression is equivalent to:       <CODE><A HREF="list.html#SIG:LIST.map:VAL:SPEC">List.map</A> <VAR>f</VAR> (zip (<VAR>l1</VAR>, <VAR>l2</VAR>))</CODE>.   
<BR>
<BR>

<DT> <A NAME="SIG:LIST_PAIR.app:VAL"><CODE>app <VAR>f</VAR> (<VAR>l1</VAR>, <VAR>l2</VAR>)
      </CODE></A>
<DD>
applies the function <VAR>f</VAR> to the list of pairs of elements from       from the lists <VAR>l1</VAR> and <VAR>l2</VAR>.       If the lists are of unequal lengths, the excess elements from the tail       of the longer one are ignored.       The above expression is equivalent to:       <CODE><A HREF="list.html#SIG:LIST.app:VAL:SPEC">List.app</A> <VAR>f</VAR> (zip (<VAR>l1</VAR>, <VAR>l2</VAR>))</CODE>.     
<BR>
<BR>

<DT> <A NAME="SIG:LIST_PAIR.foldl:VAL"><CODE>foldl <VAR>f</VAR> <VAR>c</VAR> (<VAR>l1</VAR>, <VAR>l2</VAR>)
          </CODE></A>
<DT> <CODE>          foldr <VAR>f</VAR> <VAR>c</VAR> (<VAR>l1</VAR>, <VAR>l2</VAR>)
          </CODE>
<DD>
return the result of folding the function <VAR>f</VAR> over the pair of       lists <VAR>l1</VAR> and <VAR>l2</VAR>.       They are respectively equivalent to:       <CODE><A HREF="list.html#SIG:LIST.foldl:VAL:SPEC">List.foldl</A> <VAR>f'</VAR> <VAR>c</VAR> (zip (<VAR>l1</VAR>, <VAR>l2</VAR>))</CODE>       and       <CODE><A HREF="list.html#SIG:LIST.foldr:VAL:SPEC">List.foldr</A> <VAR>f'</VAR> <VAR>c</VAR> (zip (<VAR>l1</VAR>, <VAR>l2</VAR>))</CODE>       where <VAR>f'</VAR> is <CODE>fn ((a,b),c) =&gt; f(a,b,c)</CODE>.   
<BR>
<BR>

<DT> <A NAME="SIG:LIST_PAIR.all:VAL"><CODE>all <VAR>pred</VAR> (<VAR>l1</VAR>, <VAR>l2</VAR>)
      </CODE></A>
<DT> <CODE>        exists <VAR>pred</VAR> (<VAR>l1</VAR>, <VAR>l2</VAR>)
      </CODE>
<DD>
These functions provide short-circuit testing of a predicate       over a pair of lists.       They are respectively equivalent to:       <CODE><A HREF="list.html#SIG:LIST.all:VAL:SPEC">List.all</A> <VAR>pred</VAR> (zip (<VAR>l1</VAR>, <VAR>l2</VAR>))</CODE>       and       <CODE><A HREF="list.html#SIG:LIST.exists:VAL:SPEC">List.exists</A> <VAR>pred</VAR> (zip (<VAR>l1</VAR>, <VAR>l2</VAR>))</CODE>.   
<BR>
<BR>

</DL>
<HR>
<H4>Discussion</H4>
<BLOCKQUOTE>
<B>Rationale:</B><BR>

<P>
Another approach to these functions is to raise an exception when the       argument lists are of uneven length.       We chose not to do this, because comparing the lists for length conflicts       with the short-circuit evaluation of <CODE>all</CODE> and <CODE>exists</CODE>.     
</BLOCKQUOTE>
    
<H4>See Also</H4>
<BLOCKQUOTE>
<A HREF="list.html#List:STR:SPEC">List</A>
</BLOCKQUOTE>


<HR>
<CENTER>
<B>[ <A HREF="index-all.html">INDEX</A> | <A HREF="#top">TOP</A>
   | <A HREF="list-chapter.html">Parent</A> | <A HREF="sml-std-basis.html">Root</A>
   ]</B>
</CENTER>
<P>
<I>Last Modified April 8, 1996</I><BR>
<I>Comments to <A HREF="mailto:jhr@research.bell-labs.com">John Reppy.</A></I><BR>

Copyright &copy; 1997 Bell Labs, Lucent Technologies <BR>

<HR>
</BODY>
</HTML>
