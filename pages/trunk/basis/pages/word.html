<!-- HTML/word.html -->

<!-- COPYRIGHT (c) 1997 Bell Labs, Lucent Technologies. -->

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>The WORD signature</TITLE>
</HEAD>
<BODY>
<A NAME="top"></A>
<H1 align="CENTER">The Standard ML Basis Library</H1>
<HR>


<H3>The <CODE>WORD</CODE> signature</H3>
<P>
Instances of the signature WORD provide a type of unsigned integers with arithmetic and logical operations and conversion operations.  They are also meant to give efficient access to the primitive machine word types of the underlying hardware. 
<P>
Note: In this text, a bit ordering is assumed as follows: The most significant bit (MSB) is the leftmost, the least significant bit the rightmost bit.  This does not touch the semantics of the operations, but the (intuitive) description of the shift operators. 
<HR>
<H4>Synopsis</H4>
<BLOCKQUOTE>
<CODE><B>signature </B><A NAME="WORD:SIG:SPEC"><CODE>WORD</CODE></A><BR>
<B>structure </B><A NAME="Word:STR:SPEC"><CODE>Word</CODE></A><B> : </B>WORD<BR>
<B>structure </B><A NAME="Word8:STR:SPEC"><CODE>Word8</CODE></A><B> : </B>WORD<BR>
<B>structure </B><A NAME="LargeWord:STR:SPEC"><CODE>LargeWord</CODE></A><B> : </B>WORD<BR>
<B>structure </B><A NAME="Word{N}:STR:SPEC"><CODE>Word{N}</CODE></A><B> : </B>WORD<BR>
<B>structure </B><A NAME="SysWord:STR:SPEC"><CODE>SysWord</CODE></A><B> : </B>WORD<BR>
</CODE>
</BLOCKQUOTE>
<HR>
<H4>Interface</H4>
<BLOCKQUOTE>
<CODE><B>eqtype</B> <A NAME="SIG:WORD.word:TY:SPEC" HREF="#SIG:WORD.word:TY">word</A><BR>
<B>val</B> <A NAME="SIG:WORD.wordSize:VAL:SPEC" HREF="#SIG:WORD.wordSize:VAL">wordSize</A> <B>:</B> int         <BR>
<B>val</B> <A NAME="SIG:WORD.toLargeWord:VAL:SPEC" HREF="#SIG:WORD.toLargeWord:VAL">toLargeWord</A> <B>:</B> word -&gt; LargeWord.word       <BR>
<B>val</B> <A NAME="SIG:WORD.toLargeWordX:VAL:SPEC" HREF="#SIG:WORD.toLargeWord:VAL">toLargeWordX</A> <B>:</B> word -&gt; LargeWord.word         <BR>
<B>val</B> <A NAME="SIG:WORD.fromLargeWord:VAL:SPEC" HREF="#SIG:WORD.fromLargeWord:VAL">fromLargeWord</A> <B>:</B> LargeWord.word -&gt; word         <BR>
<B>val</B> <A NAME="SIG:WORD.toLargeInt:VAL:SPEC" HREF="#SIG:WORD.toLargeInt:VAL">toLargeInt</A> <B>:</B> word -&gt; LargeInt.int         <BR>
<B>val</B> <A NAME="SIG:WORD.toLargeIntX:VAL:SPEC" HREF="#SIG:WORD.toLargeInt:VAL">toLargeIntX</A> <B>:</B> word -&gt; LargeInt.int         <BR>
<B>val</B> <A NAME="SIG:WORD.fromLargeInt:VAL:SPEC" HREF="#SIG:WORD.fromLargeInt:VAL">fromLargeInt</A> <B>:</B> LargeInt.int -&gt; word         <BR>
<B>val</B> <A NAME="SIG:WORD.toInt:VAL:SPEC" HREF="#SIG:WORD.toInt:VAL">toInt</A> <B>:</B> word -&gt; Int.int         <BR>
<B>val</B> <A NAME="SIG:WORD.toIntX:VAL:SPEC" HREF="#SIG:WORD.toInt:VAL">toIntX</A> <B>:</B> word -&gt; Int.int         <BR>
<B>val</B> <A NAME="SIG:WORD.fromInt:VAL:SPEC" HREF="#SIG:WORD.fromInt:VAL">fromInt</A> <B>:</B> Int.int -&gt; word         <BR>
<B>val</B> <A NAME="SIG:WORD.orb:VAL:SPEC" HREF="#SIG:WORD.orb:VAL">orb</A> <B>:</B> (word * word) -&gt; word         <BR>
<B>val</B> <A NAME="SIG:WORD.xorb:VAL:SPEC" HREF="#SIG:WORD.xorb:VAL">xorb</A> <B>:</B> (word * word) -&gt; word         <BR>
<B>val</B> <A NAME="SIG:WORD.andb:VAL:SPEC" HREF="#SIG:WORD.andb:VAL">andb</A> <B>:</B> (word * word) -&gt; word         <BR>
<B>val</B> <A NAME="SIG:WORD.notb:VAL:SPEC" HREF="#SIG:WORD.notb:VAL">notb</A> <B>:</B> word -&gt; word         <BR>
<B>val</B> <A NAME="SIG:WORD.\|@LT\|\|@LT\|:VAL:SPEC" HREF="#SIG:WORD.\|@LT\|\|@LT\|:VAL">&lt;&lt;</A> <B>:</B> (word * Word.word) -&gt; word         <BR>
<B>val</B> <A NAME="SIG:WORD.\|@GT\|\|@GT\|:VAL:SPEC" HREF="#SIG:WORD.\|@GT\|\|@GT\|:VAL">&gt;&gt;</A> <B>:</B> (word * Word.word) -&gt; word         <BR>
<B>val</B> <A NAME="SIG:WORD.~\|@GT\|\|@GT\|:VAL:SPEC" HREF="#SIG:WORD.~\|@GT\|\|@GT\|:VAL">~&gt;&gt;</A> <B>:</B> (word * Word.word) -&gt; word         <BR>
<B>val</B> <A NAME="SIG:WORD.+:VAL:SPEC" HREF="#SIG:WORD.+:VAL">+</A> <B>:</B> (word * word) -&gt; word         <BR>
<B>val</B> <A NAME="SIG:WORD.-:VAL:SPEC" HREF="#SIG:WORD.-:VAL">-</A> <B>:</B> (word * word) -&gt; word         <BR>
<B>val</B> <A NAME="SIG:WORD.*:VAL:SPEC" HREF="#SIG:WORD.*:VAL">*</A> <B>:</B> (word * word) -&gt; word         <BR>
<B>val</B> <A NAME="SIG:WORD.div:VAL:SPEC" HREF="#SIG:WORD.div:VAL">div</A> <B>:</B> (word * word) -&gt; word 	<BR>
<B>val</B> <A NAME="SIG:WORD.mod:VAL:SPEC" HREF="#SIG:WORD.mod:VAL">mod</A> <B>:</B> (word * word) -&gt; word 	<BR>
<B>val</B> <A NAME="SIG:WORD.compare:VAL:SPEC" HREF="#SIG:WORD.compare:VAL">compare</A> <B>:</B> (word * word) -&gt; order         <BR>
<B>val</B> <A NAME="SIG:WORD.\|@GT\|:VAL:SPEC" HREF="#SIG:WORD.\|@GT\|:VAL">&gt;</A> <B>:</B> (word * word) -&gt; bool       <BR>
<B>val</B> <A NAME="SIG:WORD.\|@LT\|:VAL:SPEC" HREF="#SIG:WORD.\|@GT\|:VAL">&lt;</A> <B>:</B> (word * word) -&gt; bool       <BR>
<B>val</B> <A NAME="SIG:WORD.\|@GTE\|:VAL:SPEC" HREF="#SIG:WORD.\|@GT\|:VAL">&gt;=</A> <B>:</B> (word * word) -&gt; bool       <BR>
<B>val</B> <A NAME="SIG:WORD.\|@LTE\|:VAL:SPEC" HREF="#SIG:WORD.\|@GT\|:VAL">&lt;=</A> <B>:</B> (word * word) -&gt; bool         <BR>
<B>val</B> <A NAME="SIG:WORD.min:VAL:SPEC" HREF="#SIG:WORD.min:VAL">min</A> <B>:</B> (word * word) -&gt; word       <BR>
<B>val</B> <A NAME="SIG:WORD.max:VAL:SPEC" HREF="#SIG:WORD.min:VAL">max</A> <B>:</B> (word * word) -&gt; word         <BR>
<B>val</B> <A NAME="SIG:WORD.fmt:VAL:SPEC" HREF="#SIG:WORD.fmt:VAL">fmt</A> <B>:</B> StringCvt.radix -&gt; word -&gt; string         <BR>
<B>val</B> <A NAME="SIG:WORD.toString:VAL:SPEC" HREF="#SIG:WORD.toString:VAL">toString</A> <B>:</B> word -&gt; string         <BR>
<B>val</B> <A NAME="SIG:WORD.fromString:VAL:SPEC" HREF="#SIG:WORD.fromString:VAL">fromString</A> <B>:</B> string -&gt; word option 	<BR>
<B>val</B> <A NAME="SIG:WORD.scan:VAL:SPEC" HREF="#SIG:WORD.scan:VAL">scan</A> <B>:</B> StringCvt.radix -&gt; (char, 'a) StringCvt.reader -&gt; 'a -&gt; (word, 'a) option 	<BR>
</CODE>
</BLOCKQUOTE>
<H4>Description</H4>
<DL>
<DT> <A NAME="SIG:WORD.word:TY"><CODE><B>eqtype</B> word</CODE></A>
<DD>
<BR>

<DT> <A NAME="SIG:WORD.wordSize:VAL"><CODE>wordSize
          </CODE></A>
<DD>
is the number of bits in type <A HREF="#SIG:WORD.word:TY:SPEC">word</A>.  <A HREF="#SIG:WORD.wordSize:VAL:SPEC">wordSize</A> 	  need not be a power of two. Note that <A HREF="#SIG:WORD.word:TY:SPEC">word</A> has a fixed, finite           precision.     
<BR>
<BR>

<DT> <A NAME="SIG:WORD.toLargeWord:VAL"><CODE>toLargeWord <VAR>w</VAR>
          </CODE></A>
<DT> <CODE>          toLargeWordX <VAR>w</VAR>
          </CODE>
<DD>
convert <VAR>w</VAR> to a value of type <A HREF="#SIG:WORD.word:TY:SPEC">LargeWord.word</A>.           In the former case, <VAR>w</VAR> is converted to its equivalent           <A HREF="#SIG:WORD.word:TY:SPEC">LargeWord.word</A> value           in the range [0,2<SUP>(<CODE>wordSize</CODE>)</SUP>-1].           In the latter case, <VAR>w</VAR> is ``sign-extended,'' i.e.,           the <A HREF="#SIG:WORD.wordSize:VAL:SPEC">wordSize</A> low-order bits of <VAR>w</VAR> and           <CODE><A HREF="#SIG:WORD.toLargeWordX:VAL:SPEC">toLargeWordX</A> <VAR>w</VAR></CODE> are the same, and the           remaining bits of <CODE><A HREF="#SIG:WORD.toLargeWordX:VAL:SPEC">toLargeWordX</A> <VAR>w</VAR></CODE> are           all equal to the most significant bit of <VAR>w</VAR>.     
<BR>
<BR>

<DT> <A NAME="SIG:WORD.fromLargeWord:VAL"><CODE>fromLargeWord <VAR>w</VAR>
          </CODE></A>
<DD>
converts <VAR>w</VAR> of the type <A HREF="#SIG:WORD.word:TY:SPEC">LargeWord.word</A> to the            value <VAR>w</VAR> <CODE>modulo</CODE> 2<SUP>(<CODE>wordSize</CODE>)</SUP>            of type <A HREF="#SIG:WORD.word:TY:SPEC">word</A>.     
<BR>
<BR>

<DT> <A NAME="SIG:WORD.toLargeInt:VAL"><CODE>toLargeInt <VAR>w</VAR>
          </CODE></A>
<DT> <CODE>          toLargeIntX <VAR>w</VAR>
          </CODE>
<DD>
convert <VAR>w</VAR> to a value of type <A HREF="integer.html#SIG:INTEGER.int:TY:SPEC">LargeInt.int</A>.           In the former case, <VAR>w</VAR> is viewed as an integer value           in the range [0,2<SUP>(<CODE>wordSize</CODE>)</SUP>-1].           In the latter case, <VAR>w</VAR> is treated as a 2's complement           signed integer with <A HREF="#SIG:WORD.wordSize:VAL:SPEC">wordSize</A> precision, thereby           having a value in the range            [-2<SUP>(<CODE>wordSize</CODE>-1)</SUP>,2<SUP>(<CODE>wordSize</CODE>-1)</SUP>-1].           <A HREF="#SIG:WORD.toLargeInt:VAL:SPEC">toLargeInt</A> raises <A HREF="general.html#SIG:GENERAL.Overflow:EXN:SPEC">Overflow</A> if the target            integer value cannot           be represented as a <A HREF="integer.html#SIG:INTEGER.int:TY:SPEC">LargeInt.int</A>.           Since the precision of <A HREF="integer.html#SIG:INTEGER.int:TY:SPEC">LargeInt.int</A> is always at           least <A HREF="#SIG:WORD.wordSize:VAL:SPEC">wordSize</A>, <A HREF="#SIG:WORD.toLargeIntX:VAL:SPEC">toLargeIntX</A> will never           raise an exception.     
<BR>
<BR>

<DT> <A NAME="SIG:WORD.fromLargeInt:VAL"><CODE>fromLargeInt <VAR>i</VAR>
          </CODE></A>
<DD>
converts <VAR>i</VAR> of the type <A HREF="integer.html#SIG:INTEGER.int:TY:SPEC">LargeInt.int</A> to a            value of type <A HREF="#SIG:WORD.word:TY:SPEC">word</A>. This has the effect of           taking the low-order <A HREF="#SIG:WORD.wordSize:VAL:SPEC">wordSize</A> bits of the two's           complement representation of <VAR>i</VAR>.     
<BR>
<BR>

<DT> <A NAME="SIG:WORD.toInt:VAL"><CODE>toInt <VAR>w</VAR>
          </CODE></A>
<DT> <CODE>          toIntX <VAR>w</VAR>
          </CODE>
<DD>
convert <VAR>w</VAR> to a value of default integer type.           In the former case, <VAR>w</VAR> is viewed as an integer value           in the range [0,2<SUP>(<CODE>wordSize</CODE>)</SUP>-1].           In the latter case, <VAR>w</VAR> is treated as a 2's complement           signed integer with <A HREF="#SIG:WORD.wordSize:VAL:SPEC">wordSize</A> precision, thereby           having a value in the range            [-2<SUP>(<CODE>wordSize</CODE>-1)</SUP>,2<SUP>(<CODE>wordSize</CODE>-1)</SUP>-1].           Raise <A HREF="general.html#SIG:GENERAL.Overflow:EXN:SPEC">Overflow</A> if the target integer value cannot           be represented as an <A HREF="integer.html#SIG:INTEGER.int:TY:SPEC">Int.int</A>.     
<BR>
<BR>

<DT> <A NAME="SIG:WORD.fromInt:VAL"><CODE>fromInt <VAR>i</VAR>
          </CODE></A>
<DD>
converts <VAR>i</VAR> of the default integer type to a            value of type <A HREF="#SIG:WORD.word:TY:SPEC">word</A>. This has the effect of           taking the low-order <A HREF="#SIG:WORD.wordSize:VAL:SPEC">wordSize</A> bits of the two's           complement representation of <VAR>i</VAR>. If the precision of           <A HREF="integer.html#SIG:INTEGER.int:TY:SPEC">Int.int</A> is less            than <A HREF="#SIG:WORD.wordSize:VAL:SPEC">wordSize</A>, then <VAR>i</VAR> is sign-extended           to <A HREF="#SIG:WORD.wordSize:VAL:SPEC">wordSize</A> bits.     
<BR>
<BR>

<DT> <A NAME="SIG:WORD.orb:VAL"><CODE>orb (<VAR>i</VAR>, <VAR>j</VAR>)
          </CODE></A>
<DD>
returns the bit-wise OR of <VAR>i</VAR> and <VAR>j</VAR>.     
<BR>
<BR>

<DT> <A NAME="SIG:WORD.xorb:VAL"><CODE>xorb (<VAR>i</VAR>, <VAR>j</VAR>)
          </CODE></A>
<DD>
returns the bit-wise exclusive OR of <VAR>i</VAR> 	  and <VAR>j</VAR>.     
<BR>
<BR>

<DT> <A NAME="SIG:WORD.andb:VAL"><CODE>andb (<VAR>i</VAR>, <VAR>j</VAR>)
          </CODE></A>
<DD>
returns the bit-wise AND of <VAR>i</VAR> and <VAR>j</VAR>.     
<BR>
<BR>

<DT> <A NAME="SIG:WORD.notb:VAL"><CODE>notb <VAR>i</VAR>
          </CODE></A>
<DD>
returns the bit-wise complement (NOT) of <VAR>i</VAR>.     
<BR>
<BR>

<DT> <A NAME="SIG:WORD.\|@LT\|\|@LT\|:VAL"><CODE>&lt;&lt; (<VAR>i</VAR>, <VAR>n</VAR>)
          </CODE></A>
<DD>
shifts <VAR>i</VAR> to the left by <VAR>n</VAR> bit positions, filling 	  in zeros from the right.  When <VAR>i</VAR> and <VAR>n</VAR> are 	  interpreted as unsigned binary numbers, returns 	  (<VAR>i</VAR> * 2<SUP>(<VAR>n</VAR>)</SUP>) mod (2 <SUP>(<CODE>wordSize</CODE>)</SUP>).           In particular, shifting by greater than or equal to the word           size results in 0.  	  This operation is similar to the ``(logical) shift left'' 	  instruction in many processors.     
<BR>
<BR>

<DT> <A NAME="SIG:WORD.\|@GT\|\|@GT\|:VAL"><CODE>&gt;&gt; (<VAR>i</VAR>, <VAR>n</VAR>)
          </CODE></A>
<DD>
shifts <VAR>i</VAR> to the right by <VAR>n</VAR> bit positions, filling 	  in zeros from the left.  When <VAR>i</VAR> and <VAR>n</VAR> are 	  interpreted as unsigned binary numbers, returns 	  <CODE>floor</CODE> (<VAR>i</VAR> / 2<SUP>(<VAR>n</VAR>)</SUP>).           In particular, shifting by greater than or equal to the word           size results in 0.  	  This operation is similar to the ``logical shift right'' 	  instruction in many processors.     
<BR>
<BR>

<DT> <A NAME="SIG:WORD.~\|@GT\|\|@GT\|:VAL"><CODE>~&gt;&gt; (<VAR>i</VAR>, <VAR>n</VAR>)
          </CODE></A>
<DD>
shifts <VAR>i</VAR> to the right by <VAR>n</VAR> bit positions.  The 	  value of the leftmost bit (the MSB) of <VAR>i</VAR> is filled in 	  from the left; in a two's-complement interpretation this 	  corresponds to sign extension. 	  When <VAR>i</VAR> is interpreted as a <A HREF="#SIG:WORD.wordSize:VAL:SPEC">wordSize</A>-bit 	  twos-complement integer and <VAR>n</VAR> is interpreted as an 	  unsigned binary number, returns            <CODE>floor</CODE> (<VAR>i</VAR> / 2<SUP>(<VAR>n</VAR>)</SUP>).           In particular, shifting by greater than or equal to the word           size results in either 0 or all 1's.  	  This operation is similar to the ``arithmetic shift right'' 	  instruction in many processors.     
<BR>
<BR>

<DT> <A NAME="SIG:WORD.+:VAL"><CODE><VAR>i</VAR> + <VAR>j</VAR>
          </CODE></A>
<DD>
When <VAR>i</VAR> and <VAR>j</VAR> are interpreted as unsigned binary 	  numbers, returns the sum of <VAR>i</VAR> and <VAR>j</VAR> modulo 	  (2<SUP>(<CODE>wordSize</CODE>)</SUP>).            Does <EM>not</EM> raise <A HREF="general.html#SIG:GENERAL.Overflow:EXN:SPEC">Overflow</A>.     
<BR>
<BR>

<DT> <A NAME="SIG:WORD.-:VAL"><CODE><VAR>i</VAR> - <VAR>j</VAR>
          </CODE></A>
<DD>
When <VAR>i</VAR> and <VAR>j</VAR> are interpreted as unsigned binary 	  numbers, returns the difference of <VAR>i</VAR> and <VAR>j</VAR> modulo 	  (2<SUP>(<CODE>wordSize</CODE>)</SUP>):           
<BLOCKQUOTE>
          (2<SUP>(<CODE>wordSize</CODE>)</SUP> + <VAR>i</VAR> - <VAR>j</VAR>) mod (2<SUP>(<CODE>wordSize</CODE>)</SUP>)           
</BLOCKQUOTE>
 	  Does <EM>not</EM> raise <A HREF="general.html#SIG:GENERAL.Overflow:EXN:SPEC">Overflow</A>.     
<BR>
<BR>

<DT> <A NAME="SIG:WORD.*:VAL"><CODE><VAR>i</VAR> * <VAR>j</VAR>
          </CODE></A>
<DD>
When <VAR>i</VAR> and <VAR>j</VAR> are interpreted as unsigned binary 	  numbers, returns the product of <VAR>i</VAR> and <VAR>j</VAR> modulo 	  (2<SUP>(<CODE>wordSize</CODE>)</SUP>). 	  Does <EM>not</EM> raise <A HREF="general.html#SIG:GENERAL.Overflow:EXN:SPEC">Overflow</A>.     
<BR>
<BR>

<DT> <A NAME="SIG:WORD.div:VAL"><CODE><VAR>i</VAR> div <VAR>j</VAR>
          </CODE></A>
<DD>
When <VAR>i</VAR> and <VAR>j</VAR> are interpreted as unsigned binary 	  numbers, returns the truncated quotient of <VAR>i</VAR> and 	  <VAR>j</VAR>: <CODE>floor</CODE> (<VAR>i</VAR> / <VAR>j</VAR>). 	  Raises <A HREF="general.html#SIG:GENERAL.Div:EXN:SPEC">Div</A> when <VAR>j</VAR> = 0.     
<BR>
<BR>

<DT> <A NAME="SIG:WORD.mod:VAL"><CODE><VAR>i</VAR> mod <VAR>j</VAR>
          </CODE></A>
<DD>
When <VAR>i</VAR> and <VAR>j</VAR> are interpreted as unsigned binary 	  numbers, returns the remainder of the division <VAR>i</VAR> by 	  <VAR>j</VAR>:            
<BLOCKQUOTE>
          <VAR>i</VAR> - <VAR>j</VAR> * <CODE>floor</CODE> (<VAR>i</VAR> / <VAR>j</VAR>).           
</BLOCKQUOTE>
 	  Raises <A HREF="general.html#SIG:GENERAL.Div:EXN:SPEC">Div</A> when <VAR>j</VAR> = 0.     
<BR>
<BR>

<DT> <A NAME="SIG:WORD.compare:VAL"><CODE>compare (<VAR>i</VAR>, <VAR>j</VAR>)
          </CODE></A>
<DD>
When <VAR>i</VAR> and <VAR>j</VAR> are interpreted as unsigned binary 	  numbers, returns <A HREF="general.html#SIG:GENERAL.order:TY:SPEC">LESS</A>, <A HREF="general.html#SIG:GENERAL.order:TY:SPEC">EQUAL</A>, or 	  <A HREF="general.html#SIG:GENERAL.order:TY:SPEC">GREATER</A> if and only if <VAR>i</VAR> is less than, equal to, or 	  greater than <VAR>j</VAR>, respectively.     
<BR>
<BR>

<DT> <A NAME="SIG:WORD.\|@GT\|:VAL"><CODE><VAR>i</VAR> &gt; <VAR>j</VAR>
          </CODE></A>
<DT> <CODE>          <VAR>i</VAR> &lt; <VAR>j</VAR>
          </CODE>
<DT> <CODE>          <VAR>i</VAR> &gt;= <VAR>j</VAR>
          </CODE>
<DT> <CODE>          <VAR>i</VAR> &lt;= <VAR>j</VAR>
          </CODE>
<DD>
return <CODE>true</CODE> if and only 	  <VAR>i</VAR> and <VAR>j</VAR> satisfy the given relation when           interpreted as unsigned binary numbers.     
<BR>
<BR>

<DT> <A NAME="SIG:WORD.min:VAL"><CODE>min (<VAR>i</VAR>, <VAR>j</VAR>)
          </CODE></A>
<DT> <CODE>          max (<VAR>i</VAR>, <VAR>j</VAR>)
          </CODE>
<DD>
returns the smaller (respectively, larger) of <VAR>i</VAR> and <VAR>j</VAR>.     
<BR>
<BR>

<DT> <A NAME="SIG:WORD.fmt:VAL"><CODE>fmt <VAR>radix</VAR> <VAR>i</VAR>
          </CODE></A>
<DD>
returns a string containing a numeric representation of <VAR>i</VAR> using 	  the given <VAR>radix</VAR>. No prefix <CODE>&quot;Ow&quot;</CODE>, <CODE>&quot;OwX&quot;</CODE>, etc. is           generated.           The hexadecimal digits 10-15 are represented as [A-F].      
<BR>
<BR>

<DT> <A NAME="SIG:WORD.toString:VAL"><CODE>toString <VAR>i</VAR>
          </CODE></A>
<DD>
returns a hexadecimal string representation of <VAR>i</VAR>.           It is equivalent to <CODE><A HREF="#SIG:WORD.fmt:VAL:SPEC">fmt</A> <A HREF="string-cvt.html#SIG:STRING_CVT.radix:TY:SPEC">StringCvt.HEX</A> <VAR>i</VAR></CODE>.     
<BR>
<BR>

<DT> <A NAME="SIG:WORD.fromString:VAL"><CODE>fromString <VAR>s</VAR>
          </CODE></A>
<DD>
returns <CODE>SOME w</CODE> if an unsigned hexadecimal number in the 	  format <CODE>(0wx|0wX|0x|0X)?[0-9a-fA-F]+</CODE> can be parsed from a 	  prefix of string <VAR>s</VAR>, ignoring initial whitespace;            <A HREF="option.html#SIG:OPTION.option:TY:SPEC">NONE</A> is returned otherwise. 	  <CODE>w</CODE> is the value of the number parsed. 	  Raises <A HREF="general.html#SIG:GENERAL.Overflow:EXN:SPEC">Overflow</A> when a hexadecimal numeral can be parsed,            but is too large to fit in type <A HREF="#SIG:WORD.word:TY:SPEC">word</A>.           Equivalent to <CODE>StringCvt.scanString (scan StringCvt.HEX)</CODE>.     
<BR>
<BR>

<DT> <A NAME="SIG:WORD.scan:VAL"><CODE>scan <VAR>radix</VAR> <VAR>getc</VAR> <VAR>src</VAR>
          </CODE></A>
<DD>
returns <CODE><A HREF="option.html#SIG:OPTION.option:TY:SPEC">SOME</A> (w,r)</CODE> if an unsigned number in the format 	  denoted by <VAR>radix</VAR> can be parsed from a prefix of the 	  character source <VAR>src</VAR> using the character input function 	  <VAR>getc</VAR>; <CODE>w</CODE> is the value of the number parsed, <CODE>r</CODE> 	  is the rest of the character source. Initial whitespace is           ignored. <A HREF="option.html#SIG:OPTION.option:TY:SPEC">NONE</A> is returned otherwise. 	  Raises <A HREF="general.html#SIG:GENERAL.Overflow:EXN:SPEC">Overflow</A> when a number can be parsed, but is 	  too large to fit in type <CODE>word</CODE>.           The type of <A HREF="#SIG:WORD.scan:VAL:SPEC">scan</A> can also be written as           
<PRE>
StringCvt.radix -&gt; (char, 'a) StringCvt.reader -&gt; (word, 'a) StringCvt.reader
          
</PRE>
           
<P>
	  The format expected depends on <VAR>radix</VAR>.           The formats are as follows:				           
<PRE>
          <A HREF="string-cvt.html#SIG:STRING_CVT.radix:TY:SPEC">StringCvt.BIN</A> - (0w)?[0-1]+
          <A HREF="string-cvt.html#SIG:STRING_CVT.radix:TY:SPEC">StringCvt.OCT</A> - (0w)?[0-7]+
          <A HREF="string-cvt.html#SIG:STRING_CVT.radix:TY:SPEC">StringCvt.DEC</A> - (0w)?[0-9]+
          <A HREF="string-cvt.html#SIG:STRING_CVT.radix:TY:SPEC">StringCvt.HEX</A> - (0wx|0wX|0x|0X)?[0-9a-fA-F]+
          
</PRE>
   
<BR>
<BR>

</DL>
<HR>
<H4>Discussion</H4>
<P>
The type <A HREF="#SIG:WORD.word:TY:SPEC">LargeWord.word</A> represents the largest  word supported. We require that <VAR>LargeWord.wordSize</VAR> &lt;= <VAR>LargeInt.precision</VAR>
<P>
The structure <A HREF="#SysWord:STR:SPEC">SysWord</A> is used with the optional <A HREF="posix.html#Posix:STR:SPEC">Posix</A> modules. The type <A HREF="#SIG:WORD.word:TY:SPEC">SysWord.word</A> is guaranteed to be large enough to hold any integral value used by the underlying system.
<P>
For words and integers of the same precision/word size, the operations <A HREF="#SIG:WORD.fromInt:VAL:SPEC">fromInt</A> and <A HREF="#SIG:WORD.toIntX:VAL:SPEC">toIntX</A> act as bit-wise identity functions. However, even in this case, <A HREF="#SIG:WORD.toInt:VAL:SPEC">toInt</A> will raise <A HREF="general.html#SIG:GENERAL.Overflow:EXN:SPEC">Overflow</A> if the high-order bit of the word is set.
<P>
Conversion between words and integers of any size can be handled by  intermediate conversion into <A HREF="#SIG:WORD.word:TY:SPEC">LargeWord.word</A> and <A HREF="integer.html#SIG:INTEGER.int:TY:SPEC">LargeInt.int</A>. For example, the functions <A HREF="#SIG:WORD.fromInt:VAL:SPEC">fromInt</A>, <A HREF="#SIG:WORD.toInt:VAL:SPEC">toInt</A> and <A HREF="#SIG:WORD.toIntX:VAL:SPEC">toIntX</A> are respectively equivalent to: 
<PRE>
  fromLargeWord o LargeWord.fromLargeInt o Int.toLarge
  Int.fromLarge o LargeWord.toLargeInt   o toLargeWord
  Int.fromLarge o LargeWord.toLargeIntX  o toLargeWordX
</PRE>
<P>
Typically, implementations will provide very efficient word operations by inline-expanding them to a few machine instructions. It also is assumed that implementations will catch the  idiom of converting between words and integers of differing precisions using an intermediate representation (e.g.,  <CODE>Word32.fromLargeWord o Word8.toLargeWord</CODE>) and optimize these conversions.
<H4>See Also</H4>
<BLOCKQUOTE>
<A HREF="byte.html#Byte:STR:SPEC">Byte</A>, <A HREF="integer.html#Int:STR:SPEC">Int</A>, <A HREF="integer.html#LargeInt:STR:SPEC">LargeInt</A>, <A HREF="string-cvt.html#StringCvt:STR:SPEC">StringCvt</A>
</BLOCKQUOTE>


<HR>
<CENTER>
<B>[ <A HREF="index-all.html">INDEX</A> | <A HREF="#top">TOP</A>
   | <A HREF="integer-chapter.html">Parent</A> | <A HREF="sml-std-basis.html">Root</A>
   ]</B>
</CENTER>
<P>
<I>Last Modified January 21, 1997</I><BR>
<I>Comments to <A HREF="mailto:jhr@research.bell-labs.com">John Reppy.</A></I><BR>

Copyright &copy; 1997 Bell Labs, Lucent Technologies <BR>

<HR>
</BODY>
</HTML>
