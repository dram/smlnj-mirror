<!-- HTML/real.html -->

<!-- COPYRIGHT (c) 1997 Bell Labs, Lucent Technologies. -->

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>The REAL signature</TITLE>
</HEAD>
<BODY>
<A NAME="top"></A>
<H1 align="CENTER">The Standard ML Basis Library</H1>
<HR>


<H3>The <CODE>REAL</CODE> signature</H3>
<P>
The REAL signature specifies structures that implement floating-point numbers. The semantics of floating-point numbers should follow the IEEE standard <B>[CITE]</B>754-1985/ and  the ANSI/IEEE standard <B>[CITE]</B>854-1987/. In addition, implementations of the REAL signature are required to use non-trapping semantics. Additional aspects of the design of the REAL and <A HREF="math.html#MATH:SIG:SPEC">MATH</A> signatures were guided by the Floating-Point C  <B>[CITE]</B>Extensions/ developed by the X3J11 ANSI committee and the lecture  <B>[CITE]</B>notes/ by W. Kahan on the IEEE standard 754. 
<P>
The relation between the comparison predicates defined here and those defined by IEEE, ANSI C and FORTRAN is specified in the following table. 
<HR>
<CENTER>
<TABLE ALIGN="CENTER">
<TR>
<TH ALIGN="LEFT" VALIGN="TOP">
<B>SML</B>
<TH ALIGN="LEFT" VALIGN="TOP">
<B>IEEE</B>
<TH ALIGN="LEFT" VALIGN="TOP">
<B>C</B>
<TH ALIGN="LEFT" VALIGN="TOP">
<B>FORTRAN</B>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>==</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>=</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>==</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>.EQ.</TT>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>!=</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>?&lt;&gt;</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>!=</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>.NE.</TT>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>&lt;</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>&lt;</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>&lt;</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>.LT.</TT>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>&lt;=</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>&lt;=</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>&lt;=</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>.LE.</TT>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>&gt;</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>&gt;</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>&gt;</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>.GT.</TT>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>&gt;=</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>&gt;=</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>&gt;=</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>.GE.</TT>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>?=</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>?=</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>!islessgreater</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>.UE.</TT>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>not o ?=</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>&lt;&gt;</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>islessgreater</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>.LG.</TT>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>unordered</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>?</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>isunordered</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>unordered</TT>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>not o unordered</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>&lt;=&gt;</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>!isunordered</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>.LEG.</TT>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>not o op &lt;</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>?&gt;=</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>! &lt;</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>.UGE.</TT>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>not o op &lt;=</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>?&gt;</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>! &lt;=</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>.UG.</TT>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>not o op &gt;</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>?&lt;=</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>! &gt;</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>.ULE.</TT>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>not o op &gt;=</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>?&lt;</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>! &gt;=</TT>
<TD ALIGN="LEFT" VALIGN="TOP">
<TT>.UL.</TT>
</TABLE>
</CENTER>
<HR>
<P>
In the functions below, unless specified otherwise, if any argument is a NaN, the return value is a NaN. In a list of rules specifying the behavior of a function in special cases, the first matching rule defines the semantics.  
<BLOCKQUOTE>
<B>Rationale:</B><BR>

<P>
The specification of the default signature and structure for non-integer arithmetic, particularly concerning exceptional conditions, was the source  of much debate, given the desire of allowing implementations to provide efficient floating-point modules. Permitting implementations to differ on whether or not, for example, to raise <A HREF="general.html#SIG:GENERAL.Div:EXN:SPEC">Div</A> on  division by zero meant that the user really did not have a standard to program against.  Portable code would require adopting the more conservative position of explicitly handling exceptions. A second alternative was to specify that functions in the  Real structure must raise exceptions, but that implementations so desiring could provide additional structures matching REAL with explicit floating-point semantics. This was rejected because it meant that the default <CODE>real</CODE> type would not be the same as a defined floating-point <CODE>real</CODE> type. This imbued a second-class status on the latter, while providing a default real of lesser performance and involving additional implementation complexity for little benefit.
<P>
Deciding if real should be an <CODE>eqtype</CODE>, and if so, what should equality mean, was also problematic. IEEE specifies that the sign of zeros be ignored in comparisons, and that equality evaluate to false if  either argument is a NaN. These constraints are disturbing to the SML programmer. The former implies that <CODE>0 = ~0</CODE> is true while <CODE>r/0 = r/~0</CODE> is false. The latter implies such anomalies as <CODE>r = r</CODE> is false, or that, for a ref cell <CODE>rr</CODE>, we could have <CODE>rr = rr</CODE> but not have <CODE>!rr = !rr</CODE>. We accepted the unsigned comparison of zeros, but felt that the reflexive property of equality, structural equality, and the desire that <CODE>&lt;&gt;</CODE> be equivalent to <CODE>not o =</CODE> ought to be preserved.  Additional complications led to the decision to not have real be an <CODE>eqtype</CODE>. <B>Additional rationale</B>.
<P>
The type, signature and structure identifiers real, REAL and Real, although misnomers in light of the floating-point-specific nature of the modules, were retained for historical reasons.
</BLOCKQUOTE>
 
<HR>
<H4>Synopsis</H4>
<BLOCKQUOTE>
<CODE><B>signature </B><A NAME="REAL:SIG:SPEC"><CODE>REAL</CODE></A><BR>
<B>structure </B><A NAME="Real:STR:SPEC"><CODE>Real</CODE></A><B> : </B>REAL<BR>
<B>structure </B><A NAME="LargeReal:STR:SPEC"><CODE>LargeReal</CODE></A><B> : </B>REAL<BR>
<B>structure </B><A NAME="Real{N}:STR:SPEC"><CODE>Real{N}</CODE></A><B> : </B>REAL<BR>
</CODE>
</BLOCKQUOTE>
<HR>
<H4>Interface</H4>
<BLOCKQUOTE>
<CODE><B>type</B> <A NAME="SIG:REAL.real:TY:SPEC" HREF="#SIG:REAL.real:TY">real</A><BR>
<B>structure</B> <A NAME="SIG:REAL.Math:STR:SPEC" HREF="#SIG:REAL.Math:STR">Math</A> <B>:</B> MATH<BR>
<B>val</B> <A NAME="SIG:REAL.radix:VAL:SPEC" HREF="#SIG:REAL.radix:VAL">radix</A> <B>:</B> int         <BR>
<B>val</B> <A NAME="SIG:REAL.precision:VAL:SPEC" HREF="#SIG:REAL.precision:VAL">precision</A> <B>:</B> int         <BR>
<B>val</B> <A NAME="SIG:REAL.maxFinite:VAL:SPEC" HREF="#SIG:REAL.maxFinite:VAL">maxFinite</A> <B>:</B> real       <BR>
<B>val</B> <A NAME="SIG:REAL.minPos:VAL:SPEC" HREF="#SIG:REAL.maxFinite:VAL">minPos</A> <B>:</B> real       <BR>
<B>val</B> <A NAME="SIG:REAL.minNormalPos:VAL:SPEC" HREF="#SIG:REAL.maxFinite:VAL">minNormalPos</A> <B>:</B> real         <BR>
<B>val</B> <A NAME="SIG:REAL.posInf:VAL:SPEC" HREF="#SIG:REAL.posInf:VAL">posInf</A> <B>:</B> real       <BR>
<B>val</B> <A NAME="SIG:REAL.negInf:VAL:SPEC" HREF="#SIG:REAL.posInf:VAL">negInf</A> <B>:</B> real         <BR>
<B>val</B> <A NAME="SIG:REAL.+:VAL:SPEC" HREF="#SIG:REAL.+:VAL">+</A> <B>:</B> (real * real) -&gt; real       <BR>
<B>val</B> <A NAME="SIG:REAL.-:VAL:SPEC" HREF="#SIG:REAL.+:VAL">-</A> <B>:</B> (real * real) -&gt; real         <BR>
<B>val</B> <A NAME="SIG:REAL.*:VAL:SPEC" HREF="#SIG:REAL.*:VAL">*</A> <B>:</B> (real * real) -&gt; real         <BR>
<B>val</B> <A NAME="SIG:REAL./:VAL:SPEC" HREF="#SIG:REAL./:VAL">/</A> <B>:</B> (real * real) -&gt; real         <BR>
<B>val</B> <A NAME="SIG:REAL.*+:VAL:SPEC" HREF="#SIG:REAL.*+:VAL">*+</A> <B>:</B> real * real * real -&gt; real       <BR>
<B>val</B> <A NAME="SIG:REAL.*-:VAL:SPEC" HREF="#SIG:REAL.*+:VAL">*-</A> <B>:</B> real * real * real -&gt; real         <BR>
<B>val</B> <A NAME="SIG:REAL.~:VAL:SPEC" HREF="#SIG:REAL.~:VAL">~</A> <B>:</B> real -&gt; real         <BR>
<B>val</B> <A NAME="SIG:REAL.abs:VAL:SPEC" HREF="#SIG:REAL.abs:VAL">abs</A> <B>:</B> real -&gt; real         <BR>
<B>val</B> <A NAME="SIG:REAL.min:VAL:SPEC" HREF="#SIG:REAL.min:VAL">min</A> <B>:</B> (real * real) -&gt; real       <BR>
<B>val</B> <A NAME="SIG:REAL.max:VAL:SPEC" HREF="#SIG:REAL.min:VAL">max</A> <B>:</B> (real * real) -&gt; real         <BR>
<B>val</B> <A NAME="SIG:REAL.sign:VAL:SPEC" HREF="#SIG:REAL.sign:VAL">sign</A> <B>:</B> real -&gt; int         <BR>
<B>val</B> <A NAME="SIG:REAL.signBit:VAL:SPEC" HREF="#SIG:REAL.signBit:VAL">signBit</A> <B>:</B> real -&gt; bool         <BR>
<B>val</B> <A NAME="SIG:REAL.sameSign:VAL:SPEC" HREF="#SIG:REAL.sameSign:VAL">sameSign</A> <B>:</B> (real * real) -&gt; bool         <BR>
<B>val</B> <A NAME="SIG:REAL.copySign:VAL:SPEC" HREF="#SIG:REAL.copySign:VAL">copySign</A> <B>:</B> (real * real) -&gt; real         <BR>
<B>val</B> <A NAME="SIG:REAL.compare:VAL:SPEC" HREF="#SIG:REAL.compare:VAL">compare</A> <B>:</B> (real * real) -&gt; order         <BR>
<B>val</B> <A NAME="SIG:REAL.compareReal:VAL:SPEC" HREF="#SIG:REAL.compare:VAL">compareReal</A> <B>:</B> (real * real) -&gt; IEEEReal.real_order         <BR>
<B>val</B> <A NAME="SIG:REAL.\|@LT\|:VAL:SPEC" HREF="#SIG:REAL.\|@LT\|:VAL">&lt;</A> <B>:</B> (real * real) -&gt; bool       <BR>
<B>val</B> <A NAME="SIG:REAL.\|@LTE\|:VAL:SPEC" HREF="#SIG:REAL.\|@LT\|:VAL">&lt;=</A> <B>:</B> (real * real) -&gt; bool       <BR>
<B>val</B> <A NAME="SIG:REAL.\|@GT\|:VAL:SPEC" HREF="#SIG:REAL.\|@LT\|:VAL">&gt;</A> <B>:</B> (real * real) -&gt; bool       <BR>
<B>val</B> <A NAME="SIG:REAL.\|@GTE\|:VAL:SPEC" HREF="#SIG:REAL.\|@LT\|:VAL">&gt;=</A> <B>:</B> (real * real) -&gt; bool         <BR>
<B>val</B> <A NAME="SIG:REAL.==:VAL:SPEC" HREF="#SIG:REAL.==:VAL">==</A> <B>:</B> (real * real) -&gt; bool       <BR>
<B>val</B> <A NAME="SIG:REAL.!=:VAL:SPEC" HREF="#SIG:REAL.==:VAL">!=</A> <B>:</B> (real * real) -&gt; bool         <BR>
<B>val</B> <A NAME="SIG:REAL.?=:VAL:SPEC" HREF="#SIG:REAL.?=:VAL">?=</A> <B>:</B> (real * real) -&gt; bool         <BR>
<B>val</B> <A NAME="SIG:REAL.unordered:VAL:SPEC" HREF="#SIG:REAL.unordered:VAL">unordered</A> <B>:</B> (real * real) -&gt; bool         <BR>
<B>val</B> <A NAME="SIG:REAL.isFinite:VAL:SPEC" HREF="#SIG:REAL.isFinite:VAL">isFinite</A> <B>:</B> real -&gt; bool         <BR>
<B>val</B> <A NAME="SIG:REAL.isNan:VAL:SPEC" HREF="#SIG:REAL.isNan:VAL">isNan</A> <B>:</B> real -&gt; bool         <BR>
<B>val</B> <A NAME="SIG:REAL.isNormal:VAL:SPEC" HREF="#SIG:REAL.isNormal:VAL">isNormal</A> <B>:</B> real -&gt; bool         <BR>
<B>val</B> <A NAME="SIG:REAL.class:VAL:SPEC" HREF="#SIG:REAL.class:VAL">class</A> <B>:</B> real -&gt; IEEEReal.float_class         <BR>
<B>val</B> <A NAME="SIG:REAL.fmt:VAL:SPEC" HREF="#SIG:REAL.fmt:VAL">fmt</A> <B>:</B> StringCvt.realfmt -&gt; real -&gt; string       <BR>
<B>val</B> <A NAME="SIG:REAL.toString:VAL:SPEC" HREF="#SIG:REAL.fmt:VAL">toString</A> <B>:</B> real -&gt; string         <BR>
<B>val</B> <A NAME="SIG:REAL.fromString:VAL:SPEC" HREF="#SIG:REAL.fromString:VAL">fromString</A> <B>:</B> string -&gt; real option         <BR>
<B>val</B> <A NAME="SIG:REAL.scan:VAL:SPEC" HREF="#SIG:REAL.scan:VAL">scan</A> <B>:</B> (char, 'a) StringCvt.reader -&gt; (real, 'a) StringCvt.reader         <BR>
<B>val</B> <A NAME="SIG:REAL.toManExp:VAL:SPEC" HREF="#SIG:REAL.toManExp:VAL">toManExp</A> <B>:</B> real -&gt; {man : real, exp : int}         <BR>
<B>val</B> <A NAME="SIG:REAL.fromManExp:VAL:SPEC" HREF="#SIG:REAL.fromManExp:VAL">fromManExp</A> <B>:</B> {man : real, exp : int} -&gt; real         <BR>
<B>val</B> <A NAME="SIG:REAL.split:VAL:SPEC" HREF="#SIG:REAL.split:VAL">split</A> <B>:</B> real -&gt; {whole : real, frac : real}       <BR>
<B>val</B> <A NAME="SIG:REAL.realMod:VAL:SPEC" HREF="#SIG:REAL.split:VAL">realMod</A> <B>:</B> real -&gt; real         <BR>
<B>val</B> <A NAME="SIG:REAL.rem:VAL:SPEC" HREF="#SIG:REAL.rem:VAL">rem</A> <B>:</B> (real * real) -&gt; real         <BR>
<B>val</B> <A NAME="SIG:REAL.nextAfter:VAL:SPEC" HREF="#SIG:REAL.nextAfter:VAL">nextAfter</A> <B>:</B> (real * real) -&gt; real         <BR>
<B>val</B> <A NAME="SIG:REAL.checkFloat:VAL:SPEC" HREF="#SIG:REAL.checkFloat:VAL">checkFloat</A> <B>:</B> real -&gt;real       <BR>
<B>val</B> <A NAME="SIG:REAL.realFloor:VAL:SPEC" HREF="#SIG:REAL.realFloor:VAL">realFloor</A> <B>:</B> real -&gt; real       <BR>
<B>val</B> <A NAME="SIG:REAL.realCeil:VAL:SPEC" HREF="#SIG:REAL.realFloor:VAL">realCeil</A> <B>:</B> real -&gt; real       <BR>
<B>val</B> <A NAME="SIG:REAL.realTrunc:VAL:SPEC" HREF="#SIG:REAL.realFloor:VAL">realTrunc</A> <B>:</B> real -&gt; real         <BR>
<B>val</B> <A NAME="SIG:REAL.floor:VAL:SPEC" HREF="#SIG:REAL.floor:VAL">floor</A> <B>:</B> real -&gt; Int.int         <BR>
<B>val</B> <A NAME="SIG:REAL.ceil:VAL:SPEC" HREF="#SIG:REAL.floor:VAL">ceil</A> <B>:</B> real -&gt; Int.int         <BR>
<B>val</B> <A NAME="SIG:REAL.trunc:VAL:SPEC" HREF="#SIG:REAL.floor:VAL">trunc</A> <B>:</B> real -&gt; Int.int         <BR>
<B>val</B> <A NAME="SIG:REAL.round:VAL:SPEC" HREF="#SIG:REAL.floor:VAL">round</A> <B>:</B> real -&gt; Int.int         <BR>
<B>val</B> <A NAME="SIG:REAL.toInt:VAL:SPEC" HREF="#SIG:REAL.toInt:VAL">toInt</A> <B>:</B> IEEEReal.rounding_mode -&gt; real -&gt; int         <BR>
<B>val</B> <A NAME="SIG:REAL.toLargeInt:VAL:SPEC" HREF="#SIG:REAL.toInt:VAL">toLargeInt</A> <B>:</B> IEEEReal.rounding_mode -&gt; real -&gt; LargeInt.int         <BR>
<B>val</B> <A NAME="SIG:REAL.fromInt:VAL:SPEC" HREF="#SIG:REAL.fromInt:VAL">fromInt</A> <B>:</B> int -&gt; real       <BR>
<B>val</B> <A NAME="SIG:REAL.fromLargeInt:VAL:SPEC" HREF="#SIG:REAL.fromInt:VAL">fromLargeInt</A> <B>:</B> LargeInt.int -&gt; real         <BR>
<B>val</B> <A NAME="SIG:REAL.toLarge:VAL:SPEC" HREF="#SIG:REAL.toLarge:VAL">toLarge</A> <B>:</B> real -&gt; LargeReal.real       <BR>
<B>val</B> <A NAME="SIG:REAL.fromLarge:VAL:SPEC" HREF="#SIG:REAL.toLarge:VAL">fromLarge</A> <B>:</B> IEEEReal.rounding_mode -&gt; LargeReal.real -&gt; real         <BR>
<B>val</B> <A NAME="SIG:REAL.toDecimal:VAL:SPEC" HREF="#SIG:REAL.toDecimal:VAL">toDecimal</A> <B>:</B> real -&gt; IEEEReal.decimal_approx       <BR>
<B>val</B> <A NAME="SIG:REAL.fromDecimal:VAL:SPEC" HREF="#SIG:REAL.toDecimal:VAL">fromDecimal</A> <B>:</B> IEEEReal.decimal_approx -&gt; real         <BR>
</CODE>
</BLOCKQUOTE>
<H4>Description</H4>
<DL>
<DT> <A NAME="SIG:REAL.real:TY"><CODE><B>type</B> real</CODE></A>
<DD>
Note that, as discussed above <A HREF="#SIG:REAL.real:TY:SPEC">real</A> is not an <CODE>eqtype</CODE>.     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.Math:STR"><CODE><B>structure</B> Math</CODE></A>
<DD>
<BR>

<DT> <A NAME="SIG:REAL.radix:VAL"><CODE>radix
          </CODE></A>
<DD>
is the base of the representation, e.g., 2 or 10 for IEEE           floating point.     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.precision:VAL"><CODE>precision
          </CODE></A>
<DD>
is the number of digits, each between <CODE>0</CODE> and            <CODE><A HREF="#SIG:REAL.radix:VAL:SPEC">radix</A>-1</CODE>, in the mantissa.     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.maxFinite:VAL"><CODE>maxFinite
          </CODE></A>
<DT> <CODE>          minPos
          </CODE>
<DT> <CODE>          minNormalPos
          </CODE>
<DD>
are the maximum finite number, the minimum non-zero positive number           and the minimum non-zero normalized number, respectively.     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.posInf:VAL"><CODE><B>val</B> posInf</CODE></A>
<DT> <CODE><B>val</B> negInf</CODE>
<DD>
Positive and negative infinity values.     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.+:VAL"><CODE><VAR>r1</VAR> + <VAR>r2</VAR>
          </CODE></A>
<DT> <CODE>          <VAR>r1</VAR> - <VAR>r2</VAR>
          </CODE>
<DD>
the sum and difference of <VAR>r1</VAR> and <VAR>r2</VAR>.            If one argument           is finite and the other infinite, the result is infinite with           the correct sign, e.g., 5 - (-infinity) = infinity.           We also have infinity + infinity = infinity and            (-infinity) + (-infinity) = (-infinity). Any other combination of           two infinities produces a NaN.     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.*:VAL"><CODE><VAR>r1</VAR> * <VAR>r2</VAR>
          </CODE></A>
<DD>
the product of <VAR>r1</VAR> and <VAR>r2</VAR>.           The product of zero and an infinity produces a NaN. Otherwise,           if one argument is infinite, the result is infinite with           the correct sign, e.g., -5 * (-infinity) = infinity,           infinity * (-infinity) = -infinity.     
<BR>
<BR>

<DT> <A NAME="SIG:REAL./:VAL"><CODE><VAR>r1</VAR> / <VAR>r2</VAR>
          </CODE></A>
<DD>
the quotient of <VAR>r1</VAR> and <VAR>r2</VAR>.            We have 0 / 0 = <CODE>NaN</CODE> and            +-infinity / +-infinity = <CODE>NaN</CODE>.           Dividing a finite, non-zero number by a zero,            or an infinity by a finite number produces an infinity with           the correct sign. (Note that zeros are signed.) A finite           number divided by an infinity is 0 with the correct sign.     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.*+:VAL"><CODE>*+ (<VAR>a</VAR>, <VAR>b</VAR>, <VAR>c</VAR>)
          </CODE></A>
<DT> <CODE>          *- (<VAR>a</VAR>, <VAR>b</VAR>, <VAR>c</VAR>)
          </CODE>
<DD>
return <CODE><VAR>a</VAR>*<VAR>b</VAR> + <VAR>c</VAR></CODE>            and <CODE><VAR>a</VAR>*<VAR>b</VAR> - <VAR>c</VAR></CODE>, respectively.           Their behaviors on infinities follow from the behaviors derived           from addition, subtraction and multiplication.           
<P>
          The precise semantics of these operations depend on the language           implementation and the underlying hardware. Specifically,           certain architectures provide these operations as a single           instruction, possibly using a single rounding operation.           Thus, the use of these operations may be           faster than performing the individual arithmetic operations           sequentially, but may also cause different rounding behavior.     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.~:VAL"><CODE>~ <VAR>r</VAR>
          </CODE></A>
<DD>
the negation of <VAR>r</VAR>, i.e., <CODE>(- <VAR>r</VAR>)</CODE>.           <CODE>~</CODE> (+-infinity) = -+infinity.     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.abs:VAL"><CODE>abs <VAR>r</VAR>
          </CODE></A>
<DD>
the absolute value of <VAR>r</VAR>.           <CODE>abs</CODE> (+-infinity) = infinity.     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.min:VAL"><CODE>min (<VAR>a</VAR>, <VAR>b</VAR>)
          </CODE></A>
<DT> <CODE>          max (<VAR>a</VAR>, <VAR>b</VAR>)
          </CODE>
<DD>
returns the smaller (respectively, larger) of <VAR>a</VAR> and <VAR>b</VAR>.           If exactly one argument is NaN, return the other argument.           If both arguments are NaN, return NaN.     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.sign:VAL"><CODE>sign <VAR>r</VAR>
          </CODE></A>
<DD>
~1 if <VAR>r</VAR> is negative, 0 if <VAR>r</VAR> is zero, or 	  1 if <VAR>r</VAR> is positive. An infinity returns its sign; a zero           returns 0 regardless of its sign.            Raises <A HREF="general.html#SIG:GENERAL.Domain:EXN:SPEC">Domain</A> on NaN.     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.signBit:VAL"><CODE>signBit <VAR>r</VAR>
          </CODE></A>
<DD>
returns <CODE>true</CODE> if and only if the sign of <VAR>r</VAR> (infinities,           zeros and NaNs, included) is negative.     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.sameSign:VAL"><CODE>sameSign (<VAR>r1</VAR>, <VAR>r2</VAR>)
          </CODE></A>
<DD>
returns <B>true</B> if and only if <CODE><A HREF="#SIG:REAL.signBit:VAL:SPEC">signBit</A> <VAR>r1</VAR></CODE>            equals <CODE><A HREF="#SIG:REAL.signBit:VAL:SPEC">signBit</A> <VAR>r2</VAR></CODE>.     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.copySign:VAL"><CODE>copySign (<VAR>x</VAR>, <VAR>y</VAR>)
          </CODE></A>
<DD>
returns <VAR>x</VAR> with the sign of <VAR>y</VAR>, even if <VAR>y</VAR> is a NaN.     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.compare:VAL"><CODE>compare (<VAR>r1</VAR>, <VAR>r2</VAR>)
          </CODE></A>
<DT> <CODE>          compareReal (<VAR>r1</VAR>, <VAR>r2</VAR>)
          </CODE>
<DD>
The function <A HREF="#SIG:REAL.compare:VAL:SPEC">compare</A> returns 	  <A HREF="general.html#SIG:GENERAL.order:TY:SPEC">LESS</A>, <A HREF="general.html#SIG:GENERAL.order:TY:SPEC">EQUAL</A> or  	  <A HREF="general.html#SIG:GENERAL.order:TY:SPEC">GREATER</A> according to whether <VAR>r1</VAR> is 	  less than, equal to, or greater than <VAR>r2</VAR>. It raises           <A HREF="ieee-float.html#SIG:IEEE_REAL.Unordered:EXN:SPEC">IEEEReal.Unordered</A> on unordered           arguments.           
<P>
          The function <A HREF="#SIG:REAL.compareReal:VAL:SPEC">compareReal</A> behaves similarly except it           returns values of type <A HREF="ieee-float.html#SIG:IEEE_REAL.real_order:TY:SPEC">IEEEReal.real_order</A>           and returns <A HREF="ieee-float.html#SIG:IEEE_REAL.real_order:TY:SPEC">IEEEReal.UNORDERED</A> on           unordered arguments. 
<BLOCKQUOTE>
<B>Implementation note:</B><BR>

<P>
Implementations should try to optimize use of Real.compare, since it is necessary for catching NaNs.
</BLOCKQUOTE>
     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.\|@LT\|:VAL"><CODE><VAR>r1</VAR> &lt; <VAR>r2</VAR>
          </CODE></A>
<DT> <CODE>          <VAR>r1</VAR> &lt;= <VAR>r2</VAR>
          </CODE>
<DT> <CODE>          <VAR>r1</VAR> &gt; <VAR>r2</VAR>
          </CODE>
<DT> <CODE>          <VAR>r1</VAR> &gt;= <VAR>r2</VAR>
          </CODE>
<DD>
return <B>true</B> if the corresponding relation            holds between the two reals.           
<P>
          Note that these operators return <CODE>false</CODE> on unordered arguments,           i.e., if either argument is NaN, so that the usual reversal of           comparison under negation does not hold, e.g.,           <CODE>a &lt; b</CODE> is not the same as <CODE>not (a &gt;= b)</CODE>.      
<BR>
<BR>

<DT> <A NAME="SIG:REAL.==:VAL"><CODE>== (<VAR>x</VAR>, <VAR>y</VAR>)
          </CODE></A>
<DT> <CODE>          != (<VAR>x</VAR>, <VAR>y</VAR>)
          </CODE>
<DD>
The first returns true if and only if neither <VAR>y</VAR> nor <VAR>x</VAR>            is NaN,           and <VAR>y</VAR> and <VAR>x</VAR> are equal, ignoring signs on zeros.           This is equivalent to the IEEE <CODE>=</CODE> operator.           
<P>
          The second function <CODE>!=</CODE> is equivalent to <CODE>not o op ==</CODE>           and the IEEE <CODE>?&lt;&gt;</CODE> operator.     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.?=:VAL"><CODE>?= (<VAR>x</VAR>, <VAR>y</VAR>)
          </CODE></A>
<DD>
returns true if either argument is a NaN or if the            arguments are bitwise equal, ignoring signs on zeros.           It is equivalent to the IEEE <CODE>?=</CODE> operator.      
<BR>
<BR>

<DT> <A NAME="SIG:REAL.unordered:VAL"><CODE>unordered (<VAR>x</VAR>, <VAR>y</VAR>)
          </CODE></A>
<DD>
returns true if <VAR>x</VAR> and <VAR>y</VAR> are unordered, i.e., at           least one of <VAR>x</VAR> and <VAR>y</VAR> is a NaN.     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.isFinite:VAL"><CODE>isFinite <VAR>x</VAR>
          </CODE></A>
<DD>
returns true if <VAR>x</VAR> is neither a NaN nor an infinity.     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.isNan:VAL"><CODE>isNan <VAR>x</VAR>
          </CODE></A>
<DD>
returns true if <VAR>x</VAR> is a NaN.      
<BR>
<BR>

<DT> <A NAME="SIG:REAL.isNormal:VAL"><CODE>isNormal <VAR>x</VAR>
          </CODE></A>
<DD>
returns true if <VAR>x</VAR> is normal, i.e., neither zero, subnormal,           infinite nor NaN.     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.class:VAL"><CODE>class <VAR>x</VAR>
          </CODE></A>
<DD>
returns the <A HREF="ieee-float.html#SIG:IEEE_REAL.float_class:TY:SPEC">IEEEReal.float_class</A> to which <VAR>x</VAR> belongs.     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.fmt:VAL"><CODE>fmt <VAR>spec</VAR> <VAR>r</VAR>
          </CODE></A>
<DT> <CODE>          toString <VAR>r</VAR>
          </CODE>
<DD>
convert reals into strings. The conversion provided by           the function <A HREF="#SIG:REAL.fmt:VAL:SPEC">fmt</A> is parameterized 	      by <VAR>spec</VAR>, which has the following forms and interpretations. 
<DL>
<DT> <CODE>SCI <VAR>arg</VAR></CODE>
<DD>
Scientific notation: <CODE>[~]<VAR>d.ddd</VAR>E[~]dd</CODE>, where there is always one digit before the decimal point, nonzero if the number is nonzero.  <VAR>arg</VAR> specifies the number of digits to appear after the decimal point, with 6 the default if <VAR>arg</VAR> is <CODE>NONE</CODE>.
<DT> <CODE>FIX <VAR>arg</VAR></CODE>
<DD>
Fixed-point notation: <CODE>[~]<VAR>ddd.ddd</VAR></CODE>. <VAR>arg</VAR> specifies the number of digits to appear after the decimal point, with 6 the default if <VAR>arg</VAR> is <CODE>NONE</CODE>.
<DT> <CODE>GEN <VAR>arg</VAR></CODE>
<DD>
Adaptive notation: the notation used is either scientific or fixed-point depending on the value converted. <VAR>arg</VAR> specifies the maximum number of significant digits used, with 12 the default if <VAR>arg</VAR> is <CODE>NONE</CODE>.
<DT> <CODE>EXACT</CODE>
<DD>
Exact decimal notation: refer  to <A HREF="ieee-float.html#SIG:IEEE_REAL.toString:VAL:SPEC">IEEEReal.toString</A> for a  complete description of this format.
</DL>
 In all cases, positive and negative infinities are converted to <CODE>&quot;inf&quot;</CODE> and <CODE>&quot;~inf&quot;</CODE>, respectively. If <VAR>spec</VAR> is not <CODE>EXACT</CODE>, NaN values are returned as <CODE>&quot;nan&quot;</CODE>; otherwise, NaN values are converted to the form <TT>&quot;nan(d<SUB>(1)</SUB>d<SUB>(2)</SUB>...d<SUB>(n)</SUB>)&quot;</TT>.           
<P>
          <A HREF="#SIG:REAL.fmt:VAL:SPEC">fmt</A> raises <A HREF="general.html#SIG:GENERAL.Size:EXN:SPEC">Size</A> if <VAR>spec</VAR> is an            invalid precision, i.e., if <VAR>spec</VAR> is  
<UL>
<LI>
<CODE><A HREF="string-cvt.html#SIG:STRING_CVT.realfmt:TY:SPEC">SCI</A> (<A HREF="option.html#SIG:OPTION.option:TY:SPEC">SOME</A> <VAR>i</VAR>)</CODE> with <VAR>i</VAR> &lt; 0
<LI>
<CODE><A HREF="string-cvt.html#SIG:STRING_CVT.realfmt:TY:SPEC">FIX</A> (<A HREF="option.html#SIG:OPTION.option:TY:SPEC">SOME</A> <VAR>i</VAR>)</CODE> with <VAR>i</VAR> &lt; 0
<LI>
<CODE><A HREF="string-cvt.html#SIG:STRING_CVT.realfmt:TY:SPEC">GEN</A> (<A HREF="option.html#SIG:OPTION.option:TY:SPEC">SOME</A> <VAR>i</VAR>)</CODE> with <VAR>i</VAR> &lt; 1
</UL>
  	  
<P>
          The value returned by <A HREF="#SIG:REAL.toString:VAL:SPEC">toString</A> is equivalent to:  	  
<PRE>
(<A HREF="#SIG:REAL.fmt:VAL:SPEC">fmt</A> (<A HREF="string-cvt.html#SIG:STRING_CVT.realfmt:TY:SPEC">StringCvt.GEN</A> <A HREF="option.html#SIG:OPTION.option:TY:SPEC">NONE</A>) <VAR>r</VAR>)
	  
</PRE>
     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.fromString:VAL"><CODE>fromString <VAR>s</VAR>
          </CODE></A>
<DD>
returns <CODE><A HREF="option.html#SIG:OPTION.option:TY:SPEC">SOME</A>(<VAR>r</VAR>)</CODE> if a <A HREF="#SIG:REAL.real:TY:SPEC">real</A>            value can be scanned from a prefix of <VAR>s</VAR>,  	  ignoring any initial whitespace; otherwise, returns <A HREF="option.html#SIG:OPTION.option:TY:SPEC">NONE</A>.           Equivalent to <CODE><A HREF="string-cvt.html#SIG:STRING_CVT.scanString:VAL:SPEC">StringCvt.scanString</A> scan</CODE>.     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.scan:VAL"><CODE>scan <VAR>getc</VAR> <VAR>a</VAR>
          </CODE></A>
<DD>
scans a <A HREF="#SIG:REAL.real:TY:SPEC">real</A> value from character source <VAR>a</VAR> using 	  reader <VAR>getc</VAR>, ignoring initial whitespace. 	  If successful, returns <CODE><A HREF="option.html#SIG:OPTION.option:TY:SPEC">SOME</A>(<VAR>r</VAR>,<VAR>rest</VAR>)</CODE> where 	  <VAR>r</VAR> is the scanned <A HREF="#SIG:REAL.real:TY:SPEC">real</A> value and <VAR>rest</VAR> is            the unused portion of the character source <VAR>a</VAR>.           Raises <A HREF="general.html#SIG:GENERAL.Overflow:EXN:SPEC">Overflow</A> if the value cannot be represented in           <A HREF="#SIG:REAL.real:TY:SPEC">real</A> value.           
<P>
          The format for valid string representation of reals is given by            the regular expression           
<PRE>
	  [+~-]?(([0-9]+(\.[0-9]+)?)|(\.[0-9]+))([eE][+~-]?[0-9]+)?
          
</PRE>
      
<BR>
<BR>

<DT> <A NAME="SIG:REAL.toManExp:VAL"><CODE>toManExp <VAR>r</VAR>
          </CODE></A>
<DD>
returns <CODE>{<VAR>man</VAR>, <VAR>exp</VAR>}</CODE>, where <VAR>man</VAR> and <VAR>exp</VAR> are           the mantissa and exponent of <VAR>r</VAR>, respectively. Specifically,           we have the relation           
<BLOCKQUOTE>
          <VAR>r</VAR> = <VAR>man</VAR> * <CODE>radix</CODE><SUP>(<VAR>exp</VAR>)</SUP>           
</BLOCKQUOTE>
           where 1.0 &lt;= <VAR>man</VAR> * <VAR>radix</VAR> &lt; <VAR>radix</VAR>.           This function is comparable to <CODE>frexp</CODE> in the C library.           
<P>
          If <VAR>r</VAR> is +-0,           <VAR>man</VAR> is +-0 and <VAR>exp</VAR> is +0.           If <VAR>r</VAR> is +-infinity,            <VAR>man</VAR> is +-infinity and <VAR>exp</VAR> is unspecified.           If <VAR>r</VAR> is NaN,           <VAR>man</VAR> is Nan and <VAR>exp</VAR> is unspecified.     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.fromManExp:VAL"><CODE>fromManExp {<VAR>man</VAR>, <VAR>exp</VAR>}
          </CODE></A>
<DD>
returns <VAR>man</VAR> * <CODE>radix</CODE><SUP>(<VAR>exp</VAR>)</SUP>.           This function is comparable to <CODE>ldexp</CODE> in the C library.           Note that non-exceptional arguments can produce zero or infinities,           essentially because of underflows and overflows.           
<P>
          If <VAR>man</VAR> is +-0, the result is +-0.           If <VAR>man</VAR> is +-infinity, the result is +-infinity.           If <VAR>man</VAR> is NaN, the result is NaN.     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.split:VAL"><CODE>split <VAR>r</VAR>
          </CODE></A>
<DT> <CODE>          realMod <VAR>r</VAR>
          </CODE>
<DD>
The former returns <CODE>{<VAR>whole</VAR>, <VAR>frac</VAR>}</CODE>, where            <VAR>frac</VAR> and <VAR>whole</VAR> are           the fractional and integral parts of <VAR>r</VAR>, respectively.           Specifically, <VAR>whole</VAR> is integral,            |<VAR>frac</VAR>| &lt; 1.0, <VAR>whole</VAR>            and <VAR>frac</VAR> have the same sign as <VAR>r</VAR>,            and <VAR>r</VAR> = <VAR>whole</VAR> + <VAR>frac</VAR>.           This function is comparable to <CODE>modf</CODE> in the C library.           
<P>
          If <VAR>r</VAR> is +-infinity, <VAR>whole</VAR> is           +-infinity and <VAR>frac</VAR> is +-0.           If <VAR>r</VAR> is NaN, both <VAR>whole</VAR> and <VAR>frac</VAR> are NaN.           
<P>
          <CODE>realMod</CODE> is equivalent to <CODE>#frac o split</CODE>.     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.rem:VAL"><CODE>rem (<VAR>x</VAR>, <VAR>y</VAR>)
          </CODE></A>
<DD>
returns the remainder <VAR>x</VAR> - <VAR>n</VAR>*<VAR>y</VAR>, where           <VAR>n</VAR> = <CODE>trunc</CODE> (<VAR>x</VAR> / <VAR>y</VAR>). The result           has the same sign as <VAR>x</VAR> and has absolute value less than           the absolute value of <VAR>y</VAR>.           
<P>
          If <VAR>x</VAR> is an infinity or <VAR>y</VAR> is 0, <A HREF="#SIG:REAL.rem:VAL:SPEC">rem</A> returns NaN.           If <VAR>y</VAR> is an infinity, <A HREF="#SIG:REAL.rem:VAL:SPEC">rem</A> returns <VAR>x</VAR>.     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.nextAfter:VAL"><CODE>nextAfter (<VAR>r</VAR>, <VAR>t</VAR>)
          </CODE></A>
<DD>
returns the next representable real after <VAR>r</VAR> in the           direction of <VAR>t</VAR>.            Thus, if <VAR>t</VAR> is less  than  <VAR>r</VAR>,  <A HREF="#SIG:REAL.nextAfter:VAL:SPEC">nextAfter</A>           returns the largest representable floating-point number less           than <VAR>r</VAR>.           If <CODE><VAR>r</VAR> = <VAR>t</VAR></CODE> then it returns <VAR>r</VAR>.           If <VAR>r</VAR> is +-infinity, it returns +-infinity.           If either argument is a NaN, this returns NaN.     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.checkFloat:VAL"><CODE>checkFloat <VAR>x</VAR>
          </CODE></A>
<DD>
raises <A HREF="general.html#SIG:GENERAL.Overflow:EXN:SPEC">Overflow</A> if <VAR>x</VAR> is an infinity, 	  and raises <A HREF="general.html#SIG:GENERAL.Div:EXN:SPEC">Div</A> if <VAR>x</VAR> is a NaN. 	  Otherwise, it returns its argument.           
<P>
          This can be used to synthesize trapping arithmetic from the            non-trapping operations given here. Note, however, that infinities can            be converted to NaNs by some operations, so that if accurate            exceptions are required, checks must be done after each operation.      
<BR>
<BR>

<DT> <A NAME="SIG:REAL.realFloor:VAL"><CODE>realFloor <VAR>r</VAR>
          </CODE></A>
<DT> <CODE>          realCeil <VAR>r</VAR>
          </CODE>
<DT> <CODE>          realTrunc <VAR>r</VAR>
          </CODE>
<DD>
truncate reals to integer-valued reals. <A HREF="#SIG:REAL.realFloor:VAL:SPEC">realFloor</A> produces           the largest integer not larger than <VAR>r</VAR>.           <A HREF="#SIG:REAL.realCeil:VAL:SPEC">realCeil</A> produces           the smallest integer not less than <VAR>r</VAR>.           <A HREF="#SIG:REAL.realTrunc:VAL:SPEC">realTrunc</A> rounds <VAR>r</VAR> towards zero.           If <VAR>r</VAR> is NaN or an infinity, these functions return <VAR>r</VAR>.     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.floor:VAL"><CODE>floor <VAR>r</VAR>
          </CODE></A>
<DT> <CODE>          ceil <VAR>r</VAR>
          </CODE>
<DT> <CODE>          trunc <VAR>r</VAR>
          </CODE>
<DT> <CODE>          round <VAR>r</VAR>
          </CODE>
<DD>
convert reals to integers. <A HREF="#SIG:REAL.floor:VAL:SPEC">floor</A> produces           the largest <A HREF="integer.html#SIG:INTEGER.int:TY:SPEC">int</A> not larger than <VAR>r</VAR>.           <A HREF="#SIG:REAL.ceil:VAL:SPEC">ceil</A> produces           the smallest <A HREF="integer.html#SIG:INTEGER.int:TY:SPEC">int</A> not less than <VAR>r</VAR>.           <A HREF="#SIG:REAL.trunc:VAL:SPEC">trunc</A> rounds <VAR>r</VAR> towards zero.           <A HREF="#SIG:REAL.round:VAL:SPEC">round</A> yields the integer nearest to <VAR>r</VAR>.  	  In the case of a tie, rounds to the nearest even integer.           They raise <A HREF="general.html#SIG:GENERAL.Overflow:EXN:SPEC">Overflow</A> if the resulting           value cannot be represented as an <A HREF="integer.html#SIG:INTEGER.int:TY:SPEC">int</A>, for           example, on infinity.           They raise <A HREF="general.html#SIG:GENERAL.Domain:EXN:SPEC">Domain</A> on NaN arguments.           
<P>
          These are respectively equivalent to:        
<PRE>
         toInt IEEEReal.TO_NEGINF r
         toInt IEEEReal.TO_POSINF r
         toInt IEEEReal.TO_ZERO r
         toInt IEEEReal.TO_NEAREST r
       
</PRE>
     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.toInt:VAL"><CODE>toInt <VAR>mode</VAR> <VAR>x</VAR>
          </CODE></A>
<DT> <CODE>          toLargeInt <VAR>mode</VAR> <VAR>x</VAR>
          </CODE>
<DD>
convert the argument <VAR>x</VAR> to an integral type using the specified           rounding mode.           Raise <A HREF="general.html#SIG:GENERAL.Overflow:EXN:SPEC">Overflow</A> if the result is not           representable, in particular, if <VAR>x</VAR> is an infinity.           Raise <A HREF="general.html#SIG:GENERAL.Domain:EXN:SPEC">Domain</A> if the input real is a NaN.     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.fromInt:VAL"><CODE>fromInt <VAR>i</VAR>
          </CODE></A>
<DT> <CODE>          fromLargeInt <VAR>i</VAR>
          </CODE>
<DD>
convert integers to type <A HREF="#SIG:REAL.real:TY:SPEC">real</A>.     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.toLarge:VAL"><CODE>toLarge <VAR>x</VAR>
          </CODE></A>
<DT> <CODE>          fromLarge <VAR>mode</VAR> <VAR>x</VAR>
          </CODE>
<DD>
convert between values of type <A HREF="#SIG:REAL.real:TY:SPEC">real</A> and type           <A HREF="#SIG:REAL.real:TY:SPEC">LargeReal.real</A>.     
<BR>
<BR>

<DT> <A NAME="SIG:REAL.toDecimal:VAL"><CODE>toDecimal <VAR>r</VAR>
          </CODE></A>
<DT> <CODE>          fromDecimal <VAR>d</VAR>
          </CODE>
<DD>
convert between <A HREF="#SIG:REAL.real:TY:SPEC">real</A> values and decimal approximations.           Decimal approximations are to be converted using the            <A HREF="ieee-float.html#SIG:IEEE_REAL.rounding_mode:TY:SPEC">IEEEReal.TO_NEAREST</A> rounding mode.           <CODE>toDecimal</CODE> should produce only as many digits as are necessary           for <CODE>fromDecimal</CODE> to convert back to the same number,            i.e., for any <CODE>Normal</CODE> or <CODE>SubNormal</CODE> real value <VAR>r</VAR>,            we have: 
<PRE>
    fromDecimal (toDecimal <VAR>r</VAR>) = <VAR>r</VAR>.
</PRE>
<P>
For <CODE>toDecimal</CODE>, when the <CODE>kind</CODE> field is not <CODE>Normal</CODE> or <CODE>SubNormal</CODE>,  then <CODE>exp = 0</CODE> and <CODE>digits = []</CODE> except if <CODE>kind</CODE> is <CODE>NAN</CODE>, which case the <CODE>digits</CODE> field provides a decimal representation of the fraction field of <VAR>r</VAR>.
<P>
For <CODE>fromDecimal</CODE>, if <CODE>kind</CODE> is <CODE>ZERO</CODE> or <CODE>INF</CODE>, the resulting real is the appropriate signed zero or infinity, with the <CODE>digits</CODE> and <CODE>exp</CODE> fields ignored. If <CODE>kind</CODE> is <CODE>NAN</CODE>, a signed NaN is generated, where the <CODE>exp</CODE> field is ignored and the <CODE>digits</CODE> field  is used as the decimal representation of the fractional field. If the resulting fractional field has all zero bits, which corresponds to an infinity, <CODE>fromDecimal</CODE> raises the <A HREF="general.html#SIG:GENERAL.Domain:EXN:SPEC">Domain</A> exception. If <CODE>digits</CODE> is empty, an implementation-dependent NaN is produced. If <CODE>kind</CODE> is <CODE>NORMAL</CODE> or <CODE>SUBNORMAL</CODE>, the <CODE>sign</CODE>, <CODE>digits</CODE> and <CODE>exp</CODE> fields  are used to produce a real value. Note that the conversion itself should ignore the <CODE>kind</CODE> field, so that the resulting value might have class <CODE>NORMAL</CODE>, <CODE>SUBNORMAL</CODE> or <CODE>ZERO</CODE>. In particular, is <CODE>digits</CODE> is empty or a list of all 0's, the result should be a signed zero. 
<BLOCKQUOTE>
<B>Implementation note:</B><BR>

<P>
Algorithms for accurately and efficiently converting between binary and decimal real representations are readily available, e.g., see the technical report by <B>[CITE]</B>Gay/.
</BLOCKQUOTE>
   
<BR>
<BR>

</DL>
<HR>
<H4>Discussion</H4>
<P>
The sign of a zero is ignored in all comparisons.
<P>
Note that, if <VAR>x</VAR> is real, <CODE>~<VAR>x</VAR></CODE> is equivalent to <CODE>~(<VAR>x</VAR>)</CODE>, that is, it is identical to <VAR>x</VAR> but with its sign bit flipped.  In particular, the literal <CODE>~0.0</CODE> is just <CODE>0.0</CODE> with it sign bit set. On the other hand, this might not be the same as <CODE>0.0-0.0</CODE>,  in which rounding modes come into play.
<P>
Except for the <CODE>*+</CODE> and <CODE>*-</CODE> functions, arithmetic should be done in the exact precision specified by the <A HREF="#SIG:REAL.precision:VAL:SPEC">precision</A> value. In particular, arithmetic must not be done in some extended precision and then rounded.  
<BLOCKQUOTE>
<B>Implementation note:</B><BR>

<P>
Implementations may choose to provide a debugging mode, in which NaNs and Infs are detected when they are generated.
</BLOCKQUOTE>
<H4>See Also</H4>
<BLOCKQUOTE>
<A HREF="math.html#MATH:SIG:SPEC">MATH</A>, <A HREF="ieee-float.html#IEEEReal:STR:SPEC">IEEEReal</A>, <A HREF="string-cvt.html#StringCvt:STR:SPEC">StringCvt</A>
</BLOCKQUOTE>


<HR>
<CENTER>
<B>[ <A HREF="index-all.html">INDEX</A> | <A HREF="#top">TOP</A>
   | <A HREF="real-chapter.html">Parent</A> | <A HREF="sml-std-basis.html">Root</A>
   ]</B>
</CENTER>
<P>
<I>Last Modified October 5, 1997</I><BR>
<I>Comments to <A HREF="mailto:jhr@research.bell-labs.com">John Reppy.</A></I><BR>

Copyright &copy; 1997 Bell Labs, Lucent Technologies <BR>

<HR>
</BODY>
</HTML>
