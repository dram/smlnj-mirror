<!-- HTML/intro-chapter.html -->

<!-- COPYRIGHT (c) 1997 Bell Labs, Lucent Technologies. -->

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>Introduction</TITLE>
</HEAD>
<BODY>
<A NAME="top"></A>
<H1 align=CENTER>The Standard ML Basis Library</H1>
<HR>


<H2>Introduction</H2>
<P>
This document describes the <I>Standard ML Basis Library</I>. This library provides an extensive initial basis for Standard ML, which complements the language described by the <I>Definition of Standard ML</I>. The goals of the Basis Library are to: 
<UL>
<LI>
serve as the basic toolkit for the SML programmer,      whether novice or professional.   
<LI>
replace the many incompatible general-purpose libraries     currently available.   
<LI>
focus attention on the attractiveness of SML as a language     for programming in a wide variety of domains, e.g,. systems programming.
</UL>
 
<P>
In this chapter, we discuss the principles and conventions used in the  design of the Library, and present a high-level view of the library structure. 
<P>
By design, the Basis Library is meant to provide a fairly rich collection of general-purpose modules that can serve as the basis for applications programming or for more domain-specific libraries. One criterion for inclusion in the Basis Library is that a type or value requires compiler or run-time system support. In addition, the Library defines a standard minimal environment that anyone using SML can expect to find. The Library also attempts to provide similar functions in similar contexts. Thus, the traditional <CODE>app</CODE> function for lists, which applies a function to each member of a list, has also  been provided for arrays and vectors. 
<P>
An opposite design force has been the desire to keep the basis library small. In general, a function has been included only if it has clear or proven utility, with additional emphasis on those that are complicated to  implement, require compiler support, or are more concise or efficient  than an equivalent combination of other functions.  Some exceptions were made for historical reasons. 
<H3>Library modules</H3>
<P>
The Basis Library is contained in a set of structures. Almost every type, exception constructor and value belongs to some structure. Although some identifiers are also bound in the initial top-level environment we have attempted to keep the number of top-level identifiers small. Infix declarations and overloading are specified for the top-level environment. 
<P>
We view the signature and structure names used below as being reserved. For an implementation to be conforming, any module it provides that is named in the SML Basis Library must exactly match the description specified in the library. For example, the <CODE>Int</CODE> structure provided by an implementation should not match a superset of the <CODE>INTEGER</CODE> signature. If an implementation provides any types, values or modules  not described in the SML Basis Library, they must be encapsulated in additional  structures whose names are not used by the SML Basis Library. In particular, an implementation must not introduce any new non-module identifiers into the top-level environment. 
<H4>Required modules</H4>
<P>
We have divided the modules into <EM>required</EM> and <EM>optional</EM> categories. Any conforming implementation of SML Basis Library must provide implementations of all of the required modules. 
<P>
Many of the structures are variations on some generic module (e.g., single and double-precision floating-point numbers). The following table gives a list of the required generic signatures. 
<HR>
<CENTER>
<TABLE ALIGN=CENTER>
<TR>
<TH ALIGN=CENTER VALIGN=TOP>
<B>Signature</B>
<TH ALIGN=CENTER VALIGN=TOP>
<B>Description</B>
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>CHAR</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Generic character interface
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>INTEGER</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Generic integer interface
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>MATH</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Generic math library interface
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>IMPERATIVE_IO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Imperative I/O interface
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>MONO_ARRAY</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Mutable monomorphic arrays
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>MONO_VECTOR</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Immutable monomorphic vectors
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>PRIM_IO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
System-call operations for IO
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>REAL</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Generic real number interface
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>STREAM_IO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Stream I/O interface
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>STRING</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Generic string interface
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>SUBSTRING</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Generic substring interface
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>TEXT_IO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Text I/O interface
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>TEXT_STREAM_IO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Text stream I/O interface
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>WORD</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Generic word (i.e., unsigned modular integer) interface
</TABLE>
</CENTER>
<HR>
 Non-generic signatures typically define the interface of a unique structure. A list of the required non-generic signatures is given below. 
<HR>
<CENTER>
<TABLE ALIGN=CENTER>
<TR>
<TH ALIGN=CENTER VALIGN=TOP>
<B>Signature</B>
<TH ALIGN=CENTER VALIGN=TOP>
<B>Description</B>
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>ARRAY</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Mutable polymorphic arrays
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>BIN_IO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Binary input/output types and operations
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>BOOL</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Boolean type and values
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>BYTE</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Conversions between <TT>Word8</TT> and <TT>Char</TT> values
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>COMMAND_LINE</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Program name and arguments
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>DATE</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Calendar operations
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>GENERAL</TT>
<TD ALIGN=LEFT VALIGN=TOP>
General-purpose types, exceptions and values
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>IEEE_REAL</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Floating-point classes and hardware control
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>IO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Basic I/O types and exceptions
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>LIST</TT>
<TD ALIGN=LEFT VALIGN=TOP>
List type and utility functions
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>LIST_PAIR</TT>
<TD ALIGN=LEFT VALIGN=TOP>
List of pairs and utility functions
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>OPTION</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Optional values and partial functions
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>OS</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Basic operating system services
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>OS_FILE_SYS</TT>
<TD ALIGN=LEFT VALIGN=TOP>
File status and directory operations
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>OS_IO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Support for polling I/O devices
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>OS_PATH</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Pathname operations
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>OS_PROCESS</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Simple process operations
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>SML90</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Structure for backward compatability
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>STRING_CVT</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Support for conversions between strings and values
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>TIME</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Representation of time values
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>TIMER</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Timing operations
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>VECTOR</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Immutable polymorphic arrays
</TABLE>
</CENTER>
<HR>
 The required structures (and their signatures) are listed next. 
<HR>
<CENTER>
<TABLE ALIGN=CENTER>
<TR>
<TH ALIGN=CENTER VALIGN=TOP>
<B>Structure</B>
<TH ALIGN=CENTER VALIGN=TOP>
<B>Signature</B>
<TH ALIGN=CENTER VALIGN=TOP>
<B>Description</B>
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Array</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>ARRAY</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Mutable polymorphic arrays
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>BinIO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>BIN_IO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Binary input/output types and operations
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>BinPrimIO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>PRIM_IO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Low-level binary IO
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Bool</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>BOOL</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Boolean type and values
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Byte</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>BYTE</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Conversions between <TT>Word8</TT> and <TT>Char</TT> values
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Char</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>CHAR</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Default characters
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>CharArray</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>MONO_ARRAY</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Mutable arrays of characters
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>CharVector</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>MONO_VECTOR</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Immutable arrays of characters
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>CommandLine</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>COMMAND_LINE</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Program name and arguments
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Date</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>DATE</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Calendar operations
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>General</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>GENERAL</TT>
<TD ALIGN=LEFT VALIGN=TOP>
General-purpose types, exceptions and values
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>IEEEReal</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>IEEE_REAL</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Floating-point classes and hardware control
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Int</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>INTEGER</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Default integer type
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>IO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>IO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Basic I/O types and exceptions
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>LargeInt</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>INTEGER</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Largest integer representation
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>LargeReal</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>REAL</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Largest floating-point representation
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>LargeWord</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>WORD</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Largest word representation
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>List</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>LIST</TT>
<TD ALIGN=LEFT VALIGN=TOP>
List type and utility functions
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>ListPair</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>LIST_PAIR</TT>
<TD ALIGN=LEFT VALIGN=TOP>
List of pairs and utility functions
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Math</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>MATH</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Default math structure
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Option</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>OPTION</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Optional values and partial functions
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>OS</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>OS</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Basic operating system services
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>OS.FileSys</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>OS_FILE_SYS</TT>
<TD ALIGN=LEFT VALIGN=TOP>
File status and directory operations
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>OS.IO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>OS_IO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Support for polling I/O devices
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>OS.Path</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>OS_PATH</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Pathname operations
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>OS.Process</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>OS_PROCESS</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Simple process operations
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Position</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>INTEGER</TT>
<TD ALIGN=LEFT VALIGN=TOP>
File system positions
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Real</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>REAL</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Default floating-point type
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>SML90</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>SML90</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Structure for backward compatability
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>String</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>STRING</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Default strings
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>StringCvt</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>STRING_CVT</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Conversions between strings and various types
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Substring</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>SUBSTRING</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Substrings
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>TextIO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>TEXT_IO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Text input/output types and operations
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>TextPrimIO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>PRIM_IO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Low-level text IO
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Time</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>TIME</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Representation of time values
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Timer</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>TIMER</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Timing operations
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Vector</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>VECTOR</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Immutable polymorphic vectors
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Word</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>WORD</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Default word type
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Word8</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>WORD</TT>
<TD ALIGN=LEFT VALIGN=TOP>
8-bit words
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Word8Array</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>MONO_ARRAY</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Arrays of 8-bit words
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Word8Vector</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>MONO_VECTOR</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Vectors of 8-bit words
</TABLE>
</CENTER>
<HR>
 
<H4>Optional modules</H4>
<P>
The library specifies a large collection of signatures and structures that are considered optional in a conforming implementation. They provide features that, although useful, are not considered fundamental to a workable SML implementation. These modules include additional representations of integers, words, characters and reals; more efficient array and vector representations; and a subsystem providing Posix compatability.
<P>
Although an implementation may or may not provide one of these modules, if it provides one, the module must exactly match the specification  given in this document.  The names specified here for optional signatures and structures must be used at top-level only to denote implementations of the specified library module.  On the other hand, if an implementation offers features related to an optional module, it should also provide the optional module. 
<P>
The library specifies the following optional signatures. 
<HR>
<CENTER>
<TABLE ALIGN=CENTER>
<TR>
<TH ALIGN=CENTER VALIGN=TOP>
<B>Signature</B>
<TH ALIGN=CENTER VALIGN=TOP>
<B>Description</B>
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>ARRAY2</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Mutable polymorphic 2-dimensional arrays
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>INT_INF</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Arbitrary-precision integers
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>LOCALE</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Support for locale-dependent applications
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>MONO_ARRAY2</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Mutable monomorphic 2-dimensional arrays
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>MULTIBYTE</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Support for multibyte characters
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>PACK_REAL</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Support for packing floats into vectors of 8-bit words
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>PACK_WORD</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Support for packing words into vectors of 8-bit words
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>POSIX</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Root POSIX structure
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>POSIX_ERROR</TT>
<TD ALIGN=LEFT VALIGN=TOP>
POSIX error values
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>POSIX_FILE_SYS</TT>
<TD ALIGN=LEFT VALIGN=TOP>
POSIX file system operations
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>POSIX_FLAGS</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Support for sets of system flags
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>POSIX_IO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
POSIX I/O operations
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>POSIX_PROC_ENV</TT>
<TD ALIGN=LEFT VALIGN=TOP>
POSIX process environment operations
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>POSIX_PROCESS</TT>
<TD ALIGN=LEFT VALIGN=TOP>
POSIX process operations
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>POSIX_SIGNAL</TT>
<TD ALIGN=LEFT VALIGN=TOP>
POSIX signal types and values
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>POSIX_SYS_DB</TT>
<TD ALIGN=LEFT VALIGN=TOP>
POSIX system database types and values
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>POSIX_TTY</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Control of POSIX TTY drivers
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>UNIX</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Various Unix specific operations
</TABLE>
</CENTER>
<HR>
 The following table gives the set of optional structures. 
<HR>
<CENTER>
<TABLE ALIGN=CENTER>
<TR>
<TH ALIGN=CENTER VALIGN=TOP>
<B>Structure</B>
<TH ALIGN=CENTER VALIGN=TOP>
<B>Signature</B>
<TH ALIGN=CENTER VALIGN=TOP>
<B>Description</B>
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Array2</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>ARRAY2</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Mutable polymorphic 2-dimensional arrays
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>BoolArray</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>MONO_ARRAY</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Mutable arrays of booleans
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>BoolArray2</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>MONO_ARRAY2</TT>
<TD ALIGN=LEFT VALIGN=TOP>
2-dimensional arrays of booleans
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>BoolVector</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>MONO_VECTOR</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Immutable arrays of booleans
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>CharArray2</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>MONO_ARRAY2</TT>
<TD ALIGN=LEFT VALIGN=TOP>
2-dimensional arrays of characters
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>FixedInt</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>INTEGER</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Largest fixed precision integers
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>ImperativeIO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>IMPERATIVE_IO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Functor to convert stream I/O into imperative IO
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>IntInf</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>INT_INF</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Arbitrary-precision integers
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Int</TT><I>N</I>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>INTEGER</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<I>N</I>-bit, fixed precision integers
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>IntArray</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>MONO_ARRAY</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Mutable arrays of default integers
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Int</TT><I>N</I><TT>Array</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>MONO_ARRAY</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Mutable arrays of <I>N</I>-bit integers
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>IntArray2</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>MONO_ARRAY2</TT>
<TD ALIGN=LEFT VALIGN=TOP>
2-dimensional arrays of integers
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Int</TT><I>N</I><TT>Array2</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>MONO_ARRAY2</TT>
<TD ALIGN=LEFT VALIGN=TOP>
2-dimensional arrays of <I>N</I>-bit integers
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>IntVector</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>MONO_VECTOR</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Immutable vectors of default integers
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Int</TT><I>N</I><TT>Vector</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>MONO_VECTOR</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Immutable vectors of <I>N</I>-bit integers
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Locale</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>LOCALE</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Support for locale-dependent applications
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>MultiByte</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>MULTIBYTE</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Support for multibyte characters
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>PackReal</TT><I>N</I><TT>Big</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>PACK_REAL</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Big-endian packing for <I>N</I>-bit floats
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>PackReal</TT><I>N</I><TT>Little</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>PACK_REAL</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Little-endian packing for <I>N</I>-bit floats
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>PackRealBig</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>PACK_REAL</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Big-endian packing for default floats
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>PackRealLittle</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>PACK_REAL</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Little-endian packing for default floats
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Pack</TT><I>N</I><TT>Big</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>PACK_WORD</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Big-endian packing for <I>N</I>-byte words
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Pack</TT><I>N</I><TT>Little</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>PACK_WORD</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Little-endian packing for <I>N</I>-byte words
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Posix</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>POSIX</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Root POSIX structure
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Posix.Error</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>POSIX_ERROR</TT>
<TD ALIGN=LEFT VALIGN=TOP>
POSIX error values
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Posix.FileSys</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>POSIX_FILE_SYS</TT>
<TD ALIGN=LEFT VALIGN=TOP>
POSIX file system operations
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Posix.IO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>POSIX_IO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
POSIX I/O operations
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Posix.ProcEnv</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>POSIX_PROC_ENV</TT>
<TD ALIGN=LEFT VALIGN=TOP>
POSIX process environment operations
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Posix.Process</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>POSIX_PROCESS</TT>
<TD ALIGN=LEFT VALIGN=TOP>
POSIX process operations
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Posix.Signal</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>POSIX_SIGNAL</TT>
<TD ALIGN=LEFT VALIGN=TOP>
POSIX signal types and values
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Posix.SysDB</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>POSIX_SYS_DB</TT>
<TD ALIGN=LEFT VALIGN=TOP>
POSIX system database types and values
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Posix.TTY</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>POSIX_TTY</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Control of POSIX TTY drivers
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>PrimIO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>PRIM_IO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Functor to build <CODE>PRIM_IO</CODE> structure
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>RealArray</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>MONO_ARRAY</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Mutable arrays for default floats
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>RealVector</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>MONO_VECTOR</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Immutable vectors for default floats
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Real</TT><I>N</I>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>REAL</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<I>N</I>-bit floating-point numbers
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Real</TT><I>N</I><TT>Array</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>MONO_ARRAY</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Mutable arrays of <I>N</I>-bit floating-point numbers
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Real</TT><I>N</I><TT>Vector</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>MONO_VECTOR</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Immutable vectors of <I>N</I>-bit floating-point numbers
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>RealArray2</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>MONO_ARRAY2</TT>
<TD ALIGN=LEFT VALIGN=TOP>
2-dimensional arrays of floating-point numbers
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Real</TT><I>N</I><TT>Array2</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>MONO_ARRAY2</TT>
<TD ALIGN=LEFT VALIGN=TOP>
2-dimensional arrays of <I>N</I>-bit floating-point numbers
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>StreamIO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>STREAM_IO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Functor to convert primitive I/O into stream I/O
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>SysWord</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>WORD</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Words sufficient for OS operations
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>WideChar</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>CHAR</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Support for wide characters
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>WideCharArray</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>MONO_ARRAY</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Mutable arrays of wide characters
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>WideCharArray2</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>MONO_ARRAY2</TT>
<TD ALIGN=LEFT VALIGN=TOP>
2-dimensional arrays of wide characters
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>WideCharVector</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>MONO_VECTOR</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Immutable vectors of wide characters
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>WideString</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>STRING</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Support for wide strings
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>WideSubstring</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>SUBSTRING</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Support for wide substrings
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>WideTextPrimIO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>PRIM_IO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Low-level wide char IO
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>WideTextIO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>TEXT_IO</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Text I/O on wide characters
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Word</TT><I>N</I>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>WORD</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<I>N</I>-bit words
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Word8Array2</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>MONO_ARRAY2</TT>
<TD ALIGN=LEFT VALIGN=TOP>
2-dimensional arrays of 8-bit words
<TR>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>Unix</TT>
<TD ALIGN=LEFT VALIGN=TOP>
<TT>UNIX</TT>
<TD ALIGN=LEFT VALIGN=TOP>
Unix-like process invocation
</TABLE>
</CENTER>
<HR>
 
<H4>Module dependencies</H4>
<P>
We specify certain relationships among the modules. 
<UL>
<LI>
If <A HREF="large-int.html#IntInf:STR:SPEC">IntInf</A> is provided, then <A HREF="integer.html#LargeInt:STR:SPEC">LargeInt</A> must be a thinned     version of <A HREF="large-int.html#IntInf:STR:SPEC">IntInf</A>. Otherwise, if <A HREF="integer.html#LargeInt:STR:SPEC">LargeInt</A> is not the     same as <A HREF="integer.html#Int:STR:SPEC">Int</A>, then there must be a     structure Int{N} equal to <A HREF="integer.html#LargeInt:STR:SPEC">LargeInt</A>.   
<LI>
If <A HREF="word.html#LargeWord:STR:SPEC">LargeWord</A> is not the     same as <A HREF="word.html#Word:STR:SPEC">Word</A>, then there must be a     structure Word{N} equal to <A HREF="word.html#LargeWord:STR:SPEC">LargeWord</A>.   
<LI>
If <A HREF="real.html#LargeReal:STR:SPEC">LargeReal</A> is not the     same as <A HREF="real.html#Real:STR:SPEC">Real</A>, then there must be a     structure Real{N} equal to <A HREF="real.html#LargeReal:STR:SPEC">LargeReal</A>.   
<LI>
The signatures <A HREF="multibyte.html#MULTIBYTE:SIG:SPEC">MULTIBYTE</A> and <A HREF="locale.html#LOCALE:SIG:SPEC">LOCALE</A>, and the structures     <A HREF="locale.html#Locale:STR:SPEC">Locale</A>, <A HREF="char.html#WideChar:STR:SPEC">WideChar</A>, <A HREF="string.html#WideString:STR:SPEC">WideString</A>, <A HREF="substring.html#WideSubstring:STR:SPEC">WideSubstring</A>,     <A HREF="mono-vector.html#WideCharVector:STR:SPEC">WideCharVector</A>, <A HREF="mono-array.html#WideCharArray:STR:SPEC">WideCharArray</A> and WideTextIO     are optional as a group.   
<LI>
The <A HREF="posix.html#Posix:STR:SPEC">Posix</A> structures and signatures plus <A HREF="word.html#SysWord:STR:SPEC">SysWord</A>     are optional as a group.
</UL>
 
<H4>Backward compatability</H4>
<P>
To permit users to compile programs written under the old basis, we require that each implementation provide the structure <CODE>SML90</CODE>. This structure contains the top-level bindings specified in the 1990 version of the <B>[CITE]</B>Definition/, along with one or more substructures that define the top-level  bindings of various implementations. For example, a user might write: 
<PRE>
local
  open SML90 SML90.SMLNJ
in
  (* user's program *)
end
</PRE>
 to compile a user's program under the old SML/NJ basis.
<P>
We expect that at some future point, the <CODE>SML90</CODE> module will be deemed obsolete, and will be dropped from the standard basis.
<H3>Design rules and conventions</H3>
<P>
In designing the library, we have tried to follow a set of stylistic rules to make library usage consistent and predictable, and to preclude certain errors. These rules are not meant to be prescriptive for the programmer using or extending the library. On the other hand, although the  library itself thwarts the conventions on occasion,  we feel the rules are reasonable and helpful, and would encourage their use. 
<H4>Orthographic conventions</H4>
<P>
We use a new set of spelling and capitalization conventions. Some of these conventions, e.g., the capitalization of value constructors, seem to be widely accepted in the user community. Other decisions were based less on dominant style or compelling reason than on compromise and the need for consistency and some sense of good taste.
<P>
The conventions we use are: 
<UL>
<LI>
Alphanumeric value variables are in mixed-case, with a leading lower-case     letter; e.g., <CODE>map</CODE>, <CODE>openIn</CODE>.   
<LI>
Type identifiers are all lower case, with words separated     by underscores; e.g., <CODE>word</CODE>, <CODE>file_desc</CODE>.   
<LI>
Signature identifiers are in all capitals, with words      separated by underscore; e.g., <CODE>PACK_WORD</CODE>, <CODE>OS_PATH</CODE>.      We refer to this as the <I>signature</I> convention.   
<LI>
Structure and functor identifiers are in mixed-case, with initial letters      of words capitalized; e.g., <CODE>General</CODE>, <CODE>WideChar</CODE>.     We refer to this as the <I>structure</I> convention.   
<LI>
Alphanumeric datatype constructors use the signature convention;     e.g., <CODE>SOME</CODE>, <CODE>A_READ</CODE>, <CODE>FOLLOW_ALL</CODE>. In certain     cases, where external usage or aesthetics dictates otherwise, the     structure convention is followed; e.g., <CODE>Jan</CODE>, <CODE>Mon</CODE>.     Within the basis library, the only use of the latter convention occurs     with the months and weekdays in <A HREF="date.html#Date:STR:SPEC">Date</A>.     The only exceptions to these rules are the      identifiers <CODE>nil</CODE>, <CODE>true</CODE> and <CODE>false</CODE>, where we bow to tradition.   
<LI>
Exception identifiers use the structure convention;     e.g., <CODE>Domain</CODE>, <CODE>TerminatedStream</CODE>.
</UL>
  The above conventions concerning variable and constructor names, if followed consistently, can be used by a compiler to aid in detecting the subtle  error in which a constructor is misspelled in a pattern-match and is  thus treated as a variable binding. Some implementations may provide the option of enforcing these conventions by generating warning messages. 
<H4>Naming</H4>
<P>
Similar values should have similar names, with similar type shapes, following the conventions outlined above.  For example, the function <CODE>Array.app</CODE> has the type: 
<PRE>
    val app : ('a -&gt; unit) -&gt; 'a array -&gt; unit
</PRE>
 which has the same shape as <CODE>List.app</CODE>. Names should be meaningful, but concise. We have broken this rule, however, in certain instances where previous usage seemed compelling. For example, we have kept the name <CODE>app</CODE> rather than adopt <CODE>apply</CODE>. More dramatically, we have purposely kept most of the traditional Unix names in the optional <A HREF="posix.html#Posix:STR:SPEC">Posix</A> modules, to capitalize on the familiarity of these names and the available documentation. 
<H4>Comparisons</H4>
<P>
Many structures define a type <CODE>ty</CODE> along with a comparison function 
<PRE>
    val compare : ty * ty -&gt; order
</PRE>
 plus the expected relational operators <CODE>&gt;</CODE>, <CODE>&gt;=</CODE>, <CODE>&lt;</CODE> and <CODE>&lt;=</CODE>. In all cases, the standard relationships hold between these functions. For example, we have <CODE><VAR>x</VAR> &gt; <VAR>y</VAR> = true</CODE> if and only if <CODE>compare(<VAR>x</VAR>, <VAR>y</VAR>) = GREATER</CODE>. If, in addition, <CODE>ty</CODE> is an equality type, we assume that the operators <CODE>=</CODE> and <CODE>&lt;&gt;</CODE> satisfy the usual relationships with <CODE>compare</CODE> and the relational operators. For example, if <CODE>x = y</CODE>, then <CODE>compare(x,y) = EQUAL</CODE>. Note that these assumptions are not quite true for <A HREF="real.html#SIG:REAL.real:TY:SPEC">real</A> values; see the <A HREF="real.html#REAL:SIG:SPEC">REAL</A> signature for more details.
<P>
Types that have a standard or obvious linear order come with the full set of relational operators plus a <CODE>compare</CODE> function. Certain abstract types, e.g., <A HREF="os-file-sys.html#SIG:OS_FILE_SYS.file_id:TY:SPEC">OS.FileSys.file_id</A>, provide a <CODE>compare</CODE> function for use with, for example, ordered binary trees.
<H4>Conversions</H4>
<P>
Most structures defining a type provide conversion functions to and from other types. When unambiguous, we use the naming convention <TT>to<I>T</I></TT> and <TT>from<I>T</I></TT>, where <I>T</I> is some version of  the name of the other type.  For example, in <A HREF="word.html#WORD:SIG:SPEC">WORD</A>, we have 
<PRE>
    val fromInt : Int.int -&gt; word
    val toInt : word -&gt; Int.int
</PRE>
 If this naming is ambiguous (e.g., a structure defines multiple types that have conversions from integers), we use the convention <TT><I>T</I>From<I>TT</I></TT> and <TT><I>T</I>To<I>TT</I></TT>. For example, in <A HREF="posix-proc-env.html#POSIX_PROC_ENV:SIG:SPEC">POSIX_PROC_ENV</A>, we have 
<PRE>
    val uidToWord : uid -&gt; SysWord.word
    val gidToWord : gid -&gt; SysWord.word
</PRE>
<P>
There should be conversions to and from strings for most types. Following the convention above, these functions are typically called <CODE>toString</CODE> and <CODE>fromString</CODE>. Usually, modules provide additional string conversion functions that allow more control over format and operate on an abstract character stream. These functions are called <CODE>fmt</CODE> and <CODE>scan</CODE>. The input accepted by <CODE>fromString</CODE> and <CODE>scan</CODE> consists of printable ASCII characters. The output generated by <CODE>toString</CODE> and <CODE>fmt</CODE> consists of printable ASCII characters.
<P>
We adopt the convention that conversions from strings should be forgiving, allowing initial white space and multiple formats,  and ignoring additional terminating characters. On the other hand, we have tried to specify conversions to strings precisely. In addition, for basic types, scanning functions should accept legal SML literals, and formatting functions should, whenever possible, produce the value part of a valid SML literal but, for flexibility, may omit  certain annotations. For example, <CODE>String.toString</CODE> produces a valid SML string constant, but without the enclosing quotes, and <CODE>Word.toString</CODE> produces a word constant without the <CODE>&quot;0wx&quot;</CODE> prefix. 
<H4>Characters and strings</H4>
<P>
The old basis did not provide a character type, only a string type. To manipulate characters, programmers used integers corresponding to the  character's code. This was unsatisfactory for several reasons: 
<UL>
<LI>
No symbolic names for pattern matching single characters   
<LI>
Character to string conversions require unnecessary range checks   
<LI>
There is no provision for the extended character sets necessary     for international use.
</UL>
 Alternatively, programmers used strings of length one to represent characters, which is less efficient and cannot be enforced by the type system.
<P>
The revised SML Definition introduces a new <CODE>char</CODE> type and literal syntax along with old <CODE>string</CODE> type. The SML Standard Basis provides support for both <CODE>string</CODE> and <CODE>char</CODE> types, where the <CODE>string</CODE> type is a <EM>vector</EM> of characters. In addition, we define the optional types <CODE>WideString.string</CODE> and <CODE>WideChar.char</CODE>, in which the former is again a vector of the latter, for handling character sets more extensive than Latin-1. 
<H4>Miscellany</H4>
<P>
Functional arguments that are evaluated solely for their side-effects should have a return type of <CODE>unit</CODE>. For example, the list application function should have the type: 
<PRE>
   val app : ('a -&gt; unit) -&gt; 'a list -&gt; unit
</PRE>


<HR>
<CENTER>
<B>[ <A HREF="index-all.html">INDEX</A> | <A HREF="#top">TOP</A>
   | <A HREF="sml-std-basis.html">Parent</A> | <A HREF="sml-std-basis.html">Root</A>
   ]</B>
</CENTER>
<P>
<I>Last Modified August 5, 1997</I><BR>
<I>Comments to <A HREF="mailto:jhr@research.bell-labs.com">John Reppy.</A></I><BR>

Copyright &copy; 1997 Bell Labs, Lucent Technologies <BR>

<HR>
</BODY>
</HTML>
