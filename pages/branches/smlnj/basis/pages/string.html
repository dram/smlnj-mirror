<!-- HTML/string.html -->

<!-- COPYRIGHT (c) 1997 Bell Labs, Lucent Technologies. -->

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>The STRING signature</TITLE>
</HEAD>
<BODY>
<A NAME="top"></A>
<H1 align="CENTER">The Standard ML Basis Library</H1>
<HR>


<H3>The <CODE>STRING</CODE> signature</H3>
<P>
The STRING signature specifies the basic operations on a string type, which is a vector of the underlying character type <A HREF="char.html#SIG:CHAR.char:TY:SPEC">char</A> as defined in the substructure <A HREF="#SIG:STRING.Char:STR:SPEC">Char</A>.
<P>
The <A HREF="#STRING:SIG:SPEC">STRING</A> signature is matched by two structures, the required <A HREF="#String:STR:SPEC">String</A> and the optional <A HREF="#WideString:STR:SPEC">WideString</A>. The former implements strings based on 8-bit characters. The latter provides strings of characters of some size greater than or equal to 8 bits. In particular, structure <A HREF="#SIG:STRING.Char:STR:SPEC">String.Char</A> is identical to the structure <A HREF="char.html#Char:STR:SPEC">Char</A> and, when defined, the structure <A HREF="#SIG:STRING.Char:STR:SPEC">WideString.Char</A> is identical to <A HREF="char.html#WideChar:STR:SPEC">WideChar</A>. In addition, the type <A HREF="#SIG:STRING.string:TY:SPEC">String.string</A> is identical to <A HREF="mono-vector.html#SIG:MONO_VECTOR.vector:TY:SPEC">CharVector.vector</A>, and the type <A HREF="#SIG:STRING.string:TY:SPEC">WideString.string</A> is identical to <A HREF="mono-vector.html#SIG:MONO_VECTOR.vector:TY:SPEC">WideCharVector.vector</A>. 
<HR>
<H4>Synopsis</H4>
<BLOCKQUOTE>
<CODE><B>signature </B><A NAME="STRING:SIG:SPEC"><CODE>STRING</CODE></A><BR>
<B>structure </B><A NAME="String:STR:SPEC"><CODE>String</CODE></A><B> : </B>STRING<BR>
<B>structure </B><A NAME="WideString:STR:SPEC"><CODE>WideString</CODE></A><B> : </B>STRING<BR>
</CODE>
</BLOCKQUOTE>
<HR>
<H4>Interface</H4>
<BLOCKQUOTE>
<CODE><B>eqtype</B> <A NAME="SIG:STRING.string:TY:SPEC" HREF="#SIG:STRING.string:TY">string</A><BR>
<B>structure</B> <A NAME="SIG:STRING.Char:STR:SPEC" HREF="#SIG:STRING.Char:STR">Char</A> <B>:</B> CHAR<BR>
<B>val</B> <A NAME="SIG:STRING.maxSize:VAL:SPEC" HREF="#SIG:STRING.maxSize:VAL">maxSize</A> <B>:</B> int         <BR>
<B>val</B> <A NAME="SIG:STRING.size:VAL:SPEC" HREF="#SIG:STRING.size:VAL">size</A> <B>:</B> string -&gt; int         <BR>
<B>val</B> <A NAME="SIG:STRING.sub:VAL:SPEC" HREF="#SIG:STRING.sub:VAL">sub</A> <B>:</B> (string * int) -&gt; Char.char         <BR>
<B>val</B> <A NAME="SIG:STRING.extract:VAL:SPEC" HREF="#SIG:STRING.extract:VAL">extract</A> <B>:</B> (string * int * int option) -&gt; string         <BR>
<B>val</B> <A NAME="SIG:STRING.substring:VAL:SPEC" HREF="#SIG:STRING.extract:VAL">substring</A> <B>:</B> (string * int * int) -&gt; string         <BR>
<B>val</B> <A NAME="SIG:STRING.concat:VAL:SPEC" HREF="#SIG:STRING.concat:VAL">concat</A> <B>:</B> string list -&gt; string         <BR>
<B>val</B> <A NAME="SIG:STRING.^:VAL:SPEC" HREF="#SIG:STRING.^:VAL">^</A> <B>:</B> (string * string) -&gt; string         <BR>
<B>val</B> <A NAME="SIG:STRING.str:VAL:SPEC" HREF="#SIG:STRING.str:VAL">str</A> <B>:</B> Char.char -&gt; string         <BR>
<B>val</B> <A NAME="SIG:STRING.implode:VAL:SPEC" HREF="#SIG:STRING.implode:VAL">implode</A> <B>:</B> Char.char list -&gt; string         <BR>
<B>val</B> <A NAME="SIG:STRING.explode:VAL:SPEC" HREF="#SIG:STRING.explode:VAL">explode</A> <B>:</B> string -&gt; Char.char list         <BR>
<B>val</B> <A NAME="SIG:STRING.map:VAL:SPEC" HREF="#SIG:STRING.map:VAL">map</A> <B>:</B> (Char.char -&gt; Char.char) -&gt; string -&gt; string         <BR>
<B>val</B> <A NAME="SIG:STRING.translate:VAL:SPEC" HREF="#SIG:STRING.translate:VAL">translate</A> <B>:</B> (Char.char -&gt; string) -&gt; string -&gt; string         <BR>
<B>val</B> <A NAME="SIG:STRING.tokens:VAL:SPEC" HREF="#SIG:STRING.tokens:VAL">tokens</A> <B>:</B> (Char.char -&gt; bool) -&gt; string -&gt; string list       <BR>
<B>val</B> <A NAME="SIG:STRING.fields:VAL:SPEC" HREF="#SIG:STRING.tokens:VAL">fields</A> <B>:</B> (Char.char -&gt; bool) -&gt; string -&gt; string list         <BR>
<B>val</B> <A NAME="SIG:STRING.isPrefix:VAL:SPEC" HREF="#SIG:STRING.isPrefix:VAL">isPrefix</A> <B>:</B> string -&gt; string -&gt; bool         <BR>
<B>val</B> <A NAME="SIG:STRING.compare:VAL:SPEC" HREF="#SIG:STRING.compare:VAL">compare</A> <B>:</B> (string * string) -&gt; order         <BR>
<B>val</B> <A NAME="SIG:STRING.collate:VAL:SPEC" HREF="#SIG:STRING.collate:VAL">collate</A> <B>:</B> ((Char.char * Char.char) -&gt; order) -&gt; (string * string) -&gt; order         <BR>
<B>val</B> <A NAME="SIG:STRING.\|@LT\|:VAL:SPEC" HREF="#SIG:STRING.\|@LT\|:VAL">&lt;</A> <B>:</B> (string * string) -&gt; bool       <BR>
<B>val</B> <A NAME="SIG:STRING.\|@LTE\|:VAL:SPEC" HREF="#SIG:STRING.\|@LT\|:VAL">&lt;=</A> <B>:</B> (string * string) -&gt; bool       <BR>
<B>val</B> <A NAME="SIG:STRING.\|@GT\|:VAL:SPEC" HREF="#SIG:STRING.\|@LT\|:VAL">&gt;</A> <B>:</B> (string * string) -&gt; bool       <BR>
<B>val</B> <A NAME="SIG:STRING.\|@GTE\|:VAL:SPEC" HREF="#SIG:STRING.\|@LT\|:VAL">&gt;=</A> <B>:</B> (string * string) -&gt; bool         <BR>
<B>val</B> <A NAME="SIG:STRING.fromString:VAL:SPEC" HREF="#SIG:STRING.fromString:VAL">fromString</A> <B>:</B> String.string -&gt; string option         <BR>
<B>val</B> <A NAME="SIG:STRING.toString:VAL:SPEC" HREF="#SIG:STRING.toString:VAL">toString</A> <B>:</B> string -&gt; String.string         <BR>
<B>val</B> <A NAME="SIG:STRING.fromCString:VAL:SPEC" HREF="#SIG:STRING.fromCString:VAL">fromCString</A> <B>:</B> String.string -&gt; string option         <BR>
<B>val</B> <A NAME="SIG:STRING.toCString:VAL:SPEC" HREF="#SIG:STRING.toCString:VAL">toCString</A> <B>:</B> string -&gt; String.string         <BR>
</CODE>
</BLOCKQUOTE>
<H4>Description</H4>
<DL>
<DT> <A NAME="SIG:STRING.string:TY"><CODE><B>eqtype</B> string</CODE></A>
<DD>
<BR>

<DT> <A NAME="SIG:STRING.Char:STR"><CODE><B>structure</B> Char</CODE></A>
<DD>
<BR>

<DT> <A NAME="SIG:STRING.maxSize:VAL"><CODE>maxSize
          </CODE></A>
<DD>
is the longest allowed length of a string.     
<BR>
<BR>

<DT> <A NAME="SIG:STRING.size:VAL"><CODE>size <VAR>s</VAR>
          </CODE></A>
<DD>
returns the number of characters in string <VAR>s</VAR>.     
<BR>
<BR>

<DT> <A NAME="SIG:STRING.sub:VAL"><CODE>sub (<VAR>s</VAR>, <VAR>i</VAR>)
          </CODE></A>
<DD>
returns the <VAR>i</VAR>th character of <VAR>s</VAR>, counting from zero.           This raises <A HREF="general.html#SIG:GENERAL.Subscript:EXN:SPEC">Subscript</A> if <VAR>i</VAR> &lt; 0 or            <CODE>size</CODE> <VAR>s</VAR> &lt;= <VAR>i</VAR>.     
<BR>
<BR>

<DT> <A NAME="SIG:STRING.extract:VAL"><CODE>extract (<VAR>s</VAR>, <VAR>i</VAR>, <A HREF="option.html#SIG:OPTION.option:TY:SPEC">NONE</A>)
          </CODE></A>
<DT> <CODE>          extract (<VAR>s</VAR>, <VAR>i</VAR>, <A HREF="option.html#SIG:OPTION.option:TY:SPEC">SOME</A> <VAR>j</VAR>)
          </CODE>
<DT> <CODE>          substring (<VAR>s</VAR>, <VAR>i</VAR>, <VAR>j</VAR>)
          </CODE>
<DD>
return substrings of <VAR>s</VAR>.            The first returns the substring of            <VAR>s</VAR> from the <VAR>i</VAR>th character to           the end of the string, i.e.,            the string <CODE><VAR>s</VAR>[<VAR>i</VAR>..<A HREF="#SIG:STRING.size:VAL:SPEC">size</A> <VAR>s</VAR>-1]</CODE>.           This raises <A HREF="general.html#SIG:GENERAL.Subscript:EXN:SPEC">Subscript</A> if <CODE><VAR>i</VAR> &lt; 0</CODE> or            <CODE><A HREF="#SIG:STRING.size:VAL:SPEC">size</A> <VAR>s</VAR> &lt; <VAR>i</VAR></CODE>.           The second form returns the substring            of length <VAR>j</VAR> starting at index <VAR>i</VAR>, i.e.,            the string <CODE><VAR>s</VAR>[<VAR>i</VAR>..<VAR>i</VAR>+<VAR>j</VAR>-1]</CODE>.           It raises <A HREF="general.html#SIG:GENERAL.Subscript:EXN:SPEC">Subscript</A> if <VAR>i</VAR> &lt; 0 or            <VAR>j</VAR> &lt; 0 or            <CODE>size</CODE> <VAR>s</VAR> &lt; <VAR>i</VAR> + <VAR>j</VAR>.           Note that, if defined, <A HREF="#SIG:STRING.extract:VAL:SPEC">extract</A> returns the empty string           when <CODE><VAR>i</VAR> = <A HREF="#SIG:STRING.size:VAL:SPEC">size</A> <VAR>s</VAR></CODE>.           
<P>
          The third form returns           the substring of length <VAR>j</VAR> starting           at index <VAR>i</VAR>, i.e.,            the string <CODE><VAR>s</VAR>[<VAR>i</VAR>..<VAR>i</VAR>+<VAR>j</VAR>-1]</CODE>.           This is equivalent to            <CODE><A HREF="#SIG:STRING.extract:VAL:SPEC">extract</A>(<VAR>s</VAR>, <VAR>i</VAR>, <A HREF="option.html#SIG:OPTION.option:TY:SPEC">SOME</A> <VAR>j</VAR>)</CODE>.           
<BLOCKQUOTE>
<B>Implementation note:</B><BR>

<P>
Note that implementations of these functions must perform           bounds checking in such a way that the <A HREF="general.html#SIG:GENERAL.Overflow:EXN:SPEC">Overflow</A> exception           is not raised.           
</BLOCKQUOTE>
     
<BR>
<BR>

<DT> <A NAME="SIG:STRING.concat:VAL"><CODE>concat <VAR>l</VAR>
          </CODE></A>
<DD>
is the concatenation of all the strings in <VAR>l</VAR>.           This raises <A HREF="general.html#SIG:GENERAL.Size:EXN:SPEC">Size</A> if the sum of all the sizes           is greater than <A HREF="#SIG:STRING.maxSize:VAL:SPEC">maxSize</A>.     
<BR>
<BR>

<DT> <A NAME="SIG:STRING.^:VAL"><CODE><VAR>s</VAR> ^ <VAR>t</VAR>
          </CODE></A>
<DD>
is the concatenation of the strings <VAR>s</VAR> and <VAR>t</VAR>.           This raises <A HREF="general.html#SIG:GENERAL.Size:EXN:SPEC">Size</A> if           <CODE>size</CODE> <VAR>s</VAR> + <CODE>size</CODE> <VAR>t</VAR> &gt; <CODE>maxSize</CODE>.     
<BR>
<BR>

<DT> <A NAME="SIG:STRING.str:VAL"><CODE>str <VAR>c</VAR>
          </CODE></A>
<DD>
is the string of size one containing the character <VAR>c</VAR>.     
<BR>
<BR>

<DT> <A NAME="SIG:STRING.implode:VAL"><CODE>implode <VAR>l</VAR>
          </CODE></A>
<DD>
generates the string containing the characters in the list <VAR>l</VAR>.           This is equivalent to            <CODE><A HREF="#SIG:STRING.concat:VAL:SPEC">concat</A> (<A HREF="list.html#SIG:LIST.map:VAL:SPEC">List.map</A> <A HREF="#SIG:STRING.str:VAL:SPEC">str</A> <VAR>l</VAR>)</CODE>.     
<BR>
<BR>

<DT> <A NAME="SIG:STRING.explode:VAL"><CODE>explode <VAR>s</VAR>
          </CODE></A>
<DD>
is the list of characters in the string <VAR>s</VAR>.     
<BR>
<BR>

<DT> <A NAME="SIG:STRING.map:VAL"><CODE>map <VAR>f</VAR> <VAR>s</VAR>
          </CODE></A>
<DD>
applies <VAR>f</VAR> to each element of <VAR>s</VAR> from left to right,         returning the resulting string. It is equivalent to         <CODE><A HREF="mono-vector.html#SIG:MONO_VECTOR.map:VAL:SPEC">CharVector.map</A></CODE> and           <CODE><A HREF="#SIG:STRING.implode:VAL:SPEC">implode</A>(<A HREF="list.html#SIG:LIST.map:VAL:SPEC">List.map</A> <VAR>f</VAR> (<A HREF="#SIG:STRING.explode:VAL:SPEC">explode</A> <VAR>s</VAR>))</CODE>.      
<BR>
<BR>

<DT> <A NAME="SIG:STRING.translate:VAL"><CODE>translate <VAR>f</VAR> <VAR>s</VAR>
          </CODE></A>
<DD>
returns the string generated from <VAR>s</VAR> by mapping each character           in <VAR>s</VAR> by <VAR>f</VAR>. It is equivalent to           <CODE><A HREF="#SIG:STRING.concat:VAL:SPEC">concat</A>(<A HREF="list.html#SIG:LIST.map:VAL:SPEC">List.map</A> <VAR>f</VAR> (<A HREF="#SIG:STRING.explode:VAL:SPEC">explode</A> <VAR>s</VAR>))</CODE>.     
<BR>
<BR>

<DT> <A NAME="SIG:STRING.tokens:VAL"><CODE>tokens <VAR>p</VAR> <VAR>s</VAR>
          </CODE></A>
<DT> <CODE>          fields <VAR>p</VAR> <VAR>s</VAR>
          </CODE>
<DD>
These functions return a list of tokens or fields, respectively,           derived from <VAR>s</VAR> from left to right.           A token is a non-empty maximal substring of <VAR>s</VAR> not containing           any delimiter.           A field is a (possibly empty) maximal substring of <VAR>s</VAR> not containing           any delimiter. In both cases, a delimiter is a character satisfying the           predicate <VAR>p</VAR>.           
<P>
          Two tokens may be separated by more than one delimiter, whereas two           fields are separated by exactly one delimiter. For example, if the only            delimiter is the character <CODE>#&quot;|&quot;</CODE>, then the string           <CODE>&quot;|abc||def&quot;</CODE> contains two tokens <CODE>&quot;abc&quot;</CODE>            and <CODE>&quot;def&quot;</CODE>, whereas it contains           the four fields <CODE>&quot;&quot;</CODE>, <CODE>&quot;abc&quot;</CODE>, <CODE>&quot;&quot;</CODE> and <CODE>&quot;def&quot;</CODE>.     
<BR>
<BR>

<DT> <A NAME="SIG:STRING.isPrefix:VAL"><CODE>isPrefix <VAR>s1</VAR> <VAR>s2</VAR>
          </CODE></A>
<DD>
returns <CODE>true</CODE> if the string <VAR>s1</VAR> is a prefix of the string           <VAR>s2</VAR>.     
<BR>
<BR>

<DT> <A NAME="SIG:STRING.compare:VAL"><CODE>compare (<VAR>s</VAR>, <VAR>t</VAR>)
          </CODE></A>
<DD>
does a lexicographic comparison of the two strings using the           ordering <A HREF="char.html#SIG:CHAR.compare:VAL:SPEC">Char.compare</A> on the characters.            It returns <A HREF="general.html#SIG:GENERAL.order:TY:SPEC">LESS</A>, <A HREF="general.html#SIG:GENERAL.order:TY:SPEC">EQUAL</A>, 	  or <A HREF="general.html#SIG:GENERAL.order:TY:SPEC">GREATER</A>, if <VAR>s</VAR> is less than, equal to, or           greater than <VAR>t</VAR>, respectively.     
<BR>
<BR>

<DT> <A NAME="SIG:STRING.collate:VAL"><CODE>collate <VAR>f</VAR> (<VAR>s</VAR>, <VAR>t</VAR>)
          </CODE></A>
<DD>
performs lexicographic comparison of the two strings using the           given ordering <VAR>f</VAR> on characters.     
<BR>
<BR>

<DT> <A NAME="SIG:STRING.\|@LT\|:VAL"><CODE><VAR>s</VAR> &lt; <VAR>t</VAR>
          </CODE></A>
<DT> <CODE>          <VAR>s</VAR> &lt;= <VAR>t</VAR>
          </CODE>
<DT> <CODE>          <VAR>s</VAR> &gt; <VAR>t</VAR>
          </CODE>
<DT> <CODE>          <VAR>s</VAR> &gt;= <VAR>t</VAR>
          </CODE>
<DD>
compare two strings lexicographically.     
<BR>
<BR>

<DT> <A NAME="SIG:STRING.fromString:VAL"><CODE>fromString <VAR>s</VAR>
          </CODE></A>
<DD>
scans a printable string <VAR>s</VAR> as an SML source program string,           converting escape sequences into the appropriate characters.             It does not skip leading whitespace. It returns as many characters           as it can successfully scan, stopping when it reaches the end            of <VAR>s</VAR> or a non-printing character,            or if it encounters an improper escape sequence.           These additional characters are ignored.           If no conversion is possible, e.g., if the first character           is non-printable or begins an illegal escape sequence,            <A HREF="option.html#SIG:OPTION.option:TY:SPEC">NONE</A> is returned.           Note, however, that <CODE><A HREF="#SIG:STRING.fromString:VAL:SPEC">fromString</A> &quot;&quot;</CODE>           returns <CODE>SOME &quot;&quot;</CODE>.           
<P>
          For more information on the allowed escape sequences, see the           entry for <A HREF="char.html#SIG:CHAR.fromString:VAL:SPEC">CHAR.fromString</A>.     
<BR>
<BR>

<DT> <A NAME="SIG:STRING.toString:VAL"><CODE>toString <VAR>s</VAR>
          </CODE></A>
<DD>
returns a string corresponding to <VAR>s</VAR>, with           non-printable characters replaced by SML escape sequences.           This is equivalent to            
<P>
          <CODE><A HREF="#SIG:STRING.translate:VAL:SPEC">translate</A> <A HREF="char.html#SIG:CHAR.toString:VAL:SPEC">Char.toString</A> <VAR>s</VAR></CODE>     
<BR>
<BR>

<DT> <A NAME="SIG:STRING.fromCString:VAL"><CODE>fromCString <VAR>s</VAR>
          </CODE></A>
<DD>
scans the string <VAR>s</VAR> as a C source program string,           converting C escape sequences into the appropriate characters.             The semantics are identical to <A HREF="#SIG:STRING.fromString:VAL:SPEC">fromString</A> above,           except that C escape sequences are            used (cf. ISO C standard ISO/IEC <B>[CITE]</B>9899:1990/).           
<P>
          For more information on the allowed escape sequences, see the           entry for <A HREF="char.html#SIG:CHAR.fromCString:VAL:SPEC">CHAR.fromCString</A>.     
<BR>
<BR>

<DT> <A NAME="SIG:STRING.toCString:VAL"><CODE>toCString <VAR>s</VAR>
          </CODE></A>
<DD>
returns a string corresponding to <VAR>s</VAR>, with           non-printable characters replaced by C escape sequences.           This is equivalent to            
<P>
          <CODE><A HREF="#SIG:STRING.translate:VAL:SPEC">translate</A> <A HREF="char.html#SIG:CHAR.toCString:VAL:SPEC">Char.toCString</A> <VAR>s</VAR></CODE>   
<BR>
<BR>

</DL>
<HR>
<H4>See Also</H4>
<BLOCKQUOTE>
<A HREF="char.html#CHAR:SIG:SPEC">CHAR</A>, <A HREF="substring.html#SUBSTRING:SIG:SPEC">SUBSTRING</A>, <A HREF="string-cvt.html#StringCvt:STR:SPEC">StringCvt</A>, <A HREF="multibyte.html#MultiByte:STR:SPEC">MultiByte</A>, <A HREF="mono-vector.html#CharVector:STR:SPEC">CharVector</A>, <A HREF="mono-array.html#CharArray:STR:SPEC">CharArray</A>, <A HREF="mono-vector.html#WideCharVector:STR:SPEC">WideCharVector</A>
</BLOCKQUOTE>


<HR>
<CENTER>
<B>[ <A HREF="index-all.html">INDEX</A> | <A HREF="#top">TOP</A>
   | <A HREF="text-chapter.html">Parent</A> | <A HREF="sml-std-basis.html">Root</A>
   ]</B>
</CENTER>
<P>
<I>Last Modified October 6, 1997</I><BR>
<I>Comments to <A HREF="mailto:jhr@research.bell-labs.com">John Reppy.</A></I><BR>

Copyright &copy; 1997 Bell Labs, Lucent Technologies <BR>

<HR>
</BODY>
</HTML>
