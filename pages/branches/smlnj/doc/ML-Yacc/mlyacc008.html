<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset= ISO-8859-1">
<TITLE>
 Signatures
</TITLE>
</HEAD>
<BODY BGCOLOR=silver TEXT=black>
<A HREF="mlyacc007.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="mlyacc009.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
<A HREF="index.html"><IMG SRC ="contents_motif.gif" ALT="Contents"></A>
<HR>

<H2>8&nbsp;&nbsp; Signatures</H2>This section contains signatures used by ML-Yacc for structures in
the file base.sml, functors and structures that it generates, and for
the signatures of lexer structures supplied by you.<BR>
<BR>
<A NAME="toc17"></A>
<H3>8.1&nbsp;&nbsp; Parsing structure signatures</H3><BLOCKQUOTE>
<PRE>
(* STREAM: signature for a lazy stream.*)

signature STREAM =
sig
  type 'a stream
  val streamify : (unit -&gt; 'a) -&gt; 'a stream
  val cons : 'a * 'a stream -&gt; 'a stream
  val get : 'a stream -&gt; 'a * 'a stream
end

(* LR_TABLE: signature for an LR Table.*)

signature LR_TABLE =
sig
  datatype ('a,'b) pairlist
    = EMPTY
    | PAIR of 'a * 'b * ('a,'b) pairlist
  datatype state = STATE of int
  datatype term = T of int
  datatype nonterm = NT of int
  datatype action = SHIFT of state
                  | REDUCE of int
                  | ACCEPT
                  | ERROR
  type table
        
  val numStates : table -&gt; int
  val numRules : table -&gt; int
  val describeActions : table -&gt; state -&gt;
                          (term,action) pairlist * action
  val describeGoto : table -&gt; state -&gt;
                       (nonterm,state) pairlist
  val action : table -&gt; state * term -&gt; action
  val goto : table -&gt; state * nonterm -&gt; state
  val initialState : table -&gt; state
  exception Goto of state * nonterm

  val mkLrTable :
      {actions : ((term,action) pairlist * action) array,
       gotos : (nonterm,state) pairlist array,
       numStates : int, numRules : int,
       initialState : state} -&gt; table
end

(* TOKEN: signature for the internal structure of a token.*)

signature TOKEN =
sig
  structure LrTable : LR_TABLE
  datatype ('a,'b) token = TOKEN of LrTable.term *
                                    ('a * 'b * 'b)
  val sameToken : ('a,'b) token * ('a,'b) token -&gt; bool
end

(* LR_PARSER: signature for a polymorphic LR parser *)

signature LR_PARSER =
sig
  structure Stream: STREAM
  structure LrTable : LR_TABLE
  structure Token : TOKEN

  sharing LrTable = Token.LrTable

  exception ParseError

  val parse:
       {table : LrTable.table,
        lexer : ('b,'c) Token.token Stream.stream,
        arg: 'arg,
        saction : int *
                 'c *
                 (LrTable.state * ('b * 'c * 'c)) list * 
                 'arg -&gt;
                  LrTable.nonterm *
                  ('b * 'c * 'c) *
                  ((LrTable.state *('b * 'c * 'c)) list),
        void : 'b,
        ec: {is_keyword : LrTable.term -&gt; bool,
             noShift : LrTable.term -&gt; bool,
             preferred_subst:LrTable.term -&gt; LrTable.term list,
             preferred_insert : LrTable.term -&gt; bool,
             errtermvalue : LrTable.term -&gt; 'b,
             showTerminal : LrTable.term -&gt; string,
             terms: LrTable.term list,
             error : string * 'c * 'c -&gt; unit
            },
        lookahead : int (* max amount of lookahead used in
                         * error correction *)
       } -&gt; 'b * (('b,'c) Token.token Stream.stream)
end
</PRE>
</BLOCKQUOTE><A NAME="toc18"></A>
<H3>8.2&nbsp;&nbsp; Lexers</H3>Lexers for use with ML-Yacc's output must match one of these signatures.<BR>
<BR>
<BLOCKQUOTE>
<PRE>
signature LEXER =
sig
  structure UserDeclarations :
    sig
      type ('a,'b) token
      type pos
      type svalue
    end
  val makeLexer : (int -&gt; string) -&gt; unit -&gt; 
       (UserDeclarations.svalue, UserDeclarations.pos)
       UserDeclarations.token
end

(* ARG_LEXER: the %arg option of ML-Lex allows users to
   produce lexers which also take an argument before
   yielding a function from unit to a token.
*)

signature ARG_LEXER =
sig
  structure UserDeclarations :
    sig
      type ('a,'b) token
      type pos
      type svalue
      type arg
    end
  val makeLexer :
      (int -&gt; string) -&gt;
      UserDeclarations.arg -&gt;
      unit -&gt; 
       (UserDeclarations.svalue, UserDeclarations.pos)
       UserDeclarations.token
end
</PRE>
</BLOCKQUOTE><A NAME="toc19"></A>
<H3>8.3&nbsp;&nbsp; Signatures for the functor produced by ML-Yacc</H3>The following signature is used in signatures generated by
ML-Yacc:
<BLOCKQUOTE>
<PRE>
(* PARSER_DATA: the signature of ParserData structures in
   {n}LrValsFun functor produced by ML-Yacc. All such
   structures match this signature. *)

signature PARSER_DATA =
sig
  type pos       (* the type of line numbers *)
  type svalue    (* the type of semantic values *)
  type arg       (* the type of the user-supplied *)
                 (* argument to the parser *)
  type result

  structure LrTable : LR_TABLE
  structure Token : TOKEN
  sharing Token.LrTable = LrTable

  structure Actions : 
    sig
      val actions : int * pos *
       (LrTable.state * (svalue * pos * pos)) list * arg -&gt;
               LrTable.nonterm * (svalue * pos * pos) *
             ((LrTable.state *(svalue * pos * pos)) list)
      val void : svalue
      val extract : svalue -&gt; result
    end

  (* structure EC contains information used to improve
     error recovery in an error-correcting parser *)

  structure EC :
    sig
      val is_keyword : LrTable.term -&gt; bool
      val noShift : LrTable.term -&gt; bool
      val preferred_subst: LrTable.term -&gt; LrTable.term list
      val preferred_insert : LrTable.term -&gt; bool
      val errtermvalue : LrTable.term -&gt; svalue
      val showTerminal : LrTable.term -&gt; string
      val terms: LrTable.term list
    end

  (* table is the LR table for the parser *)

  val table : LrTable.table
end
</PRE>
</BLOCKQUOTE>ML-Yacc generates these two signatures:
<BLOCKQUOTE>
<PRE>
(* printed out in .sig file created by parser generator: *)

signature {n}_TOKENS = 
sig
  type ('a,'b) token
  type svalue
  ...
end

signature {n}_LRVALS =
sig
  structure Tokens : {n}_TOKENS
  structure ParserData : PARSER_DATA
  sharing type ParserData.Token.token = Tokens.token
  sharing type ParserData.svalue = Tokens.svalue
end
</PRE>
</BLOCKQUOTE>
<A NAME="toc20"></A>
<H3>8.4&nbsp;&nbsp; User parser signatures</H3>Parsers created by applying the Join functor will match this signature:
<BLOCKQUOTE>
<PRE>
signature PARSER =
sig
  structure Token : TOKEN
  structure Stream : STREAM
  exception ParseError

  type pos    (* pos is the type of line numbers *)
  type result (* value returned by the parser *)
  type arg    (* type of the user-supplied argument  *)
  type svalue (* the types of semantic values *)

  val makeLexer : (int -&gt; string) -&gt;
                   (svalue,pos) Token.token Stream.stream

  val parse :
      int * ((svalue,pos) Token.token Stream.stream) *
      (string * pos * pos -&gt; unit) * arg -&gt;
          result * (svalue,pos) Token.token Stream.stream
  val sameToken :
    (svalue,pos) Token.token * (svalue,pos) Token.token -&gt;
        bool
end
</PRE>
</BLOCKQUOTE>
Parsers created by applying the JoinWithArg functor will match this
signature:
<BLOCKQUOTE>
<PRE>
signature ARG_PARSER = 
sig
  structure Token : TOKEN
  structure Stream : STREAM
  exception ParseError

  type arg
  type lexarg
  type pos
  type result
  type svalue

  val makeLexer : (int -&gt; string) -&gt; lexarg -&gt;
                     (svalue,pos) Token.token Stream.stream
  val parse : int *
              ((svalue,pos) Token.token Stream.stream) *
              (string * pos * pos -&gt; unit) *
              arg -&gt;
               result * (svalue,pos) Token.token Stream.stream
  val sameToken :
      (svalue,pos) Token.token * (svalue,pos) Token.token -&gt;
           bool
end
</PRE>
</BLOCKQUOTE><HR>
<A HREF="mlyacc007.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="mlyacc009.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
<A HREF="index.html"><IMG SRC ="contents_motif.gif" ALT="Contents"></A>
</BODY>
</HTML>
